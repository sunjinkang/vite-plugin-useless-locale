const wn = require("fs");
var zt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Mu(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function Pt(e) {
  if (typeof e != "string")
    throw new TypeError("Path must be a string. Received " + JSON.stringify(e));
}
function So(e, t) {
  for (var r = "", i = 0, s = -1, n = 0, a, o = 0; o <= e.length; ++o) {
    if (o < e.length)
      a = e.charCodeAt(o);
    else {
      if (a === 47)
        break;
      a = 47;
    }
    if (a === 47) {
      if (!(s === o - 1 || n === 1))
        if (s !== o - 1 && n === 2) {
          if (r.length < 2 || i !== 2 || r.charCodeAt(r.length - 1) !== 46 || r.charCodeAt(r.length - 2) !== 46) {
            if (r.length > 2) {
              var l = r.lastIndexOf("/");
              if (l !== r.length - 1) {
                l === -1 ? (r = "", i = 0) : (r = r.slice(0, l), i = r.length - 1 - r.lastIndexOf("/")), s = o, n = 0;
                continue;
              }
            } else if (r.length === 2 || r.length === 1) {
              r = "", i = 0, s = o, n = 0;
              continue;
            }
          }
          t && (r.length > 0 ? r += "/.." : r = "..", i = 2);
        } else
          r.length > 0 ? r += "/" + e.slice(s + 1, o) : r = e.slice(s + 1, o), i = o - s - 1;
      s = o, n = 0;
    } else
      a === 46 && n !== -1 ? ++n : n = -1;
  }
  return r;
}
function Nm(e, t) {
  var r = t.dir || t.root, i = t.base || (t.name || "") + (t.ext || "");
  return r ? r === t.root ? r + i : r + e + i : i;
}
var Or = {
  // path.resolve([from ...], to)
  resolve: function() {
    for (var t = "", r = !1, i, s = arguments.length - 1; s >= -1 && !r; s--) {
      var n;
      s >= 0 ? n = arguments[s] : (i === void 0 && (i = process.cwd()), n = i), Pt(n), n.length !== 0 && (t = n + "/" + t, r = n.charCodeAt(0) === 47);
    }
    return t = So(t, !r), r ? t.length > 0 ? "/" + t : "/" : t.length > 0 ? t : ".";
  },
  normalize: function(t) {
    if (Pt(t), t.length === 0)
      return ".";
    var r = t.charCodeAt(0) === 47, i = t.charCodeAt(t.length - 1) === 47;
    return t = So(t, !r), t.length === 0 && !r && (t = "."), t.length > 0 && i && (t += "/"), r ? "/" + t : t;
  },
  isAbsolute: function(t) {
    return Pt(t), t.length > 0 && t.charCodeAt(0) === 47;
  },
  join: function() {
    if (arguments.length === 0)
      return ".";
    for (var t, r = 0; r < arguments.length; ++r) {
      var i = arguments[r];
      Pt(i), i.length > 0 && (t === void 0 ? t = i : t += "/" + i);
    }
    return t === void 0 ? "." : Or.normalize(t);
  },
  relative: function(t, r) {
    if (Pt(t), Pt(r), t === r || (t = Or.resolve(t), r = Or.resolve(r), t === r))
      return "";
    for (var i = 1; i < t.length && t.charCodeAt(i) === 47; ++i)
      ;
    for (var s = t.length, n = s - i, a = 1; a < r.length && r.charCodeAt(a) === 47; ++a)
      ;
    for (var o = r.length, l = o - a, u = n < l ? n : l, c = -1, p = 0; p <= u; ++p) {
      if (p === u) {
        if (l > u) {
          if (r.charCodeAt(a + p) === 47)
            return r.slice(a + p + 1);
          if (p === 0)
            return r.slice(a + p);
        } else
          n > u && (t.charCodeAt(i + p) === 47 ? c = p : p === 0 && (c = 0));
        break;
      }
      var h = t.charCodeAt(i + p), y = r.charCodeAt(a + p);
      if (h !== y)
        break;
      h === 47 && (c = p);
    }
    var P = "";
    for (p = i + c + 1; p <= s; ++p)
      (p === s || t.charCodeAt(p) === 47) && (P.length === 0 ? P += ".." : P += "/..");
    return P.length > 0 ? P + r.slice(a + c) : (a += c, r.charCodeAt(a) === 47 && ++a, r.slice(a));
  },
  _makeLong: function(t) {
    return t;
  },
  dirname: function(t) {
    if (Pt(t), t.length === 0)
      return ".";
    for (var r = t.charCodeAt(0), i = r === 47, s = -1, n = !0, a = t.length - 1; a >= 1; --a)
      if (r = t.charCodeAt(a), r === 47) {
        if (!n) {
          s = a;
          break;
        }
      } else
        n = !1;
    return s === -1 ? i ? "/" : "." : i && s === 1 ? "//" : t.slice(0, s);
  },
  basename: function(t, r) {
    if (r !== void 0 && typeof r != "string")
      throw new TypeError('"ext" argument must be a string');
    Pt(t);
    var i = 0, s = -1, n = !0, a;
    if (r !== void 0 && r.length > 0 && r.length <= t.length) {
      if (r.length === t.length && r === t)
        return "";
      var o = r.length - 1, l = -1;
      for (a = t.length - 1; a >= 0; --a) {
        var u = t.charCodeAt(a);
        if (u === 47) {
          if (!n) {
            i = a + 1;
            break;
          }
        } else
          l === -1 && (n = !1, l = a + 1), o >= 0 && (u === r.charCodeAt(o) ? --o === -1 && (s = a) : (o = -1, s = l));
      }
      return i === s ? s = l : s === -1 && (s = t.length), t.slice(i, s);
    } else {
      for (a = t.length - 1; a >= 0; --a)
        if (t.charCodeAt(a) === 47) {
          if (!n) {
            i = a + 1;
            break;
          }
        } else
          s === -1 && (n = !1, s = a + 1);
      return s === -1 ? "" : t.slice(i, s);
    }
  },
  extname: function(t) {
    Pt(t);
    for (var r = -1, i = 0, s = -1, n = !0, a = 0, o = t.length - 1; o >= 0; --o) {
      var l = t.charCodeAt(o);
      if (l === 47) {
        if (!n) {
          i = o + 1;
          break;
        }
        continue;
      }
      s === -1 && (n = !1, s = o + 1), l === 46 ? r === -1 ? r = o : a !== 1 && (a = 1) : r !== -1 && (a = -1);
    }
    return r === -1 || s === -1 || // We saw a non-dot character immediately before the dot
    a === 0 || // The (right-most) trimmed path component is exactly '..'
    a === 1 && r === s - 1 && r === i + 1 ? "" : t.slice(r, s);
  },
  format: function(t) {
    if (t === null || typeof t != "object")
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t);
    return Nm("/", t);
  },
  parse: function(t) {
    Pt(t);
    var r = { root: "", dir: "", base: "", ext: "", name: "" };
    if (t.length === 0)
      return r;
    var i = t.charCodeAt(0), s = i === 47, n;
    s ? (r.root = "/", n = 1) : n = 0;
    for (var a = -1, o = 0, l = -1, u = !0, c = t.length - 1, p = 0; c >= n; --c) {
      if (i = t.charCodeAt(c), i === 47) {
        if (!u) {
          o = c + 1;
          break;
        }
        continue;
      }
      l === -1 && (u = !1, l = c + 1), i === 46 ? a === -1 ? a = c : p !== 1 && (p = 1) : a !== -1 && (p = -1);
    }
    return a === -1 || l === -1 || // We saw a non-dot character immediately before the dot
    p === 0 || // The (right-most) trimmed path component is exactly '..'
    p === 1 && a === l - 1 && a === o + 1 ? l !== -1 && (o === 0 && s ? r.base = r.name = t.slice(1, l) : r.base = r.name = t.slice(o, l)) : (o === 0 && s ? (r.name = t.slice(1, a), r.base = t.slice(1, l)) : (r.name = t.slice(o, a), r.base = t.slice(o, l)), r.ext = t.slice(a, l)), o > 0 ? r.dir = t.slice(0, o - 1) : s && (r.dir = "/"), r;
  },
  sep: "/",
  delimiter: ":",
  win32: null,
  posix: null
};
Or.posix = Or;
var _m = Or;
const Bu = /* @__PURE__ */ Mu(_m);
var pr = {};
Object.defineProperty(pr, "__esModule", {
  value: !0
});
function as(e, t) {
  if (e == null)
    return {};
  var r = {}, i = Object.keys(e), s, n;
  for (n = 0; n < i.length; n++)
    s = i[n], !(t.indexOf(s) >= 0) && (r[s] = e[s]);
  return r;
}
class Jt {
  constructor(t, r, i) {
    this.line = void 0, this.column = void 0, this.index = void 0, this.line = t, this.column = r, this.index = i;
  }
}
class os {
  constructor(t, r) {
    this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = t, this.end = r;
  }
}
function nt(e, t) {
  const {
    line: r,
    column: i,
    index: s
  } = e;
  return new Jt(r, i + t, s + t);
}
var On = {
  SyntaxError: "BABEL_PARSER_SYNTAX_ERROR",
  SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
};
const Dm = (e, t = e.length - 1) => ({
  get() {
    return e.reduce((r, i) => r[i], this);
  },
  set(r) {
    e.reduce((i, s, n) => n === t ? i[s] = r : i[s], this);
  }
}), km = (e, t, r) => Object.keys(r).map((i) => [i, r[i]]).filter(([, i]) => !!i).map(([i, s]) => [i, typeof s == "function" ? {
  value: s,
  enumerable: !1
} : typeof s.reflect == "string" ? Object.assign({}, s, Dm(s.reflect.split("."))) : s]).reduce((i, [s, n]) => Object.defineProperty(i, s, Object.assign({
  configurable: !0
}, n)), Object.assign(new e(), t));
var Lm = {
  ImportMetaOutsideModule: {
    message: `import.meta may appear only with 'sourceType: "module"'`,
    code: On.SourceTypeModuleError
  },
  ImportOutsideModule: {
    message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
    code: On.SourceTypeModuleError
  }
};
const bo = {
  ArrayPattern: "array destructuring pattern",
  AssignmentExpression: "assignment expression",
  AssignmentPattern: "assignment expression",
  ArrowFunctionExpression: "arrow function expression",
  ConditionalExpression: "conditional expression",
  CatchClause: "catch clause",
  ForOfStatement: "for-of statement",
  ForInStatement: "for-in statement",
  ForStatement: "for-loop",
  FormalParameters: "function parameter list",
  Identifier: "identifier",
  ImportSpecifier: "import specifier",
  ImportDefaultSpecifier: "import default specifier",
  ImportNamespaceSpecifier: "import namespace specifier",
  ObjectPattern: "object destructuring pattern",
  ParenthesizedExpression: "parenthesized expression",
  RestElement: "rest element",
  UpdateExpression: {
    true: "prefix operation",
    false: "postfix operation"
  },
  VariableDeclarator: "variable declaration",
  YieldExpression: "yield expression"
}, Nn = ({
  type: e,
  prefix: t
}) => e === "UpdateExpression" ? bo.UpdateExpression[String(t)] : bo[e];
var Mm = {
  AccessorIsGenerator: ({
    kind: e
  }) => `A ${e}ter cannot be a generator.`,
  ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
  AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
  AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
  AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
  AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
  AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
  AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
  AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
  BadGetterArity: "A 'get' accessor must not have any formal parameters.",
  BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
  BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
  ConstructorClassField: "Classes may not have a field named 'constructor'.",
  ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
  ConstructorIsAccessor: "Class constructor may not be an accessor.",
  ConstructorIsAsync: "Constructor can't be an async function.",
  ConstructorIsGenerator: "Constructor can't be a generator.",
  DeclarationMissingInitializer: ({
    kind: e
  }) => `Missing initializer in ${e} declaration.`,
  DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
  DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
  DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
  DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
  DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
  DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
  DecoratorStaticBlock: "Decorators can't be used with a static block.",
  DeletePrivateField: "Deleting a private field is not allowed.",
  DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
  DuplicateConstructor: "Duplicate constructor in the same class.",
  DuplicateDefaultExport: "Only one default export allowed per module.",
  DuplicateExport: ({
    exportName: e
  }) => `\`${e}\` has already been exported. Exported identifiers must be unique.`,
  DuplicateProto: "Redefinition of __proto__ property.",
  DuplicateRegExpFlags: "Duplicate regular expression flag.",
  ElementAfterRest: "Rest element must be last element.",
  EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
  ExportBindingIsString: ({
    localName: e,
    exportName: t
  }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${e}' as '${t}' } from 'some-module'\`?`,
  ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
  ForInOfLoopInitializer: ({
    type: e
  }) => `'${e === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`,
  ForInUsing: "For-in loop may not start with 'using' declaration.",
  ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
  ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
  GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
  IllegalBreakContinue: ({
    type: e
  }) => `Unsyntactic ${e === "BreakStatement" ? "break" : "continue"}.`,
  IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
  IllegalReturn: "'return' outside of function.",
  ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.",
  ImportBindingIsString: ({
    importName: e
  }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${e}" as foo }\`?`,
  ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
  ImportCallArity: ({
    maxArgumentCount: e
  }) => `\`import()\` requires exactly ${e === 1 ? "one argument" : "one or two arguments"}.`,
  ImportCallNotNewExpression: "Cannot use new with import(...).",
  ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
  ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
  ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
  ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
  IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
  InvalidBigIntLiteral: "Invalid BigIntLiteral.",
  InvalidCodePoint: "Code point out of bounds.",
  InvalidCoverInitializedName: "Invalid shorthand property initializer.",
  InvalidDecimal: "Invalid decimal.",
  InvalidDigit: ({
    radix: e
  }) => `Expected number in radix ${e}.`,
  InvalidEscapeSequence: "Bad character escape sequence.",
  InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
  InvalidEscapedReservedWord: ({
    reservedWord: e
  }) => `Escape sequence in keyword ${e}.`,
  InvalidIdentifier: ({
    identifierName: e
  }) => `Invalid identifier ${e}.`,
  InvalidLhs: ({
    ancestor: e
  }) => `Invalid left-hand side in ${Nn(e)}.`,
  InvalidLhsBinding: ({
    ancestor: e
  }) => `Binding invalid left-hand side in ${Nn(e)}.`,
  InvalidNumber: "Invalid number.",
  InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
  InvalidOrUnexpectedToken: ({
    unexpected: e
  }) => `Unexpected character '${e}'.`,
  InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
  InvalidPrivateFieldResolution: ({
    identifierName: e
  }) => `Private name #${e} is not defined.`,
  InvalidPropertyBindingPattern: "Binding member expression.",
  InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
  InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
  LabelRedeclaration: ({
    labelName: e
  }) => `Label '${e}' is already declared.`,
  LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.",
  LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
  MalformedRegExpFlags: "Invalid regular expression flag.",
  MissingClassName: "A class name is required.",
  MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
  MissingSemicolon: "Missing semicolon.",
  MissingPlugin: ({
    missingPlugin: e
  }) => `This experimental syntax requires enabling the parser plugin: ${e.map((t) => JSON.stringify(t)).join(", ")}.`,
  MissingOneOfPlugins: ({
    missingPlugin: e
  }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${e.map((t) => JSON.stringify(t)).join(", ")}.`,
  MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
  MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
  ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
  ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
  ModuleAttributesWithDuplicateKeys: ({
    key: e
  }) => `Duplicate key "${e}" is not allowed in module attributes.`,
  ModuleExportNameHasLoneSurrogate: ({
    surrogateCharCode: e
  }) => `An export name cannot include a lone surrogate, found '\\u${e.toString(16)}'.`,
  ModuleExportUndefined: ({
    localName: e
  }) => `Export '${e}' is not defined.`,
  MultipleDefaultsInSwitch: "Multiple default clauses.",
  NewlineAfterThrow: "Illegal newline after throw.",
  NoCatchOrFinally: "Missing catch or finally clause.",
  NumberIdentifier: "Identifier directly after number.",
  NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
  ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
  OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
  OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
  OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
  ParamDupe: "Argument name clash.",
  PatternHasAccessor: "Object pattern can't contain getter or setter.",
  PatternHasMethod: "Object pattern can't contain methods.",
  PrivateInExpectedIn: ({
    identifierName: e
  }) => `Private names are only allowed in property accesses (\`obj.#${e}\`) or in \`in\` expressions (\`#${e} in obj\`).`,
  PrivateNameRedeclaration: ({
    identifierName: e
  }) => `Duplicate private name #${e}.`,
  RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
  RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
  RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
  RecordNoProto: "'__proto__' is not allowed in Record expressions.",
  RestTrailingComma: "Unexpected trailing comma after rest element.",
  SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
  SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
  StaticPrototype: "Classes may not have static property named prototype.",
  SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
  SuperPrivateField: "Private fields can't be accessed on super.",
  TrailingDecorator: "Decorators must be attached to a class element.",
  TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
  TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
  TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
  UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
  UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
  UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
  UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
  UnexpectedKeyword: ({
    keyword: e
  }) => `Unexpected keyword '${e}'.`,
  UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
  UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
  UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
  UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
  UnexpectedPrivateField: "Unexpected private name.",
  UnexpectedReservedWord: ({
    reservedWord: e
  }) => `Unexpected reserved word '${e}'.`,
  UnexpectedSuper: "'super' is only allowed in object methods and classes.",
  UnexpectedToken: ({
    expected: e,
    unexpected: t
  }) => `Unexpected token${t ? ` '${t}'.` : ""}${e ? `, expected "${e}"` : ""}`,
  UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
  UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
  UnsupportedBind: "Binding should be performed on object property.",
  UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
  UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
  UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
  UnsupportedMetaProperty: ({
    target: e,
    onlyValidPropertyName: t
  }) => `The only valid meta property for ${e} is ${e}.${t}.`,
  UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
  UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
  UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
  UnterminatedComment: "Unterminated comment.",
  UnterminatedRegExp: "Unterminated regular expression.",
  UnterminatedString: "Unterminated string constant.",
  UnterminatedTemplate: "Unterminated template.",
  UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
  VarRedeclaration: ({
    identifierName: e
  }) => `Identifier '${e}' has already been declared.`,
  YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
  YieldInParameter: "Yield expression is not allowed in formal parameters.",
  ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
}, Bm = {
  StrictDelete: "Deleting local variable in strict mode.",
  StrictEvalArguments: ({
    referenceName: e
  }) => `Assigning to '${e}' in strict mode.`,
  StrictEvalArgumentsBinding: ({
    bindingName: e
  }) => `Binding '${e}' in strict mode.`,
  StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
  StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
  StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
  StrictWith: "'with' in strict mode."
};
const Fm = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
var jm = {
  PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
  PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
  PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
  PipeTopicUnconfiguredToken: ({
    token: e
  }) => `Invalid topic token ${e}. In order to use ${e} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${e}" }.`,
  PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
  PipeUnparenthesizedBody: ({
    type: e
  }) => `Hack-style pipe body cannot be an unparenthesized ${Nn({
    type: e
  })}; please wrap it in parentheses.`,
  PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
  PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
  PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
  PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
  PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
  PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
};
const Rm = ["toMessage"], $m = ["message"];
function Um(e) {
  let {
    toMessage: t
  } = e, r = as(e, Rm);
  return function i({
    loc: s,
    details: n
  }) {
    return km(SyntaxError, Object.assign({}, r, {
      loc: s
    }), {
      clone(a = {}) {
        const o = a.loc || {};
        return i({
          loc: new Jt("line" in o ? o.line : this.loc.line, "column" in o ? o.column : this.loc.column, "index" in o ? o.index : this.loc.index),
          details: Object.assign({}, this.details, a.details)
        });
      },
      details: {
        value: n,
        enumerable: !1
      },
      message: {
        get() {
          return `${t(this.details)} (${this.loc.line}:${this.loc.column})`;
        },
        set(a) {
          Object.defineProperty(this, "message", {
            value: a
          });
        }
      },
      pos: {
        reflect: "loc.index",
        enumerable: !0
      },
      missingPlugin: "missingPlugin" in n && {
        reflect: "details.missingPlugin",
        enumerable: !0
      }
    });
  };
}
function Lt(e, t) {
  if (Array.isArray(e))
    return (i) => Lt(i, e[0]);
  const r = {};
  for (const i of Object.keys(e)) {
    const s = e[i], n = typeof s == "string" ? {
      message: () => s
    } : typeof s == "function" ? {
      message: s
    } : s, {
      message: a
    } = n, o = as(n, $m), l = typeof a == "string" ? () => a : a;
    r[i] = Um(Object.assign({
      code: On.SyntaxError,
      reasonCode: i,
      toMessage: l
    }, t ? {
      syntaxPlugin: t
    } : {}, o));
  }
  return r;
}
const N = Object.assign({}, Lt(Lm), Lt(Mm), Lt(Bm), Lt`pipelineOperator`(jm)), {
  defineProperty: Vm
} = Object, go = (e, t) => Vm(e, t, {
  enumerable: !1,
  value: e[t]
});
function Fr(e) {
  return e.loc.start && go(e.loc.start, "index"), e.loc.end && go(e.loc.end, "index"), e;
}
var Km = (e) => class extends e {
  parse() {
    const r = Fr(super.parse());
    return this.options.tokens && (r.tokens = r.tokens.map(Fr)), r;
  }
  parseRegExpLiteral({
    pattern: r,
    flags: i
  }) {
    let s = null;
    try {
      s = new RegExp(r, i);
    } catch {
    }
    const n = this.estreeParseLiteral(s);
    return n.regex = {
      pattern: r,
      flags: i
    }, n;
  }
  parseBigIntLiteral(r) {
    let i;
    try {
      i = BigInt(r);
    } catch {
      i = null;
    }
    const s = this.estreeParseLiteral(i);
    return s.bigint = String(s.value || r), s;
  }
  parseDecimalLiteral(r) {
    const s = this.estreeParseLiteral(null);
    return s.decimal = String(s.value || r), s;
  }
  estreeParseLiteral(r) {
    return this.parseLiteral(r, "Literal");
  }
  parseStringLiteral(r) {
    return this.estreeParseLiteral(r);
  }
  parseNumericLiteral(r) {
    return this.estreeParseLiteral(r);
  }
  parseNullLiteral() {
    return this.estreeParseLiteral(null);
  }
  parseBooleanLiteral(r) {
    return this.estreeParseLiteral(r);
  }
  directiveToStmt(r) {
    const i = r.value;
    delete r.value, i.type = "Literal", i.raw = i.extra.raw, i.value = i.extra.expressionValue;
    const s = r;
    return s.type = "ExpressionStatement", s.expression = i, s.directive = i.extra.rawValue, delete i.extra, s;
  }
  initFunction(r, i) {
    super.initFunction(r, i), r.expression = !1;
  }
  checkDeclaration(r) {
    r != null && this.isObjectProperty(r) ? this.checkDeclaration(r.value) : super.checkDeclaration(r);
  }
  getObjectOrClassMethodParams(r) {
    return r.value.params;
  }
  isValidDirective(r) {
    var i;
    return r.type === "ExpressionStatement" && r.expression.type === "Literal" && typeof r.expression.value == "string" && !((i = r.expression.extra) != null && i.parenthesized);
  }
  parseBlockBody(r, i, s, n, a) {
    super.parseBlockBody(r, i, s, n, a);
    const o = r.directives.map((l) => this.directiveToStmt(l));
    r.body = o.concat(r.body), delete r.directives;
  }
  pushClassMethod(r, i, s, n, a, o) {
    this.parseMethod(i, s, n, a, o, "ClassMethod", !0), i.typeParameters && (i.value.typeParameters = i.typeParameters, delete i.typeParameters), r.body.push(i);
  }
  parsePrivateName() {
    const r = super.parsePrivateName();
    return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(r) : r;
  }
  convertPrivateNameToPrivateIdentifier(r) {
    const i = super.getPrivateNameSV(r);
    return r = r, delete r.id, r.name = i, r.type = "PrivateIdentifier", r;
  }
  isPrivateName(r) {
    return this.getPluginOption("estree", "classFeatures") ? r.type === "PrivateIdentifier" : super.isPrivateName(r);
  }
  getPrivateNameSV(r) {
    return this.getPluginOption("estree", "classFeatures") ? r.name : super.getPrivateNameSV(r);
  }
  parseLiteral(r, i) {
    const s = super.parseLiteral(r, i);
    return s.raw = s.extra.raw, delete s.extra, s;
  }
  parseFunctionBody(r, i, s = !1) {
    super.parseFunctionBody(r, i, s), r.expression = r.body.type !== "BlockStatement";
  }
  parseMethod(r, i, s, n, a, o, l = !1) {
    let u = this.startNode();
    return u.kind = r.kind, u = super.parseMethod(u, i, s, n, a, o, l), u.type = "FunctionExpression", delete u.kind, r.value = u, o === "ClassPrivateMethod" && (r.computed = !1), this.finishNode(r, "MethodDefinition");
  }
  parseClassProperty(...r) {
    const i = super.parseClassProperty(...r);
    return this.getPluginOption("estree", "classFeatures") && (i.type = "PropertyDefinition"), i;
  }
  parseClassPrivateProperty(...r) {
    const i = super.parseClassPrivateProperty(...r);
    return this.getPluginOption("estree", "classFeatures") && (i.type = "PropertyDefinition", i.computed = !1), i;
  }
  parseObjectMethod(r, i, s, n, a) {
    const o = super.parseObjectMethod(r, i, s, n, a);
    return o && (o.type = "Property", o.kind === "method" && (o.kind = "init"), o.shorthand = !1), o;
  }
  parseObjectProperty(r, i, s, n) {
    const a = super.parseObjectProperty(r, i, s, n);
    return a && (a.kind = "init", a.type = "Property"), a;
  }
  isValidLVal(r, i, s) {
    return r === "Property" ? "value" : super.isValidLVal(r, i, s);
  }
  isAssignable(r, i) {
    return r != null && this.isObjectProperty(r) ? this.isAssignable(r.value, i) : super.isAssignable(r, i);
  }
  toAssignable(r, i = !1) {
    if (r != null && this.isObjectProperty(r)) {
      const {
        key: s,
        value: n
      } = r;
      this.isPrivateName(s) && this.classScope.usePrivateName(this.getPrivateNameSV(s), s.loc.start), this.toAssignable(n, i);
    } else
      super.toAssignable(r, i);
  }
  toAssignableObjectExpressionProp(r, i, s) {
    r.kind === "get" || r.kind === "set" ? this.raise(N.PatternHasAccessor, {
      at: r.key
    }) : r.method ? this.raise(N.PatternHasMethod, {
      at: r.key
    }) : super.toAssignableObjectExpressionProp(r, i, s);
  }
  finishCallExpression(r, i) {
    const s = super.finishCallExpression(r, i);
    if (s.callee.type === "Import") {
      if (s.type = "ImportExpression", s.source = s.arguments[0], this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
        var n;
        s.attributes = (n = s.arguments[1]) != null ? n : null;
      }
      delete s.arguments, delete s.callee;
    }
    return s;
  }
  toReferencedArguments(r) {
    r.type !== "ImportExpression" && super.toReferencedArguments(r);
  }
  parseExport(r, i) {
    const s = this.state.lastTokStartLoc, n = super.parseExport(r, i);
    switch (n.type) {
      case "ExportAllDeclaration":
        n.exported = null;
        break;
      case "ExportNamedDeclaration":
        n.specifiers.length === 1 && n.specifiers[0].type === "ExportNamespaceSpecifier" && (n.type = "ExportAllDeclaration", n.exported = n.specifiers[0].exported, delete n.specifiers);
      case "ExportDefaultDeclaration":
        {
          var a;
          const {
            declaration: o
          } = n;
          (o == null ? void 0 : o.type) === "ClassDeclaration" && ((a = o.decorators) == null ? void 0 : a.length) > 0 && o.start === n.start && this.resetStartLocation(n, s);
        }
        break;
    }
    return n;
  }
  parseSubscript(r, i, s, n) {
    const a = super.parseSubscript(r, i, s, n);
    if (n.optionalChainMember) {
      if ((a.type === "OptionalMemberExpression" || a.type === "OptionalCallExpression") && (a.type = a.type.substring(8)), n.stop) {
        const o = this.startNodeAtNode(a);
        return o.expression = a, this.finishNode(o, "ChainExpression");
      }
    } else
      (a.type === "MemberExpression" || a.type === "CallExpression") && (a.optional = !1);
    return a;
  }
  hasPropertyAsPrivateName(r) {
    return r.type === "ChainExpression" && (r = r.expression), super.hasPropertyAsPrivateName(r);
  }
  isObjectProperty(r) {
    return r.type === "Property" && r.kind === "init" && !r.method;
  }
  isObjectMethod(r) {
    return r.method || r.kind === "get" || r.kind === "set";
  }
  finishNodeAt(r, i, s) {
    return Fr(super.finishNodeAt(r, i, s));
  }
  resetStartLocation(r, i) {
    super.resetStartLocation(r, i), Fr(r);
  }
  resetEndLocation(r, i = this.state.lastTokEndLoc) {
    super.resetEndLocation(r, i), Fr(r);
  }
};
class Gr {
  constructor(t, r) {
    this.token = void 0, this.preserveSpace = void 0, this.token = t, this.preserveSpace = !!r;
  }
}
const Be = {
  brace: new Gr("{"),
  j_oTag: new Gr("<tag"),
  j_cTag: new Gr("</tag"),
  j_expr: new Gr("<tag>...</tag>", !0)
};
Be.template = new Gr("`", !0);
const Ie = !0, se = !0, an = !0, jr = !0, Ut = !0, qm = !0;
class Fu {
  constructor(t, r = {}) {
    this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = t, this.keyword = r.keyword, this.beforeExpr = !!r.beforeExpr, this.startsExpr = !!r.startsExpr, this.rightAssociative = !!r.rightAssociative, this.isLoop = !!r.isLoop, this.isAssign = !!r.isAssign, this.prefix = !!r.prefix, this.postfix = !!r.postfix, this.binop = r.binop != null ? r.binop : null, this.updateContext = null;
  }
}
const Zn = /* @__PURE__ */ new Map();
function Ne(e, t = {}) {
  t.keyword = e;
  const r = de(e, t);
  return Zn.set(e, r), r;
}
function rt(e, t) {
  return de(e, {
    beforeExpr: Ie,
    binop: t
  });
}
let ti = -1;
const _t = [], ea = [], ta = [], ra = [], ia = [], sa = [];
function de(e, t = {}) {
  var r, i, s, n;
  return ++ti, ea.push(e), ta.push((r = t.binop) != null ? r : -1), ra.push((i = t.beforeExpr) != null ? i : !1), ia.push((s = t.startsExpr) != null ? s : !1), sa.push((n = t.prefix) != null ? n : !1), _t.push(new Fu(e, t)), ti;
}
function Oe(e, t = {}) {
  var r, i, s, n;
  return ++ti, Zn.set(e, ti), ea.push(e), ta.push((r = t.binop) != null ? r : -1), ra.push((i = t.beforeExpr) != null ? i : !1), ia.push((s = t.startsExpr) != null ? s : !1), sa.push((n = t.prefix) != null ? n : !1), _t.push(new Fu("name", t)), ti;
}
const Wm = {
  bracketL: de("[", {
    beforeExpr: Ie,
    startsExpr: se
  }),
  bracketHashL: de("#[", {
    beforeExpr: Ie,
    startsExpr: se
  }),
  bracketBarL: de("[|", {
    beforeExpr: Ie,
    startsExpr: se
  }),
  bracketR: de("]"),
  bracketBarR: de("|]"),
  braceL: de("{", {
    beforeExpr: Ie,
    startsExpr: se
  }),
  braceBarL: de("{|", {
    beforeExpr: Ie,
    startsExpr: se
  }),
  braceHashL: de("#{", {
    beforeExpr: Ie,
    startsExpr: se
  }),
  braceR: de("}"),
  braceBarR: de("|}"),
  parenL: de("(", {
    beforeExpr: Ie,
    startsExpr: se
  }),
  parenR: de(")"),
  comma: de(",", {
    beforeExpr: Ie
  }),
  semi: de(";", {
    beforeExpr: Ie
  }),
  colon: de(":", {
    beforeExpr: Ie
  }),
  doubleColon: de("::", {
    beforeExpr: Ie
  }),
  dot: de("."),
  question: de("?", {
    beforeExpr: Ie
  }),
  questionDot: de("?."),
  arrow: de("=>", {
    beforeExpr: Ie
  }),
  template: de("template"),
  ellipsis: de("...", {
    beforeExpr: Ie
  }),
  backQuote: de("`", {
    startsExpr: se
  }),
  dollarBraceL: de("${", {
    beforeExpr: Ie,
    startsExpr: se
  }),
  templateTail: de("...`", {
    startsExpr: se
  }),
  templateNonTail: de("...${", {
    beforeExpr: Ie,
    startsExpr: se
  }),
  at: de("@"),
  hash: de("#", {
    startsExpr: se
  }),
  interpreterDirective: de("#!..."),
  eq: de("=", {
    beforeExpr: Ie,
    isAssign: jr
  }),
  assign: de("_=", {
    beforeExpr: Ie,
    isAssign: jr
  }),
  slashAssign: de("_=", {
    beforeExpr: Ie,
    isAssign: jr
  }),
  xorAssign: de("_=", {
    beforeExpr: Ie,
    isAssign: jr
  }),
  moduloAssign: de("_=", {
    beforeExpr: Ie,
    isAssign: jr
  }),
  incDec: de("++/--", {
    prefix: Ut,
    postfix: qm,
    startsExpr: se
  }),
  bang: de("!", {
    beforeExpr: Ie,
    prefix: Ut,
    startsExpr: se
  }),
  tilde: de("~", {
    beforeExpr: Ie,
    prefix: Ut,
    startsExpr: se
  }),
  doubleCaret: de("^^", {
    startsExpr: se
  }),
  doubleAt: de("@@", {
    startsExpr: se
  }),
  pipeline: rt("|>", 0),
  nullishCoalescing: rt("??", 1),
  logicalOR: rt("||", 1),
  logicalAND: rt("&&", 2),
  bitwiseOR: rt("|", 3),
  bitwiseXOR: rt("^", 4),
  bitwiseAND: rt("&", 5),
  equality: rt("==/!=/===/!==", 6),
  lt: rt("</>/<=/>=", 7),
  gt: rt("</>/<=/>=", 7),
  relational: rt("</>/<=/>=", 7),
  bitShift: rt("<</>>/>>>", 8),
  bitShiftL: rt("<</>>/>>>", 8),
  bitShiftR: rt("<</>>/>>>", 8),
  plusMin: de("+/-", {
    beforeExpr: Ie,
    binop: 9,
    prefix: Ut,
    startsExpr: se
  }),
  modulo: de("%", {
    binop: 10,
    startsExpr: se
  }),
  star: de("*", {
    binop: 10
  }),
  slash: rt("/", 10),
  exponent: de("**", {
    beforeExpr: Ie,
    binop: 11,
    rightAssociative: !0
  }),
  _in: Ne("in", {
    beforeExpr: Ie,
    binop: 7
  }),
  _instanceof: Ne("instanceof", {
    beforeExpr: Ie,
    binop: 7
  }),
  _break: Ne("break"),
  _case: Ne("case", {
    beforeExpr: Ie
  }),
  _catch: Ne("catch"),
  _continue: Ne("continue"),
  _debugger: Ne("debugger"),
  _default: Ne("default", {
    beforeExpr: Ie
  }),
  _else: Ne("else", {
    beforeExpr: Ie
  }),
  _finally: Ne("finally"),
  _function: Ne("function", {
    startsExpr: se
  }),
  _if: Ne("if"),
  _return: Ne("return", {
    beforeExpr: Ie
  }),
  _switch: Ne("switch"),
  _throw: Ne("throw", {
    beforeExpr: Ie,
    prefix: Ut,
    startsExpr: se
  }),
  _try: Ne("try"),
  _var: Ne("var"),
  _const: Ne("const"),
  _with: Ne("with"),
  _new: Ne("new", {
    beforeExpr: Ie,
    startsExpr: se
  }),
  _this: Ne("this", {
    startsExpr: se
  }),
  _super: Ne("super", {
    startsExpr: se
  }),
  _class: Ne("class", {
    startsExpr: se
  }),
  _extends: Ne("extends", {
    beforeExpr: Ie
  }),
  _export: Ne("export"),
  _import: Ne("import", {
    startsExpr: se
  }),
  _null: Ne("null", {
    startsExpr: se
  }),
  _true: Ne("true", {
    startsExpr: se
  }),
  _false: Ne("false", {
    startsExpr: se
  }),
  _typeof: Ne("typeof", {
    beforeExpr: Ie,
    prefix: Ut,
    startsExpr: se
  }),
  _void: Ne("void", {
    beforeExpr: Ie,
    prefix: Ut,
    startsExpr: se
  }),
  _delete: Ne("delete", {
    beforeExpr: Ie,
    prefix: Ut,
    startsExpr: se
  }),
  _do: Ne("do", {
    isLoop: an,
    beforeExpr: Ie
  }),
  _for: Ne("for", {
    isLoop: an
  }),
  _while: Ne("while", {
    isLoop: an
  }),
  _as: Oe("as", {
    startsExpr: se
  }),
  _assert: Oe("assert", {
    startsExpr: se
  }),
  _async: Oe("async", {
    startsExpr: se
  }),
  _await: Oe("await", {
    startsExpr: se
  }),
  _from: Oe("from", {
    startsExpr: se
  }),
  _get: Oe("get", {
    startsExpr: se
  }),
  _let: Oe("let", {
    startsExpr: se
  }),
  _meta: Oe("meta", {
    startsExpr: se
  }),
  _of: Oe("of", {
    startsExpr: se
  }),
  _sent: Oe("sent", {
    startsExpr: se
  }),
  _set: Oe("set", {
    startsExpr: se
  }),
  _static: Oe("static", {
    startsExpr: se
  }),
  _using: Oe("using", {
    startsExpr: se
  }),
  _yield: Oe("yield", {
    startsExpr: se
  }),
  _asserts: Oe("asserts", {
    startsExpr: se
  }),
  _checks: Oe("checks", {
    startsExpr: se
  }),
  _exports: Oe("exports", {
    startsExpr: se
  }),
  _global: Oe("global", {
    startsExpr: se
  }),
  _implements: Oe("implements", {
    startsExpr: se
  }),
  _intrinsic: Oe("intrinsic", {
    startsExpr: se
  }),
  _infer: Oe("infer", {
    startsExpr: se
  }),
  _is: Oe("is", {
    startsExpr: se
  }),
  _mixins: Oe("mixins", {
    startsExpr: se
  }),
  _proto: Oe("proto", {
    startsExpr: se
  }),
  _require: Oe("require", {
    startsExpr: se
  }),
  _satisfies: Oe("satisfies", {
    startsExpr: se
  }),
  _keyof: Oe("keyof", {
    startsExpr: se
  }),
  _readonly: Oe("readonly", {
    startsExpr: se
  }),
  _unique: Oe("unique", {
    startsExpr: se
  }),
  _abstract: Oe("abstract", {
    startsExpr: se
  }),
  _declare: Oe("declare", {
    startsExpr: se
  }),
  _enum: Oe("enum", {
    startsExpr: se
  }),
  _module: Oe("module", {
    startsExpr: se
  }),
  _namespace: Oe("namespace", {
    startsExpr: se
  }),
  _interface: Oe("interface", {
    startsExpr: se
  }),
  _type: Oe("type", {
    startsExpr: se
  }),
  _opaque: Oe("opaque", {
    startsExpr: se
  }),
  name: de("name", {
    startsExpr: se
  }),
  string: de("string", {
    startsExpr: se
  }),
  num: de("num", {
    startsExpr: se
  }),
  bigint: de("bigint", {
    startsExpr: se
  }),
  decimal: de("decimal", {
    startsExpr: se
  }),
  regexp: de("regexp", {
    startsExpr: se
  }),
  privateName: de("#name", {
    startsExpr: se
  }),
  eof: de("eof"),
  jsxName: de("jsxName"),
  jsxText: de("jsxText", {
    beforeExpr: !0
  }),
  jsxTagStart: de("jsxTagStart", {
    startsExpr: !0
  }),
  jsxTagEnd: de("jsxTagEnd"),
  placeholder: de("%%", {
    startsExpr: !0
  })
};
function ke(e) {
  return e >= 93 && e <= 130;
}
function Ym(e) {
  return e <= 92;
}
function bt(e) {
  return e >= 58 && e <= 130;
}
function ju(e) {
  return e >= 58 && e <= 134;
}
function Xm(e) {
  return ra[e];
}
function _n(e) {
  return ia[e];
}
function Jm(e) {
  return e >= 29 && e <= 33;
}
function Eo(e) {
  return e >= 127 && e <= 129;
}
function Hm(e) {
  return e >= 90 && e <= 92;
}
function na(e) {
  return e >= 58 && e <= 92;
}
function Gm(e) {
  return e >= 39 && e <= 59;
}
function zm(e) {
  return e === 34;
}
function Qm(e) {
  return sa[e];
}
function Zm(e) {
  return e >= 119 && e <= 121;
}
function ey(e) {
  return e >= 122 && e <= 128;
}
function Ht(e) {
  return ea[e];
}
function Zi(e) {
  return ta[e];
}
function ty(e) {
  return e === 57;
}
function ls(e) {
  return e >= 24 && e <= 25;
}
function Ot(e) {
  return _t[e];
}
_t[8].updateContext = (e) => {
  e.pop();
}, _t[5].updateContext = _t[7].updateContext = _t[23].updateContext = (e) => {
  e.push(Be.brace);
}, _t[22].updateContext = (e) => {
  e[e.length - 1] === Be.template ? e.pop() : e.push(Be.template);
}, _t[140].updateContext = (e) => {
  e.push(Be.j_expr, Be.j_oTag);
};
let aa = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", Ru = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿";
const ry = new RegExp("[" + aa + "]"), iy = new RegExp("[" + aa + Ru + "]");
aa = Ru = null;
const $u = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191], sy = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
function Dn(e, t) {
  let r = 65536;
  for (let i = 0, s = t.length; i < s; i += 2) {
    if (r += t[i], r > e)
      return !1;
    if (r += t[i + 1], r >= e)
      return !0;
  }
  return !1;
}
function Dt(e) {
  return e < 65 ? e === 36 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && ry.test(String.fromCharCode(e)) : Dn(e, $u);
}
function Nr(e) {
  return e < 48 ? e === 36 : e < 58 ? !0 : e < 65 ? !1 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && iy.test(String.fromCharCode(e)) : Dn(e, $u) || Dn(e, sy);
}
const oa = {
  keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
  strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
  strictBind: ["eval", "arguments"]
}, ny = new Set(oa.keyword), ay = new Set(oa.strict), oy = new Set(oa.strictBind);
function Uu(e, t) {
  return t && e === "await" || e === "enum";
}
function Vu(e, t) {
  return Uu(e, t) || ay.has(e);
}
function Ku(e) {
  return oy.has(e);
}
function qu(e, t) {
  return Vu(e, t) || Ku(e);
}
function ly(e) {
  return ny.has(e);
}
function uy(e, t, r) {
  return e === 64 && t === 64 && Dt(r);
}
const cy = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
function fy(e) {
  return cy.has(e);
}
const Cr = 0, Ir = 1, Mt = 2, la = 4, Wu = 8, us = 16, Yu = 32, ar = 64, cs = 128, _r = 256, Ii = Ir | Mt | cs | _r, vt = 1, fr = 2, Xu = 4, ur = 8, es = 16, Ju = 64, fs = 128, kn = 256, Ln = 512, ua = 1024, Mn = 2048, ri = 4096, Ss = 8192, Hu = vt | fr | ur | fs | Ss, Dr = vt | 0 | ur | Ss, py = vt | 0 | ur | 0, ps = vt | 0 | Xu | 0, Gu = vt | 0 | es | 0, hy = 0 | fr | 0 | fs, dy = 0 | fr | 0 | 0, zu = vt | fr | ur | kn | Ss, Po = 0 | ua, Yt = 0 | Ju, my = vt | 0 | 0 | Ju, yy = zu | Ln, Ty = 0 | ua, xo = 0 | fr | 0 | ri, Sy = Mn, hs = 4, ca = 2, fa = 1, on = ca | fa, by = ca | hs, gy = fa | hs, Ey = ca, Py = fa, ln = 0;
let pa = class {
  constructor(t) {
    this.var = /* @__PURE__ */ new Set(), this.lexical = /* @__PURE__ */ new Set(), this.functions = /* @__PURE__ */ new Set(), this.flags = t;
  }
};
class ha {
  constructor(t, r) {
    this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = t, this.inModule = r;
  }
  get inTopLevel() {
    return (this.currentScope().flags & Ir) > 0;
  }
  get inFunction() {
    return (this.currentVarScopeFlags() & Mt) > 0;
  }
  get allowSuper() {
    return (this.currentThisScopeFlags() & us) > 0;
  }
  get allowDirectSuper() {
    return (this.currentThisScopeFlags() & Yu) > 0;
  }
  get inClass() {
    return (this.currentThisScopeFlags() & ar) > 0;
  }
  get inClassAndNotInNonArrowFunction() {
    const t = this.currentThisScopeFlags();
    return (t & ar) > 0 && (t & Mt) === 0;
  }
  get inStaticBlock() {
    for (let t = this.scopeStack.length - 1; ; t--) {
      const {
        flags: r
      } = this.scopeStack[t];
      if (r & cs)
        return !0;
      if (r & (Ii | ar))
        return !1;
    }
  }
  get inNonArrowFunction() {
    return (this.currentThisScopeFlags() & Mt) > 0;
  }
  get treatFunctionsAsVar() {
    return this.treatFunctionsAsVarInScope(this.currentScope());
  }
  createScope(t) {
    return new pa(t);
  }
  enter(t) {
    this.scopeStack.push(this.createScope(t));
  }
  exit() {
    return this.scopeStack.pop().flags;
  }
  treatFunctionsAsVarInScope(t) {
    return !!(t.flags & (Mt | cs) || !this.parser.inModule && t.flags & Ir);
  }
  declareName(t, r, i) {
    let s = this.currentScope();
    if (r & ur || r & es)
      this.checkRedeclarationInScope(s, t, r, i), r & es ? s.functions.add(t) : s.lexical.add(t), r & ur && this.maybeExportDefined(s, t);
    else if (r & Xu)
      for (let n = this.scopeStack.length - 1; n >= 0 && (s = this.scopeStack[n], this.checkRedeclarationInScope(s, t, r, i), s.var.add(t), this.maybeExportDefined(s, t), !(s.flags & Ii)); --n)
        ;
    this.parser.inModule && s.flags & Ir && this.undefinedExports.delete(t);
  }
  maybeExportDefined(t, r) {
    this.parser.inModule && t.flags & Ir && this.undefinedExports.delete(r);
  }
  checkRedeclarationInScope(t, r, i, s) {
    this.isRedeclaredInScope(t, r, i) && this.parser.raise(N.VarRedeclaration, {
      at: s,
      identifierName: r
    });
  }
  isRedeclaredInScope(t, r, i) {
    return i & vt ? i & ur ? t.lexical.has(r) || t.functions.has(r) || t.var.has(r) : i & es ? t.lexical.has(r) || !this.treatFunctionsAsVarInScope(t) && t.var.has(r) : t.lexical.has(r) && !(t.flags & Wu && t.lexical.values().next().value === r) || !this.treatFunctionsAsVarInScope(t) && t.functions.has(r) : !1;
  }
  checkLocalExport(t) {
    const {
      name: r
    } = t, i = this.scopeStack[0];
    !i.lexical.has(r) && !i.var.has(r) && !i.functions.has(r) && this.undefinedExports.set(r, t.loc.start);
  }
  currentScope() {
    return this.scopeStack[this.scopeStack.length - 1];
  }
  currentVarScopeFlags() {
    for (let t = this.scopeStack.length - 1; ; t--) {
      const {
        flags: r
      } = this.scopeStack[t];
      if (r & Ii)
        return r;
    }
  }
  currentThisScopeFlags() {
    for (let t = this.scopeStack.length - 1; ; t--) {
      const {
        flags: r
      } = this.scopeStack[t];
      if (r & (Ii | ar) && !(r & la))
        return r;
    }
  }
}
class xy extends pa {
  constructor(...t) {
    super(...t), this.declareFunctions = /* @__PURE__ */ new Set();
  }
}
class vy extends ha {
  createScope(t) {
    return new xy(t);
  }
  declareName(t, r, i) {
    const s = this.currentScope();
    if (r & Mn) {
      this.checkRedeclarationInScope(s, t, r, i), this.maybeExportDefined(s, t), s.declareFunctions.add(t);
      return;
    }
    super.declareName(t, r, i);
  }
  isRedeclaredInScope(t, r, i) {
    return super.isRedeclaredInScope(t, r, i) ? !0 : i & Mn ? !t.declareFunctions.has(r) && (t.lexical.has(r) || t.functions.has(r)) : !1;
  }
  checkLocalExport(t) {
    this.scopeStack[0].declareFunctions.has(t.name) || super.checkLocalExport(t);
  }
}
class Ay {
  constructor() {
    this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
  }
  hasPlugin(t) {
    if (typeof t == "string")
      return this.plugins.has(t);
    {
      const [r, i] = t;
      if (!this.hasPlugin(r))
        return !1;
      const s = this.plugins.get(r);
      for (const n of Object.keys(i))
        if ((s == null ? void 0 : s[n]) !== i[n])
          return !1;
      return !0;
    }
  }
  getPluginOption(t, r) {
    var i;
    return (i = this.plugins.get(t)) == null ? void 0 : i[r];
  }
}
function Qu(e, t) {
  e.trailingComments === void 0 ? e.trailingComments = t : e.trailingComments.unshift(...t);
}
function Cy(e, t) {
  e.leadingComments === void 0 ? e.leadingComments = t : e.leadingComments.unshift(...t);
}
function ai(e, t) {
  e.innerComments === void 0 ? e.innerComments = t : e.innerComments.unshift(...t);
}
function Rr(e, t, r) {
  let i = null, s = t.length;
  for (; i === null && s > 0; )
    i = t[--s];
  i === null || i.start > r.start ? ai(e, r.comments) : Qu(i, r.comments);
}
class Iy extends Ay {
  addComment(t) {
    this.filename && (t.loc.filename = this.filename), this.state.comments.push(t);
  }
  processComment(t) {
    const {
      commentStack: r
    } = this.state, i = r.length;
    if (i === 0)
      return;
    let s = i - 1;
    const n = r[s];
    n.start === t.end && (n.leadingNode = t, s--);
    const {
      start: a
    } = t;
    for (; s >= 0; s--) {
      const o = r[s], l = o.end;
      if (l > a)
        o.containingNode = t, this.finalizeComment(o), r.splice(s, 1);
      else {
        l === a && (o.trailingNode = t);
        break;
      }
    }
  }
  finalizeComment(t) {
    const {
      comments: r
    } = t;
    if (t.leadingNode !== null || t.trailingNode !== null)
      t.leadingNode !== null && Qu(t.leadingNode, r), t.trailingNode !== null && Cy(t.trailingNode, r);
    else {
      const {
        containingNode: i,
        start: s
      } = t;
      if (this.input.charCodeAt(s - 1) === 44)
        switch (i.type) {
          case "ObjectExpression":
          case "ObjectPattern":
          case "RecordExpression":
            Rr(i, i.properties, t);
            break;
          case "CallExpression":
          case "OptionalCallExpression":
            Rr(i, i.arguments, t);
            break;
          case "FunctionDeclaration":
          case "FunctionExpression":
          case "ArrowFunctionExpression":
          case "ObjectMethod":
          case "ClassMethod":
          case "ClassPrivateMethod":
            Rr(i, i.params, t);
            break;
          case "ArrayExpression":
          case "ArrayPattern":
          case "TupleExpression":
            Rr(i, i.elements, t);
            break;
          case "ExportNamedDeclaration":
          case "ImportDeclaration":
            Rr(i, i.specifiers, t);
            break;
          default:
            ai(i, r);
        }
      else
        ai(i, r);
    }
  }
  finalizeRemainingComments() {
    const {
      commentStack: t
    } = this.state;
    for (let r = t.length - 1; r >= 0; r--)
      this.finalizeComment(t[r]);
    this.state.commentStack = [];
  }
  resetPreviousNodeTrailingComments(t) {
    const {
      commentStack: r
    } = this.state, {
      length: i
    } = r;
    if (i === 0)
      return;
    const s = r[i - 1];
    s.leadingNode === t && (s.leadingNode = null);
  }
  resetPreviousIdentifierLeadingComments(t) {
    const {
      commentStack: r
    } = this.state, {
      length: i
    } = r;
    i !== 0 && (r[i - 1].trailingNode === t ? r[i - 1].trailingNode = null : i >= 2 && r[i - 2].trailingNode === t && (r[i - 2].trailingNode = null));
  }
  takeSurroundingComments(t, r, i) {
    const {
      commentStack: s
    } = this.state, n = s.length;
    if (n === 0)
      return;
    let a = n - 1;
    for (; a >= 0; a--) {
      const o = s[a], l = o.end;
      if (o.start === i)
        o.leadingNode = t;
      else if (l === r)
        o.trailingNode = t;
      else if (l < r)
        break;
    }
  }
}
const Zu = /\r\n?|[\n\u2028\u2029]/, wi = new RegExp(Zu.source, "g");
function ii(e) {
  switch (e) {
    case 10:
    case 13:
    case 8232:
    case 8233:
      return !0;
    default:
      return !1;
  }
}
const un = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, ts = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g, vo = new RegExp("(?=(" + ts.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
function wy(e) {
  switch (e) {
    case 9:
    case 11:
    case 12:
    case 32:
    case 160:
    case 5760:
    case 8192:
    case 8193:
    case 8194:
    case 8195:
    case 8196:
    case 8197:
    case 8198:
    case 8199:
    case 8200:
    case 8201:
    case 8202:
    case 8239:
    case 8287:
    case 12288:
    case 65279:
      return !0;
    default:
      return !1;
  }
}
class da {
  constructor() {
    this.strict = void 0, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.maybeInArrowParameters = !1, this.inType = !1, this.noAnonFunctionType = !1, this.hasFlowComment = !1, this.isAmbientContext = !1, this.inAbstractClass = !1, this.inDisallowConditionalTypesContext = !1, this.topicContext = {
      maxNumOfResolvableTopics: 0,
      maxTopicIndex: null
    }, this.soloAwait = !1, this.inFSharpPipelineDirectBody = !1, this.labels = [], this.comments = [], this.commentStack = [], this.pos = 0, this.type = 137, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.lastTokStart = 0, this.context = [Be.brace], this.canStartJSXElement = !0, this.containsEsc = !1, this.firstInvalidTemplateEscapePos = null, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
  }
  init({
    strictMode: t,
    sourceType: r,
    startLine: i,
    startColumn: s
  }) {
    this.strict = t === !1 ? !1 : t === !0 ? !0 : r === "module", this.curLine = i, this.lineStart = -s, this.startLoc = this.endLoc = new Jt(i, s, 0);
  }
  curPosition() {
    return new Jt(this.curLine, this.pos - this.lineStart, this.pos);
  }
  clone(t) {
    const r = new da(), i = Object.keys(this);
    for (let s = 0, n = i.length; s < n; s++) {
      const a = i[s];
      let o = this[a];
      !t && Array.isArray(o) && (o = o.slice()), r[a] = o;
    }
    return r;
  }
}
var Oy = function(t) {
  return t >= 48 && t <= 57;
};
const Ao = {
  decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
  hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
}, Oi = {
  bin: (e) => e === 48 || e === 49,
  oct: (e) => e >= 48 && e <= 55,
  dec: (e) => e >= 48 && e <= 57,
  hex: (e) => e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102
};
function Co(e, t, r, i, s, n) {
  const a = r, o = i, l = s;
  let u = "", c = null, p = r;
  const {
    length: h
  } = t;
  for (; ; ) {
    if (r >= h) {
      n.unterminated(a, o, l), u += t.slice(p, r);
      break;
    }
    const y = t.charCodeAt(r);
    if (Ny(e, y, t, r)) {
      u += t.slice(p, r);
      break;
    }
    if (y === 92) {
      u += t.slice(p, r);
      const P = _y(t, r, i, s, e === "template", n);
      P.ch === null && !c ? c = {
        pos: r,
        lineStart: i,
        curLine: s
      } : u += P.ch, {
        pos: r,
        lineStart: i,
        curLine: s
      } = P, p = r;
    } else
      y === 8232 || y === 8233 ? (++r, ++s, i = r) : y === 10 || y === 13 ? e === "template" ? (u += t.slice(p, r) + `
`, ++r, y === 13 && t.charCodeAt(r) === 10 && ++r, ++s, p = i = r) : n.unterminated(a, o, l) : ++r;
  }
  return {
    pos: r,
    str: u,
    firstInvalidLoc: c,
    lineStart: i,
    curLine: s,
    containsInvalid: !!c
  };
}
function Ny(e, t, r, i) {
  return e === "template" ? t === 96 || t === 36 && r.charCodeAt(i + 1) === 123 : t === (e === "double" ? 34 : 39);
}
function _y(e, t, r, i, s, n) {
  const a = !s;
  t++;
  const o = (u) => ({
    pos: t,
    ch: u,
    lineStart: r,
    curLine: i
  }), l = e.charCodeAt(t++);
  switch (l) {
    case 110:
      return o(`
`);
    case 114:
      return o("\r");
    case 120: {
      let u;
      return {
        code: u,
        pos: t
      } = Bn(e, t, r, i, 2, !1, a, n), o(u === null ? null : String.fromCharCode(u));
    }
    case 117: {
      let u;
      return {
        code: u,
        pos: t
      } = tc(e, t, r, i, a, n), o(u === null ? null : String.fromCodePoint(u));
    }
    case 116:
      return o("	");
    case 98:
      return o("\b");
    case 118:
      return o("\v");
    case 102:
      return o("\f");
    case 13:
      e.charCodeAt(t) === 10 && ++t;
    case 10:
      r = t, ++i;
    case 8232:
    case 8233:
      return o("");
    case 56:
    case 57:
      if (s)
        return o(null);
      n.strictNumericEscape(t - 1, r, i);
    default:
      if (l >= 48 && l <= 55) {
        const u = t - 1;
        let p = e.slice(u, t + 2).match(/^[0-7]+/)[0], h = parseInt(p, 8);
        h > 255 && (p = p.slice(0, -1), h = parseInt(p, 8)), t += p.length - 1;
        const y = e.charCodeAt(t);
        if (p !== "0" || y === 56 || y === 57) {
          if (s)
            return o(null);
          n.strictNumericEscape(u, r, i);
        }
        return o(String.fromCharCode(h));
      }
      return o(String.fromCharCode(l));
  }
}
function Bn(e, t, r, i, s, n, a, o) {
  const l = t;
  let u;
  return {
    n: u,
    pos: t
  } = ec(e, t, r, i, 16, s, n, !1, o, !a), u === null && (a ? o.invalidEscapeSequence(l, r, i) : t = l - 1), {
    code: u,
    pos: t
  };
}
function ec(e, t, r, i, s, n, a, o, l, u) {
  const c = t, p = s === 16 ? Ao.hex : Ao.decBinOct, h = s === 16 ? Oi.hex : s === 10 ? Oi.dec : s === 8 ? Oi.oct : Oi.bin;
  let y = !1, P = 0;
  for (let v = 0, w = n ?? 1 / 0; v < w; ++v) {
    const x = e.charCodeAt(t);
    let O;
    if (x === 95 && o !== "bail") {
      const _ = e.charCodeAt(t - 1), K = e.charCodeAt(t + 1);
      if (o) {
        if (Number.isNaN(K) || !h(K) || p.has(_) || p.has(K)) {
          if (u)
            return {
              n: null,
              pos: t
            };
          l.unexpectedNumericSeparator(t, r, i);
        }
      } else {
        if (u)
          return {
            n: null,
            pos: t
          };
        l.numericSeparatorInEscapeSequence(t, r, i);
      }
      ++t;
      continue;
    }
    if (x >= 97 ? O = x - 97 + 10 : x >= 65 ? O = x - 65 + 10 : Oy(x) ? O = x - 48 : O = 1 / 0, O >= s) {
      if (O <= 9 && u)
        return {
          n: null,
          pos: t
        };
      if (O <= 9 && l.invalidDigit(t, r, i, s))
        O = 0;
      else if (a)
        O = 0, y = !0;
      else
        break;
    }
    ++t, P = P * s + O;
  }
  return t === c || n != null && t - c !== n || y ? {
    n: null,
    pos: t
  } : {
    n: P,
    pos: t
  };
}
function tc(e, t, r, i, s, n) {
  const a = e.charCodeAt(t);
  let o;
  if (a === 123) {
    if (++t, {
      code: o,
      pos: t
    } = Bn(e, t, r, i, e.indexOf("}", t) - t, !0, s, n), ++t, o !== null && o > 1114111)
      if (s)
        n.invalidCodePoint(t, r, i);
      else
        return {
          code: null,
          pos: t
        };
  } else
    ({
      code: o,
      pos: t
    } = Bn(e, t, r, i, 4, !1, s, n));
  return {
    code: o,
    pos: t
  };
}
const Dy = ["at"], ky = ["at"];
function $r(e, t, r) {
  return new Jt(r, e - t, e);
}
const Ly = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]);
class qt {
  constructor(t) {
    this.type = t.type, this.value = t.value, this.start = t.start, this.end = t.end, this.loc = new os(t.startLoc, t.endLoc);
  }
}
class My extends Iy {
  constructor(t, r) {
    super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = {
      invalidDigit: (i, s, n, a) => this.options.errorRecovery ? (this.raise(N.InvalidDigit, {
        at: $r(i, s, n),
        radix: a
      }), !0) : !1,
      numericSeparatorInEscapeSequence: this.errorBuilder(N.NumericSeparatorInEscapeSequence),
      unexpectedNumericSeparator: this.errorBuilder(N.UnexpectedNumericSeparator)
    }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
      invalidEscapeSequence: this.errorBuilder(N.InvalidEscapeSequence),
      invalidCodePoint: this.errorBuilder(N.InvalidCodePoint)
    }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
      strictNumericEscape: (i, s, n) => {
        this.recordStrictModeErrors(N.StrictNumericEscape, {
          at: $r(i, s, n)
        });
      },
      unterminated: (i, s, n) => {
        throw this.raise(N.UnterminatedString, {
          at: $r(i - 1, s, n)
        });
      }
    }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
      strictNumericEscape: this.errorBuilder(N.StrictNumericEscape),
      unterminated: (i, s, n) => {
        throw this.raise(N.UnterminatedTemplate, {
          at: $r(i, s, n)
        });
      }
    }), this.state = new da(), this.state.init(t), this.input = r, this.length = r.length, this.isLookahead = !1;
  }
  pushToken(t) {
    this.tokens.length = this.state.tokensLength, this.tokens.push(t), ++this.state.tokensLength;
  }
  next() {
    this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new qt(this.state)), this.state.lastTokStart = this.state.start, this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
  }
  eat(t) {
    return this.match(t) ? (this.next(), !0) : !1;
  }
  match(t) {
    return this.state.type === t;
  }
  createLookaheadState(t) {
    return {
      pos: t.pos,
      value: null,
      type: t.type,
      start: t.start,
      end: t.end,
      context: [this.curContext()],
      inType: t.inType,
      startLoc: t.startLoc,
      lastTokEndLoc: t.lastTokEndLoc,
      curLine: t.curLine,
      lineStart: t.lineStart,
      curPosition: t.curPosition
    };
  }
  lookahead() {
    const t = this.state;
    this.state = this.createLookaheadState(t), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
    const r = this.state;
    return this.state = t, r;
  }
  nextTokenStart() {
    return this.nextTokenStartSince(this.state.pos);
  }
  nextTokenStartSince(t) {
    return un.lastIndex = t, un.test(this.input) ? un.lastIndex : t;
  }
  lookaheadCharCode() {
    return this.input.charCodeAt(this.nextTokenStart());
  }
  nextTokenInLineStart() {
    return this.nextTokenInLineStartSince(this.state.pos);
  }
  nextTokenInLineStartSince(t) {
    return ts.lastIndex = t, ts.test(this.input) ? ts.lastIndex : t;
  }
  lookaheadInLineCharCode() {
    return this.input.charCodeAt(this.nextTokenInLineStart());
  }
  codePointAtPos(t) {
    let r = this.input.charCodeAt(t);
    if ((r & 64512) === 55296 && ++t < this.input.length) {
      const i = this.input.charCodeAt(t);
      (i & 64512) === 56320 && (r = 65536 + ((r & 1023) << 10) + (i & 1023));
    }
    return r;
  }
  setStrict(t) {
    this.state.strict = t, t && (this.state.strictErrors.forEach(([r, i]) => this.raise(r, {
      at: i
    })), this.state.strictErrors.clear());
  }
  curContext() {
    return this.state.context[this.state.context.length - 1];
  }
  nextToken() {
    if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length) {
      this.finishToken(137);
      return;
    }
    this.getTokenFromCode(this.codePointAtPos(this.state.pos));
  }
  skipBlockComment(t) {
    let r;
    this.isLookahead || (r = this.state.curPosition());
    const i = this.state.pos, s = this.input.indexOf(t, i + 2);
    if (s === -1)
      throw this.raise(N.UnterminatedComment, {
        at: this.state.curPosition()
      });
    for (this.state.pos = s + t.length, wi.lastIndex = i + 2; wi.test(this.input) && wi.lastIndex <= s; )
      ++this.state.curLine, this.state.lineStart = wi.lastIndex;
    if (this.isLookahead)
      return;
    const n = {
      type: "CommentBlock",
      value: this.input.slice(i + 2, s),
      start: i,
      end: s + t.length,
      loc: new os(r, this.state.curPosition())
    };
    return this.options.tokens && this.pushToken(n), n;
  }
  skipLineComment(t) {
    const r = this.state.pos;
    let i;
    this.isLookahead || (i = this.state.curPosition());
    let s = this.input.charCodeAt(this.state.pos += t);
    if (this.state.pos < this.length)
      for (; !ii(s) && ++this.state.pos < this.length; )
        s = this.input.charCodeAt(this.state.pos);
    if (this.isLookahead)
      return;
    const n = this.state.pos, o = {
      type: "CommentLine",
      value: this.input.slice(r + t, n),
      start: r,
      end: n,
      loc: new os(i, this.state.curPosition())
    };
    return this.options.tokens && this.pushToken(o), o;
  }
  skipSpace() {
    const t = this.state.pos, r = [];
    e:
      for (; this.state.pos < this.length; ) {
        const i = this.input.charCodeAt(this.state.pos);
        switch (i) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;
          case 13:
            this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
          case 10:
          case 8232:
          case 8233:
            ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
            break;
          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42: {
                const s = this.skipBlockComment("*/");
                s !== void 0 && (this.addComment(s), this.options.attachComment && r.push(s));
                break;
              }
              case 47: {
                const s = this.skipLineComment(2);
                s !== void 0 && (this.addComment(s), this.options.attachComment && r.push(s));
                break;
              }
              default:
                break e;
            }
            break;
          default:
            if (wy(i))
              ++this.state.pos;
            else if (i === 45 && !this.inModule && this.options.annexB) {
              const s = this.state.pos;
              if (this.input.charCodeAt(s + 1) === 45 && this.input.charCodeAt(s + 2) === 62 && (t === 0 || this.state.lineStart > t)) {
                const n = this.skipLineComment(3);
                n !== void 0 && (this.addComment(n), this.options.attachComment && r.push(n));
              } else
                break e;
            } else if (i === 60 && !this.inModule && this.options.annexB) {
              const s = this.state.pos;
              if (this.input.charCodeAt(s + 1) === 33 && this.input.charCodeAt(s + 2) === 45 && this.input.charCodeAt(s + 3) === 45) {
                const n = this.skipLineComment(4);
                n !== void 0 && (this.addComment(n), this.options.attachComment && r.push(n));
              } else
                break e;
            } else
              break e;
        }
      }
    if (r.length > 0) {
      const i = this.state.pos, s = {
        start: t,
        end: i,
        comments: r,
        leadingNode: null,
        trailingNode: null,
        containingNode: null
      };
      this.state.commentStack.push(s);
    }
  }
  finishToken(t, r) {
    this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
    const i = this.state.type;
    this.state.type = t, this.state.value = r, this.isLookahead || this.updateContext(i);
  }
  replaceToken(t) {
    this.state.type = t, this.updateContext();
  }
  readToken_numberSign() {
    if (this.state.pos === 0 && this.readToken_interpreter())
      return;
    const t = this.state.pos + 1, r = this.codePointAtPos(t);
    if (r >= 48 && r <= 57)
      throw this.raise(N.UnexpectedDigitAfterHash, {
        at: this.state.curPosition()
      });
    if (r === 123 || r === 91 && this.hasPlugin("recordAndTuple")) {
      if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
        throw this.raise(r === 123 ? N.RecordExpressionHashIncorrectStartSyntaxType : N.TupleExpressionHashIncorrectStartSyntaxType, {
          at: this.state.curPosition()
        });
      this.state.pos += 2, r === 123 ? this.finishToken(7) : this.finishToken(1);
    } else
      Dt(r) ? (++this.state.pos, this.finishToken(136, this.readWord1(r))) : r === 92 ? (++this.state.pos, this.finishToken(136, this.readWord1())) : this.finishOp(27, 1);
  }
  readToken_dot() {
    const t = this.input.charCodeAt(this.state.pos + 1);
    if (t >= 48 && t <= 57) {
      this.readNumber(!0);
      return;
    }
    t === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
  }
  readToken_slash() {
    this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
  }
  readToken_interpreter() {
    if (this.state.pos !== 0 || this.length < 2)
      return !1;
    let t = this.input.charCodeAt(this.state.pos + 1);
    if (t !== 33)
      return !1;
    const r = this.state.pos;
    for (this.state.pos += 1; !ii(t) && ++this.state.pos < this.length; )
      t = this.input.charCodeAt(this.state.pos);
    const i = this.input.slice(r + 2, this.state.pos);
    return this.finishToken(28, i), !0;
  }
  readToken_mult_modulo(t) {
    let r = t === 42 ? 55 : 54, i = 1, s = this.input.charCodeAt(this.state.pos + 1);
    t === 42 && s === 42 && (i++, s = this.input.charCodeAt(this.state.pos + 2), r = 57), s === 61 && !this.state.inType && (i++, r = t === 37 ? 33 : 30), this.finishOp(r, i);
  }
  readToken_pipe_amp(t) {
    const r = this.input.charCodeAt(this.state.pos + 1);
    if (r === t) {
      this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(t === 124 ? 41 : 42, 2);
      return;
    }
    if (t === 124) {
      if (r === 62) {
        this.finishOp(39, 2);
        return;
      }
      if (this.hasPlugin("recordAndTuple") && r === 125) {
        if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
          throw this.raise(N.RecordExpressionBarIncorrectEndSyntaxType, {
            at: this.state.curPosition()
          });
        this.state.pos += 2, this.finishToken(9);
        return;
      }
      if (this.hasPlugin("recordAndTuple") && r === 93) {
        if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
          throw this.raise(N.TupleExpressionBarIncorrectEndSyntaxType, {
            at: this.state.curPosition()
          });
        this.state.pos += 2, this.finishToken(4);
        return;
      }
    }
    if (r === 61) {
      this.finishOp(30, 2);
      return;
    }
    this.finishOp(t === 124 ? 43 : 45, 1);
  }
  readToken_caret() {
    const t = this.input.charCodeAt(this.state.pos + 1);
    t === 61 && !this.state.inType ? this.finishOp(32, 2) : t === 94 && this.hasPlugin(["pipelineOperator", {
      proposal: "hack",
      topicToken: "^^"
    }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
  }
  readToken_atSign() {
    this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", {
      proposal: "hack",
      topicToken: "@@"
    }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
  }
  readToken_plus_min(t) {
    const r = this.input.charCodeAt(this.state.pos + 1);
    if (r === t) {
      this.finishOp(34, 2);
      return;
    }
    r === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
  }
  readToken_lt() {
    const {
      pos: t
    } = this.state, r = this.input.charCodeAt(t + 1);
    if (r === 60) {
      if (this.input.charCodeAt(t + 2) === 61) {
        this.finishOp(30, 3);
        return;
      }
      this.finishOp(51, 2);
      return;
    }
    if (r === 61) {
      this.finishOp(49, 2);
      return;
    }
    this.finishOp(47, 1);
  }
  readToken_gt() {
    const {
      pos: t
    } = this.state, r = this.input.charCodeAt(t + 1);
    if (r === 62) {
      const i = this.input.charCodeAt(t + 2) === 62 ? 3 : 2;
      if (this.input.charCodeAt(t + i) === 61) {
        this.finishOp(30, i + 1);
        return;
      }
      this.finishOp(52, i);
      return;
    }
    if (r === 61) {
      this.finishOp(49, 2);
      return;
    }
    this.finishOp(48, 1);
  }
  readToken_eq_excl(t) {
    const r = this.input.charCodeAt(this.state.pos + 1);
    if (r === 61) {
      this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
      return;
    }
    if (t === 61 && r === 62) {
      this.state.pos += 2, this.finishToken(19);
      return;
    }
    this.finishOp(t === 61 ? 29 : 35, 1);
  }
  readToken_question() {
    const t = this.input.charCodeAt(this.state.pos + 1), r = this.input.charCodeAt(this.state.pos + 2);
    t === 63 ? r === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : t === 46 && !(r >= 48 && r <= 57) ? (this.state.pos += 2, this.finishToken(18)) : (++this.state.pos, this.finishToken(17));
  }
  getTokenFromCode(t) {
    switch (t) {
      case 46:
        this.readToken_dot();
        return;
      case 40:
        ++this.state.pos, this.finishToken(10);
        return;
      case 41:
        ++this.state.pos, this.finishToken(11);
        return;
      case 59:
        ++this.state.pos, this.finishToken(13);
        return;
      case 44:
        ++this.state.pos, this.finishToken(12);
        return;
      case 91:
        if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(N.TupleExpressionBarIncorrectStartSyntaxType, {
              at: this.state.curPosition()
            });
          this.state.pos += 2, this.finishToken(2);
        } else
          ++this.state.pos, this.finishToken(0);
        return;
      case 93:
        ++this.state.pos, this.finishToken(3);
        return;
      case 123:
        if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(N.RecordExpressionBarIncorrectStartSyntaxType, {
              at: this.state.curPosition()
            });
          this.state.pos += 2, this.finishToken(6);
        } else
          ++this.state.pos, this.finishToken(5);
        return;
      case 125:
        ++this.state.pos, this.finishToken(8);
        return;
      case 58:
        this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14));
        return;
      case 63:
        this.readToken_question();
        return;
      case 96:
        this.readTemplateToken();
        return;
      case 48: {
        const r = this.input.charCodeAt(this.state.pos + 1);
        if (r === 120 || r === 88) {
          this.readRadixNumber(16);
          return;
        }
        if (r === 111 || r === 79) {
          this.readRadixNumber(8);
          return;
        }
        if (r === 98 || r === 66) {
          this.readRadixNumber(2);
          return;
        }
      }
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        this.readNumber(!1);
        return;
      case 34:
      case 39:
        this.readString(t);
        return;
      case 47:
        this.readToken_slash();
        return;
      case 37:
      case 42:
        this.readToken_mult_modulo(t);
        return;
      case 124:
      case 38:
        this.readToken_pipe_amp(t);
        return;
      case 94:
        this.readToken_caret();
        return;
      case 43:
      case 45:
        this.readToken_plus_min(t);
        return;
      case 60:
        this.readToken_lt();
        return;
      case 62:
        this.readToken_gt();
        return;
      case 61:
      case 33:
        this.readToken_eq_excl(t);
        return;
      case 126:
        this.finishOp(36, 1);
        return;
      case 64:
        this.readToken_atSign();
        return;
      case 35:
        this.readToken_numberSign();
        return;
      case 92:
        this.readWord();
        return;
      default:
        if (Dt(t)) {
          this.readWord(t);
          return;
        }
    }
    throw this.raise(N.InvalidOrUnexpectedToken, {
      at: this.state.curPosition(),
      unexpected: String.fromCodePoint(t)
    });
  }
  finishOp(t, r) {
    const i = this.input.slice(this.state.pos, this.state.pos + r);
    this.state.pos += r, this.finishToken(t, i);
  }
  readRegexp() {
    const t = this.state.startLoc, r = this.state.start + 1;
    let i, s, {
      pos: n
    } = this.state;
    for (; ; ++n) {
      if (n >= this.length)
        throw this.raise(N.UnterminatedRegExp, {
          at: nt(t, 1)
        });
      const u = this.input.charCodeAt(n);
      if (ii(u))
        throw this.raise(N.UnterminatedRegExp, {
          at: nt(t, 1)
        });
      if (i)
        i = !1;
      else {
        if (u === 91)
          s = !0;
        else if (u === 93 && s)
          s = !1;
        else if (u === 47 && !s)
          break;
        i = u === 92;
      }
    }
    const a = this.input.slice(r, n);
    ++n;
    let o = "";
    const l = () => nt(t, n + 2 - r);
    for (; n < this.length; ) {
      const u = this.codePointAtPos(n), c = String.fromCharCode(u);
      if (Ly.has(u))
        u === 118 ? o.includes("u") && this.raise(N.IncompatibleRegExpUVFlags, {
          at: l()
        }) : u === 117 && o.includes("v") && this.raise(N.IncompatibleRegExpUVFlags, {
          at: l()
        }), o.includes(c) && this.raise(N.DuplicateRegExpFlags, {
          at: l()
        });
      else if (Nr(u) || u === 92)
        this.raise(N.MalformedRegExpFlags, {
          at: l()
        });
      else
        break;
      ++n, o += c;
    }
    this.state.pos = n, this.finishToken(135, {
      pattern: a,
      flags: o
    });
  }
  readInt(t, r, i = !1, s = !0) {
    const {
      n,
      pos: a
    } = ec(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t, r, i, s, this.errorHandlers_readInt, !1);
    return this.state.pos = a, n;
  }
  readRadixNumber(t) {
    const r = this.state.curPosition();
    let i = !1;
    this.state.pos += 2;
    const s = this.readInt(t);
    s == null && this.raise(N.InvalidDigit, {
      at: nt(r, 2),
      radix: t
    });
    const n = this.input.charCodeAt(this.state.pos);
    if (n === 110)
      ++this.state.pos, i = !0;
    else if (n === 109)
      throw this.raise(N.InvalidDecimal, {
        at: r
      });
    if (Dt(this.codePointAtPos(this.state.pos)))
      throw this.raise(N.NumberIdentifier, {
        at: this.state.curPosition()
      });
    if (i) {
      const a = this.input.slice(r.index, this.state.pos).replace(/[_n]/g, "");
      this.finishToken(133, a);
      return;
    }
    this.finishToken(132, s);
  }
  readNumber(t) {
    const r = this.state.pos, i = this.state.curPosition();
    let s = !1, n = !1, a = !1, o = !1, l = !1;
    !t && this.readInt(10) === null && this.raise(N.InvalidNumber, {
      at: this.state.curPosition()
    });
    const u = this.state.pos - r >= 2 && this.input.charCodeAt(r) === 48;
    if (u) {
      const y = this.input.slice(r, this.state.pos);
      if (this.recordStrictModeErrors(N.StrictOctalLiteral, {
        at: i
      }), !this.state.strict) {
        const P = y.indexOf("_");
        P > 0 && this.raise(N.ZeroDigitNumericSeparator, {
          at: nt(i, P)
        });
      }
      l = u && !/[89]/.test(y);
    }
    let c = this.input.charCodeAt(this.state.pos);
    if (c === 46 && !l && (++this.state.pos, this.readInt(10), s = !0, c = this.input.charCodeAt(this.state.pos)), (c === 69 || c === 101) && !l && (c = this.input.charCodeAt(++this.state.pos), (c === 43 || c === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(N.InvalidOrMissingExponent, {
      at: i
    }), s = !0, o = !0, c = this.input.charCodeAt(this.state.pos)), c === 110 && ((s || u) && this.raise(N.InvalidBigIntLiteral, {
      at: i
    }), ++this.state.pos, n = !0), c === 109 && (this.expectPlugin("decimal", this.state.curPosition()), (o || u) && this.raise(N.InvalidDecimal, {
      at: i
    }), ++this.state.pos, a = !0), Dt(this.codePointAtPos(this.state.pos)))
      throw this.raise(N.NumberIdentifier, {
        at: this.state.curPosition()
      });
    const p = this.input.slice(r, this.state.pos).replace(/[_mn]/g, "");
    if (n) {
      this.finishToken(133, p);
      return;
    }
    if (a) {
      this.finishToken(134, p);
      return;
    }
    const h = l ? parseInt(p, 8) : parseFloat(p);
    this.finishToken(132, h);
  }
  readCodePoint(t) {
    const {
      code: r,
      pos: i
    } = tc(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t, this.errorHandlers_readCodePoint);
    return this.state.pos = i, r;
  }
  readString(t) {
    const {
      str: r,
      pos: i,
      curLine: s,
      lineStart: n
    } = Co(t === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
    this.state.pos = i + 1, this.state.lineStart = n, this.state.curLine = s, this.finishToken(131, r);
  }
  readTemplateContinuation() {
    this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
  }
  readTemplateToken() {
    const t = this.input[this.state.pos], {
      str: r,
      firstInvalidLoc: i,
      pos: s,
      curLine: n,
      lineStart: a
    } = Co("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
    this.state.pos = s + 1, this.state.lineStart = a, this.state.curLine = n, i && (this.state.firstInvalidTemplateEscapePos = new Jt(i.curLine, i.pos - i.lineStart, i.pos)), this.input.codePointAt(s) === 96 ? this.finishToken(24, i ? null : t + r + "`") : (this.state.pos++, this.finishToken(25, i ? null : t + r + "${"));
  }
  recordStrictModeErrors(t, {
    at: r
  }) {
    const i = r.index;
    this.state.strict && !this.state.strictErrors.has(i) ? this.raise(t, {
      at: r
    }) : this.state.strictErrors.set(i, [t, r]);
  }
  readWord1(t) {
    this.state.containsEsc = !1;
    let r = "";
    const i = this.state.pos;
    let s = this.state.pos;
    for (t !== void 0 && (this.state.pos += t <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
      const n = this.codePointAtPos(this.state.pos);
      if (Nr(n))
        this.state.pos += n <= 65535 ? 1 : 2;
      else if (n === 92) {
        this.state.containsEsc = !0, r += this.input.slice(s, this.state.pos);
        const a = this.state.curPosition(), o = this.state.pos === i ? Dt : Nr;
        if (this.input.charCodeAt(++this.state.pos) !== 117) {
          this.raise(N.MissingUnicodeEscape, {
            at: this.state.curPosition()
          }), s = this.state.pos - 1;
          continue;
        }
        ++this.state.pos;
        const l = this.readCodePoint(!0);
        l !== null && (o(l) || this.raise(N.EscapedCharNotAnIdentifier, {
          at: a
        }), r += String.fromCodePoint(l)), s = this.state.pos;
      } else
        break;
    }
    return r + this.input.slice(s, this.state.pos);
  }
  readWord(t) {
    const r = this.readWord1(t), i = Zn.get(r);
    i !== void 0 ? this.finishToken(i, Ht(i)) : this.finishToken(130, r);
  }
  checkKeywordEscapes() {
    const {
      type: t
    } = this.state;
    na(t) && this.state.containsEsc && this.raise(N.InvalidEscapedReservedWord, {
      at: this.state.startLoc,
      reservedWord: Ht(t)
    });
  }
  raise(t, r) {
    const {
      at: i
    } = r, s = as(r, Dy), n = i instanceof Jt ? i : i.loc.start, a = t({
      loc: n,
      details: s
    });
    if (!this.options.errorRecovery)
      throw a;
    return this.isLookahead || this.state.errors.push(a), a;
  }
  raiseOverwrite(t, r) {
    const {
      at: i
    } = r, s = as(r, ky), n = i instanceof Jt ? i : i.loc.start, a = n.index, o = this.state.errors;
    for (let l = o.length - 1; l >= 0; l--) {
      const u = o[l];
      if (u.loc.index === a)
        return o[l] = t({
          loc: n,
          details: s
        });
      if (u.loc.index < a)
        break;
    }
    return this.raise(t, r);
  }
  updateContext(t) {
  }
  unexpected(t, r) {
    throw this.raise(N.UnexpectedToken, {
      expected: r ? Ht(r) : null,
      at: t ?? this.state.startLoc
    });
  }
  expectPlugin(t, r) {
    if (this.hasPlugin(t))
      return !0;
    throw this.raise(N.MissingPlugin, {
      at: r ?? this.state.startLoc,
      missingPlugin: [t]
    });
  }
  expectOnePlugin(t) {
    if (!t.some((r) => this.hasPlugin(r)))
      throw this.raise(N.MissingOneOfPlugins, {
        at: this.state.startLoc,
        missingPlugin: t
      });
  }
  errorBuilder(t) {
    return (r, i, s) => {
      this.raise(t, {
        at: $r(r, i, s)
      });
    };
  }
}
class By {
  constructor() {
    this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
  }
}
class Fy {
  constructor(t) {
    this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = t;
  }
  current() {
    return this.stack[this.stack.length - 1];
  }
  enter() {
    this.stack.push(new By());
  }
  exit() {
    const t = this.stack.pop(), r = this.current();
    for (const [i, s] of Array.from(t.undefinedPrivateNames))
      r ? r.undefinedPrivateNames.has(i) || r.undefinedPrivateNames.set(i, s) : this.parser.raise(N.InvalidPrivateFieldResolution, {
        at: s,
        identifierName: i
      });
  }
  declarePrivateName(t, r, i) {
    const {
      privateNames: s,
      loneAccessors: n,
      undefinedPrivateNames: a
    } = this.current();
    let o = s.has(t);
    if (r & on) {
      const l = o && n.get(t);
      if (l) {
        const u = l & hs, c = r & hs, p = l & on, h = r & on;
        o = p === h || u !== c, o || n.delete(t);
      } else
        o || n.set(t, r);
    }
    o && this.parser.raise(N.PrivateNameRedeclaration, {
      at: i,
      identifierName: t
    }), s.add(t), a.delete(t);
  }
  usePrivateName(t, r) {
    let i;
    for (i of this.stack)
      if (i.privateNames.has(t))
        return;
    i ? i.undefinedPrivateNames.set(t, r) : this.parser.raise(N.InvalidPrivateFieldResolution, {
      at: r,
      identifierName: t
    });
  }
}
const jy = 0, rc = 1, ma = 2, ic = 3;
class bs {
  constructor(t = jy) {
    this.type = void 0, this.type = t;
  }
  canBeArrowParameterDeclaration() {
    return this.type === ma || this.type === rc;
  }
  isCertainlyParameterDeclaration() {
    return this.type === ic;
  }
}
class sc extends bs {
  constructor(t) {
    super(t), this.declarationErrors = /* @__PURE__ */ new Map();
  }
  recordDeclarationError(t, {
    at: r
  }) {
    const i = r.index;
    this.declarationErrors.set(i, [t, r]);
  }
  clearDeclarationError(t) {
    this.declarationErrors.delete(t);
  }
  iterateErrors(t) {
    this.declarationErrors.forEach(t);
  }
}
class Ry {
  constructor(t) {
    this.parser = void 0, this.stack = [new bs()], this.parser = t;
  }
  enter(t) {
    this.stack.push(t);
  }
  exit() {
    this.stack.pop();
  }
  recordParameterInitializerError(t, {
    at: r
  }) {
    const i = {
      at: r.loc.start
    }, {
      stack: s
    } = this;
    let n = s.length - 1, a = s[n];
    for (; !a.isCertainlyParameterDeclaration(); ) {
      if (a.canBeArrowParameterDeclaration())
        a.recordDeclarationError(t, i);
      else
        return;
      a = s[--n];
    }
    this.parser.raise(t, i);
  }
  recordArrowParameterBindingError(t, {
    at: r
  }) {
    const {
      stack: i
    } = this, s = i[i.length - 1], n = {
      at: r.loc.start
    };
    if (s.isCertainlyParameterDeclaration())
      this.parser.raise(t, n);
    else if (s.canBeArrowParameterDeclaration())
      s.recordDeclarationError(t, n);
    else
      return;
  }
  recordAsyncArrowParametersError({
    at: t
  }) {
    const {
      stack: r
    } = this;
    let i = r.length - 1, s = r[i];
    for (; s.canBeArrowParameterDeclaration(); )
      s.type === ma && s.recordDeclarationError(N.AwaitBindingIdentifier, {
        at: t
      }), s = r[--i];
  }
  validateAsPattern() {
    const {
      stack: t
    } = this, r = t[t.length - 1];
    r.canBeArrowParameterDeclaration() && r.iterateErrors(([i, s]) => {
      this.parser.raise(i, {
        at: s
      });
      let n = t.length - 2, a = t[n];
      for (; a.canBeArrowParameterDeclaration(); )
        a.clearDeclarationError(s.index), a = t[--n];
    });
  }
}
function $y() {
  return new bs(ic);
}
function Uy() {
  return new sc(rc);
}
function Vy() {
  return new sc(ma);
}
function nc() {
  return new bs();
}
const kr = 0, ac = 1, gs = 2, oc = 4, xr = 8;
class Ky {
  constructor() {
    this.stacks = [];
  }
  enter(t) {
    this.stacks.push(t);
  }
  exit() {
    this.stacks.pop();
  }
  currentFlags() {
    return this.stacks[this.stacks.length - 1];
  }
  get hasAwait() {
    return (this.currentFlags() & gs) > 0;
  }
  get hasYield() {
    return (this.currentFlags() & ac) > 0;
  }
  get hasReturn() {
    return (this.currentFlags() & oc) > 0;
  }
  get hasIn() {
    return (this.currentFlags() & xr) > 0;
  }
}
function rs(e, t) {
  return (e ? gs : 0) | (t ? ac : 0);
}
class qy extends My {
  addExtra(t, r, i, s = !0) {
    if (!t)
      return;
    const n = t.extra = t.extra || {};
    s ? n[r] = i : Object.defineProperty(n, r, {
      enumerable: s,
      value: i
    });
  }
  isContextual(t) {
    return this.state.type === t && !this.state.containsEsc;
  }
  isUnparsedContextual(t, r) {
    const i = t + r.length;
    if (this.input.slice(t, i) === r) {
      const s = this.input.charCodeAt(i);
      return !(Nr(s) || (s & 64512) === 55296);
    }
    return !1;
  }
  isLookaheadContextual(t) {
    const r = this.nextTokenStart();
    return this.isUnparsedContextual(r, t);
  }
  eatContextual(t) {
    return this.isContextual(t) ? (this.next(), !0) : !1;
  }
  expectContextual(t, r) {
    if (!this.eatContextual(t)) {
      if (r != null)
        throw this.raise(r, {
          at: this.state.startLoc
        });
      this.unexpected(null, t);
    }
  }
  canInsertSemicolon() {
    return this.match(137) || this.match(8) || this.hasPrecedingLineBreak();
  }
  hasPrecedingLineBreak() {
    return Zu.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
  }
  hasFollowingLineBreak() {
    return vo.lastIndex = this.state.end, vo.test(this.input);
  }
  isLineTerminator() {
    return this.eat(13) || this.canInsertSemicolon();
  }
  semicolon(t = !0) {
    (t ? this.isLineTerminator() : this.eat(13)) || this.raise(N.MissingSemicolon, {
      at: this.state.lastTokEndLoc
    });
  }
  expect(t, r) {
    this.eat(t) || this.unexpected(r, t);
  }
  tryParse(t, r = this.state.clone()) {
    const i = {
      node: null
    };
    try {
      const s = t((n = null) => {
        throw i.node = n, i;
      });
      if (this.state.errors.length > r.errors.length) {
        const n = this.state;
        return this.state = r, this.state.tokensLength = n.tokensLength, {
          node: s,
          error: n.errors[r.errors.length],
          thrown: !1,
          aborted: !1,
          failState: n
        };
      }
      return {
        node: s,
        error: null,
        thrown: !1,
        aborted: !1,
        failState: null
      };
    } catch (s) {
      const n = this.state;
      if (this.state = r, s instanceof SyntaxError)
        return {
          node: null,
          error: s,
          thrown: !0,
          aborted: !1,
          failState: n
        };
      if (s === i)
        return {
          node: i.node,
          error: null,
          thrown: !1,
          aborted: !0,
          failState: n
        };
      throw s;
    }
  }
  checkExpressionErrors(t, r) {
    if (!t)
      return !1;
    const {
      shorthandAssignLoc: i,
      doubleProtoLoc: s,
      privateKeyLoc: n,
      optionalParametersLoc: a
    } = t, o = !!i || !!s || !!a || !!n;
    if (!r)
      return o;
    i != null && this.raise(N.InvalidCoverInitializedName, {
      at: i
    }), s != null && this.raise(N.DuplicateProto, {
      at: s
    }), n != null && this.raise(N.UnexpectedPrivateField, {
      at: n
    }), a != null && this.unexpected(a);
  }
  isLiteralPropertyName() {
    return ju(this.state.type);
  }
  isPrivateName(t) {
    return t.type === "PrivateName";
  }
  getPrivateNameSV(t) {
    return t.id.name;
  }
  hasPropertyAsPrivateName(t) {
    return (t.type === "MemberExpression" || t.type === "OptionalMemberExpression") && this.isPrivateName(t.property);
  }
  isObjectProperty(t) {
    return t.type === "ObjectProperty";
  }
  isObjectMethod(t) {
    return t.type === "ObjectMethod";
  }
  initializeScopes(t = this.options.sourceType === "module") {
    const r = this.state.labels;
    this.state.labels = [];
    const i = this.exportedIdentifiers;
    this.exportedIdentifiers = /* @__PURE__ */ new Set();
    const s = this.inModule;
    this.inModule = t;
    const n = this.scope, a = this.getScopeHandler();
    this.scope = new a(this, t);
    const o = this.prodParam;
    this.prodParam = new Ky();
    const l = this.classScope;
    this.classScope = new Fy(this);
    const u = this.expressionScope;
    return this.expressionScope = new Ry(this), () => {
      this.state.labels = r, this.exportedIdentifiers = i, this.inModule = s, this.scope = n, this.prodParam = o, this.classScope = l, this.expressionScope = u;
    };
  }
  enterInitialScopes() {
    let t = kr;
    this.inModule && (t |= gs), this.scope.enter(Ir), this.prodParam.enter(t);
  }
  checkDestructuringPrivate(t) {
    const {
      privateKeyLoc: r
    } = t;
    r !== null && this.expectPlugin("destructuringPrivate", r);
  }
}
class is {
  constructor() {
    this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
  }
}
class ds {
  constructor(t, r, i) {
    this.type = "", this.start = r, this.end = 0, this.loc = new os(i), t != null && t.options.ranges && (this.range = [r, 0]), t != null && t.filename && (this.loc.filename = t.filename);
  }
}
const ya = ds.prototype;
ya.__clone = function() {
  const e = new ds(void 0, this.start, this.loc.start), t = Object.keys(this);
  for (let r = 0, i = t.length; r < i; r++) {
    const s = t[r];
    s !== "leadingComments" && s !== "trailingComments" && s !== "innerComments" && (e[s] = this[s]);
  }
  return e;
};
function Wy(e) {
  return Bt(e);
}
function Bt(e) {
  const {
    type: t,
    start: r,
    end: i,
    loc: s,
    range: n,
    extra: a,
    name: o
  } = e, l = Object.create(ya);
  return l.type = t, l.start = r, l.end = i, l.loc = s, l.range = n, l.extra = a, l.name = o, t === "Placeholder" && (l.expectedNode = e.expectedNode), l;
}
function Yy(e) {
  const {
    type: t,
    start: r,
    end: i,
    loc: s,
    range: n,
    extra: a
  } = e;
  if (t === "Placeholder")
    return Wy(e);
  const o = Object.create(ya);
  return o.type = t, o.start = r, o.end = i, o.loc = s, o.range = n, e.raw !== void 0 ? o.raw = e.raw : o.extra = a, o.value = e.value, o;
}
class Xy extends qy {
  startNode() {
    return new ds(this, this.state.start, this.state.startLoc);
  }
  startNodeAt(t) {
    return new ds(this, t.index, t);
  }
  startNodeAtNode(t) {
    return this.startNodeAt(t.loc.start);
  }
  finishNode(t, r) {
    return this.finishNodeAt(t, r, this.state.lastTokEndLoc);
  }
  finishNodeAt(t, r, i) {
    return t.type = r, t.end = i.index, t.loc.end = i, this.options.ranges && (t.range[1] = i.index), this.options.attachComment && this.processComment(t), t;
  }
  resetStartLocation(t, r) {
    t.start = r.index, t.loc.start = r, this.options.ranges && (t.range[0] = r.index);
  }
  resetEndLocation(t, r = this.state.lastTokEndLoc) {
    t.end = r.index, t.loc.end = r, this.options.ranges && (t.range[1] = r.index);
  }
  resetStartLocationFromNode(t, r) {
    this.resetStartLocation(t, r.loc.start);
  }
}
const Jy = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), Te = Lt`flow`({
  AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
  AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
  AssignReservedType: ({
    reservedType: e
  }) => `Cannot overwrite reserved type ${e}.`,
  DeclareClassElement: "The `declare` modifier can only appear on class fields.",
  DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
  DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
  EnumBooleanMemberNotInitialized: ({
    memberName: e,
    enumName: t
  }) => `Boolean enum members need to be initialized. Use either \`${e} = true,\` or \`${e} = false,\` in enum \`${t}\`.`,
  EnumDuplicateMemberName: ({
    memberName: e,
    enumName: t
  }) => `Enum member names need to be unique, but the name \`${e}\` has already been used before in enum \`${t}\`.`,
  EnumInconsistentMemberValues: ({
    enumName: e
  }) => `Enum \`${e}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
  EnumInvalidExplicitType: ({
    invalidEnumType: e,
    enumName: t
  }) => `Enum type \`${e}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t}\`.`,
  EnumInvalidExplicitTypeUnknownSupplied: ({
    enumName: e
  }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`,
  EnumInvalidMemberInitializerPrimaryType: ({
    enumName: e,
    memberName: t,
    explicitType: r
  }) => `Enum \`${e}\` has type \`${r}\`, so the initializer of \`${t}\` needs to be a ${r} literal.`,
  EnumInvalidMemberInitializerSymbolType: ({
    enumName: e,
    memberName: t
  }) => `Symbol enum members cannot be initialized. Use \`${t},\` in enum \`${e}\`.`,
  EnumInvalidMemberInitializerUnknownType: ({
    enumName: e,
    memberName: t
  }) => `The enum member initializer for \`${t}\` needs to be a literal (either a boolean, number, or string) in enum \`${e}\`.`,
  EnumInvalidMemberName: ({
    enumName: e,
    memberName: t,
    suggestion: r
  }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${t}\`, consider using \`${r}\`, in enum \`${e}\`.`,
  EnumNumberMemberNotInitialized: ({
    enumName: e,
    memberName: t
  }) => `Number enum members need to be initialized, e.g. \`${t} = 1\` in enum \`${e}\`.`,
  EnumStringMemberInconsistentlyInitailized: ({
    enumName: e
  }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${e}\`.`,
  GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
  ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
  ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
  InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
  InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
  InexactVariance: "Explicit inexact syntax cannot have variance.",
  InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
  MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
  NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
  NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
  PatternIsOptional: Object.assign({
    message: "A binding pattern parameter cannot be optional in an implementation signature."
  }, {
    reasonCode: "OptionalBindingPattern"
  }),
  SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
  SpreadVariance: "Spread properties cannot have variance.",
  ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
  ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
  ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
  ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
  ThisParamNoDefault: "The `this` parameter may not have a default value.",
  TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
  TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
  UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
  UnexpectedReservedType: ({
    reservedType: e
  }) => `Unexpected reserved type ${e}.`,
  UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
  UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
  UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
  UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
  UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
  UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
  UnsupportedDeclareExportKind: ({
    unsupportedExportKind: e,
    suggestion: t
  }) => `\`declare export ${e}\` is not supported. Use \`${t}\` instead.`,
  UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
  UnterminatedFlowComment: "Unterminated flow-comment."
});
function Hy(e) {
  return e.type === "DeclareExportAllDeclaration" || e.type === "DeclareExportDeclaration" && (!e.declaration || e.declaration.type !== "TypeAlias" && e.declaration.type !== "InterfaceDeclaration");
}
function Io(e) {
  return e.importKind === "type" || e.importKind === "typeof";
}
const Gy = {
  const: "declare export var",
  let: "declare export var",
  type: "export type",
  interface: "export interface"
};
function zy(e, t) {
  const r = [], i = [];
  for (let s = 0; s < e.length; s++)
    (t(e[s], s, e) ? r : i).push(e[s]);
  return [r, i];
}
const Qy = /\*?\s*@((?:no)?flow)\b/;
var Zy = (e) => class extends e {
  constructor(...r) {
    super(...r), this.flowPragma = void 0;
  }
  getScopeHandler() {
    return vy;
  }
  shouldParseTypes() {
    return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
  }
  shouldParseEnums() {
    return !!this.getPluginOption("flow", "enums");
  }
  finishToken(r, i) {
    r !== 131 && r !== 13 && r !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(r, i);
  }
  addComment(r) {
    if (this.flowPragma === void 0) {
      const i = Qy.exec(r.value);
      if (i)
        if (i[1] === "flow")
          this.flowPragma = "flow";
        else if (i[1] === "noflow")
          this.flowPragma = "noflow";
        else
          throw new Error("Unexpected flow pragma");
    }
    super.addComment(r);
  }
  flowParseTypeInitialiser(r) {
    const i = this.state.inType;
    this.state.inType = !0, this.expect(r || 14);
    const s = this.flowParseType();
    return this.state.inType = i, s;
  }
  flowParsePredicate() {
    const r = this.startNode(), i = this.state.startLoc;
    return this.next(), this.expectContextual(108), this.state.lastTokStart > i.index + 1 && this.raise(Te.UnexpectedSpaceBetweenModuloChecks, {
      at: i
    }), this.eat(10) ? (r.value = super.parseExpression(), this.expect(11), this.finishNode(r, "DeclaredPredicate")) : this.finishNode(r, "InferredPredicate");
  }
  flowParseTypeAndPredicateInitialiser() {
    const r = this.state.inType;
    this.state.inType = !0, this.expect(14);
    let i = null, s = null;
    return this.match(54) ? (this.state.inType = r, s = this.flowParsePredicate()) : (i = this.flowParseType(), this.state.inType = r, this.match(54) && (s = this.flowParsePredicate())), [i, s];
  }
  flowParseDeclareClass(r) {
    return this.next(), this.flowParseInterfaceish(r, !0), this.finishNode(r, "DeclareClass");
  }
  flowParseDeclareFunction(r) {
    this.next();
    const i = r.id = this.parseIdentifier(), s = this.startNode(), n = this.startNode();
    this.match(47) ? s.typeParameters = this.flowParseTypeParameterDeclaration() : s.typeParameters = null, this.expect(10);
    const a = this.flowParseFunctionTypeParams();
    return s.params = a.params, s.rest = a.rest, s.this = a._this, this.expect(11), [s.returnType, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), n.typeAnnotation = this.finishNode(s, "FunctionTypeAnnotation"), i.typeAnnotation = this.finishNode(n, "TypeAnnotation"), this.resetEndLocation(i), this.semicolon(), this.scope.declareName(r.id.name, Sy, r.id.loc.start), this.finishNode(r, "DeclareFunction");
  }
  flowParseDeclare(r, i) {
    if (this.match(80))
      return this.flowParseDeclareClass(r);
    if (this.match(68))
      return this.flowParseDeclareFunction(r);
    if (this.match(74))
      return this.flowParseDeclareVariable(r);
    if (this.eatContextual(125))
      return this.match(16) ? this.flowParseDeclareModuleExports(r) : (i && this.raise(Te.NestedDeclareModule, {
        at: this.state.lastTokStartLoc
      }), this.flowParseDeclareModule(r));
    if (this.isContextual(128))
      return this.flowParseDeclareTypeAlias(r);
    if (this.isContextual(129))
      return this.flowParseDeclareOpaqueType(r);
    if (this.isContextual(127))
      return this.flowParseDeclareInterface(r);
    if (this.match(82))
      return this.flowParseDeclareExportDeclaration(r, i);
    this.unexpected();
  }
  flowParseDeclareVariable(r) {
    return this.next(), r.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(r.id.name, ps, r.id.loc.start), this.semicolon(), this.finishNode(r, "DeclareVariable");
  }
  flowParseDeclareModule(r) {
    this.scope.enter(Cr), this.match(131) ? r.id = super.parseExprAtom() : r.id = this.parseIdentifier();
    const i = r.body = this.startNode(), s = i.body = [];
    for (this.expect(5); !this.match(8); ) {
      let o = this.startNode();
      this.match(83) ? (this.next(), !this.isContextual(128) && !this.match(87) && this.raise(Te.InvalidNonTypeImportInDeclareModule, {
        at: this.state.lastTokStartLoc
      }), super.parseImport(o)) : (this.expectContextual(123, Te.UnsupportedStatementInDeclareModule), o = this.flowParseDeclare(o, !0)), s.push(o);
    }
    this.scope.exit(), this.expect(8), this.finishNode(i, "BlockStatement");
    let n = null, a = !1;
    return s.forEach((o) => {
      Hy(o) ? (n === "CommonJS" && this.raise(Te.AmbiguousDeclareModuleKind, {
        at: o
      }), n = "ES") : o.type === "DeclareModuleExports" && (a && this.raise(Te.DuplicateDeclareModuleExports, {
        at: o
      }), n === "ES" && this.raise(Te.AmbiguousDeclareModuleKind, {
        at: o
      }), n = "CommonJS", a = !0);
    }), r.kind = n || "CommonJS", this.finishNode(r, "DeclareModule");
  }
  flowParseDeclareExportDeclaration(r, i) {
    if (this.expect(82), this.eat(65))
      return this.match(68) || this.match(80) ? r.declaration = this.flowParseDeclare(this.startNode()) : (r.declaration = this.flowParseType(), this.semicolon()), r.default = !0, this.finishNode(r, "DeclareExportDeclaration");
    if (this.match(75) || this.isLet() || (this.isContextual(128) || this.isContextual(127)) && !i) {
      const s = this.state.value;
      throw this.raise(Te.UnsupportedDeclareExportKind, {
        at: this.state.startLoc,
        unsupportedExportKind: s,
        suggestion: Gy[s]
      });
    }
    if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(129))
      return r.declaration = this.flowParseDeclare(this.startNode()), r.default = !1, this.finishNode(r, "DeclareExportDeclaration");
    if (this.match(55) || this.match(5) || this.isContextual(127) || this.isContextual(128) || this.isContextual(129))
      return r = this.parseExport(r, null), r.type === "ExportNamedDeclaration" && (r.type = "ExportDeclaration", r.default = !1, delete r.exportKind), r.type = "Declare" + r.type, r;
    this.unexpected();
  }
  flowParseDeclareModuleExports(r) {
    return this.next(), this.expectContextual(109), r.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(r, "DeclareModuleExports");
  }
  flowParseDeclareTypeAlias(r) {
    this.next();
    const i = this.flowParseTypeAlias(r);
    return i.type = "DeclareTypeAlias", i;
  }
  flowParseDeclareOpaqueType(r) {
    this.next();
    const i = this.flowParseOpaqueType(r, !0);
    return i.type = "DeclareOpaqueType", i;
  }
  flowParseDeclareInterface(r) {
    return this.next(), this.flowParseInterfaceish(r, !1), this.finishNode(r, "DeclareInterface");
  }
  flowParseInterfaceish(r, i) {
    if (r.id = this.flowParseRestrictedIdentifier(!i, !0), this.scope.declareName(r.id.name, i ? Gu : Dr, r.id.loc.start), this.match(47) ? r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.extends = [], this.eat(81))
      do
        r.extends.push(this.flowParseInterfaceExtends());
      while (!i && this.eat(12));
    if (i) {
      if (r.implements = [], r.mixins = [], this.eatContextual(115))
        do
          r.mixins.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      if (this.eatContextual(111))
        do
          r.implements.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
    }
    r.body = this.flowParseObjectType({
      allowStatic: i,
      allowExact: !1,
      allowSpread: !1,
      allowProto: i,
      allowInexact: !1
    });
  }
  flowParseInterfaceExtends() {
    const r = this.startNode();
    return r.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? r.typeParameters = this.flowParseTypeParameterInstantiation() : r.typeParameters = null, this.finishNode(r, "InterfaceExtends");
  }
  flowParseInterface(r) {
    return this.flowParseInterfaceish(r, !1), this.finishNode(r, "InterfaceDeclaration");
  }
  checkNotUnderscore(r) {
    r === "_" && this.raise(Te.UnexpectedReservedUnderscore, {
      at: this.state.startLoc
    });
  }
  checkReservedType(r, i, s) {
    Jy.has(r) && this.raise(s ? Te.AssignReservedType : Te.UnexpectedReservedType, {
      at: i,
      reservedType: r
    });
  }
  flowParseRestrictedIdentifier(r, i) {
    return this.checkReservedType(this.state.value, this.state.startLoc, i), this.parseIdentifier(r);
  }
  flowParseTypeAlias(r) {
    return r.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(r.id.name, Dr, r.id.loc.start), this.match(47) ? r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(r, "TypeAlias");
  }
  flowParseOpaqueType(r, i) {
    return this.expectContextual(128), r.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(r.id.name, Dr, r.id.loc.start), this.match(47) ? r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.supertype = null, this.match(14) && (r.supertype = this.flowParseTypeInitialiser(14)), r.impltype = null, i || (r.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(r, "OpaqueType");
  }
  flowParseTypeParameter(r = !1) {
    const i = this.state.startLoc, s = this.startNode(), n = this.flowParseVariance(), a = this.flowParseTypeAnnotatableIdentifier();
    return s.name = a.name, s.variance = n, s.bound = a.typeAnnotation, this.match(29) ? (this.eat(29), s.default = this.flowParseType()) : r && this.raise(Te.MissingTypeParamDefault, {
      at: i
    }), this.finishNode(s, "TypeParameter");
  }
  flowParseTypeParameterDeclaration() {
    const r = this.state.inType, i = this.startNode();
    i.params = [], this.state.inType = !0, this.match(47) || this.match(140) ? this.next() : this.unexpected();
    let s = !1;
    do {
      const n = this.flowParseTypeParameter(s);
      i.params.push(n), n.default && (s = !0), this.match(48) || this.expect(12);
    } while (!this.match(48));
    return this.expect(48), this.state.inType = r, this.finishNode(i, "TypeParameterDeclaration");
  }
  flowParseTypeParameterInstantiation() {
    const r = this.startNode(), i = this.state.inType;
    r.params = [], this.state.inType = !0, this.expect(47);
    const s = this.state.noAnonFunctionType;
    for (this.state.noAnonFunctionType = !1; !this.match(48); )
      r.params.push(this.flowParseType()), this.match(48) || this.expect(12);
    return this.state.noAnonFunctionType = s, this.expect(48), this.state.inType = i, this.finishNode(r, "TypeParameterInstantiation");
  }
  flowParseTypeParameterInstantiationCallOrNew() {
    const r = this.startNode(), i = this.state.inType;
    for (r.params = [], this.state.inType = !0, this.expect(47); !this.match(48); )
      r.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
    return this.expect(48), this.state.inType = i, this.finishNode(r, "TypeParameterInstantiation");
  }
  flowParseInterfaceType() {
    const r = this.startNode();
    if (this.expectContextual(127), r.extends = [], this.eat(81))
      do
        r.extends.push(this.flowParseInterfaceExtends());
      while (this.eat(12));
    return r.body = this.flowParseObjectType({
      allowStatic: !1,
      allowExact: !1,
      allowSpread: !1,
      allowProto: !1,
      allowInexact: !1
    }), this.finishNode(r, "InterfaceTypeAnnotation");
  }
  flowParseObjectPropertyKey() {
    return this.match(132) || this.match(131) ? super.parseExprAtom() : this.parseIdentifier(!0);
  }
  flowParseObjectTypeIndexer(r, i, s) {
    return r.static = i, this.lookahead().type === 14 ? (r.id = this.flowParseObjectPropertyKey(), r.key = this.flowParseTypeInitialiser()) : (r.id = null, r.key = this.flowParseType()), this.expect(3), r.value = this.flowParseTypeInitialiser(), r.variance = s, this.finishNode(r, "ObjectTypeIndexer");
  }
  flowParseObjectTypeInternalSlot(r, i) {
    return r.static = i, r.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (r.method = !0, r.optional = !1, r.value = this.flowParseObjectTypeMethodish(this.startNodeAt(r.loc.start))) : (r.method = !1, this.eat(17) && (r.optional = !0), r.value = this.flowParseTypeInitialiser()), this.finishNode(r, "ObjectTypeInternalSlot");
  }
  flowParseObjectTypeMethodish(r) {
    for (r.params = [], r.rest = null, r.typeParameters = null, r.this = null, this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (r.this = this.flowParseFunctionTypeParam(!0), r.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
      r.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
    return this.eat(21) && (r.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), r.returnType = this.flowParseTypeInitialiser(), this.finishNode(r, "FunctionTypeAnnotation");
  }
  flowParseObjectTypeCallProperty(r, i) {
    const s = this.startNode();
    return r.static = i, r.value = this.flowParseObjectTypeMethodish(s), this.finishNode(r, "ObjectTypeCallProperty");
  }
  flowParseObjectType({
    allowStatic: r,
    allowExact: i,
    allowSpread: s,
    allowProto: n,
    allowInexact: a
  }) {
    const o = this.state.inType;
    this.state.inType = !0;
    const l = this.startNode();
    l.callProperties = [], l.properties = [], l.indexers = [], l.internalSlots = [];
    let u, c, p = !1;
    for (i && this.match(6) ? (this.expect(6), u = 9, c = !0) : (this.expect(5), u = 8, c = !1), l.exact = c; !this.match(u); ) {
      let y = !1, P = null, v = null;
      const w = this.startNode();
      if (n && this.isContextual(116)) {
        const O = this.lookahead();
        O.type !== 14 && O.type !== 17 && (this.next(), P = this.state.startLoc, r = !1);
      }
      if (r && this.isContextual(104)) {
        const O = this.lookahead();
        O.type !== 14 && O.type !== 17 && (this.next(), y = !0);
      }
      const x = this.flowParseVariance();
      if (this.eat(0))
        P != null && this.unexpected(P), this.eat(0) ? (x && this.unexpected(x.loc.start), l.internalSlots.push(this.flowParseObjectTypeInternalSlot(w, y))) : l.indexers.push(this.flowParseObjectTypeIndexer(w, y, x));
      else if (this.match(10) || this.match(47))
        P != null && this.unexpected(P), x && this.unexpected(x.loc.start), l.callProperties.push(this.flowParseObjectTypeCallProperty(w, y));
      else {
        let O = "init";
        if (this.isContextual(98) || this.isContextual(103)) {
          const K = this.lookahead();
          ju(K.type) && (O = this.state.value, this.next());
        }
        const _ = this.flowParseObjectTypeProperty(w, y, P, x, O, s, a ?? !c);
        _ === null ? (p = !0, v = this.state.lastTokStartLoc) : l.properties.push(_);
      }
      this.flowObjectTypeSemicolon(), v && !this.match(8) && !this.match(9) && this.raise(Te.UnexpectedExplicitInexactInObject, {
        at: v
      });
    }
    this.expect(u), s && (l.inexact = p);
    const h = this.finishNode(l, "ObjectTypeAnnotation");
    return this.state.inType = o, h;
  }
  flowParseObjectTypeProperty(r, i, s, n, a, o, l) {
    if (this.eat(21))
      return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (o ? l || this.raise(Te.InexactInsideExact, {
        at: this.state.lastTokStartLoc
      }) : this.raise(Te.InexactInsideNonObject, {
        at: this.state.lastTokStartLoc
      }), n && this.raise(Te.InexactVariance, {
        at: n
      }), null) : (o || this.raise(Te.UnexpectedSpreadType, {
        at: this.state.lastTokStartLoc
      }), s != null && this.unexpected(s), n && this.raise(Te.SpreadVariance, {
        at: n
      }), r.argument = this.flowParseType(), this.finishNode(r, "ObjectTypeSpreadProperty"));
    {
      r.key = this.flowParseObjectPropertyKey(), r.static = i, r.proto = s != null, r.kind = a;
      let u = !1;
      return this.match(47) || this.match(10) ? (r.method = !0, s != null && this.unexpected(s), n && this.unexpected(n.loc.start), r.value = this.flowParseObjectTypeMethodish(this.startNodeAt(r.loc.start)), (a === "get" || a === "set") && this.flowCheckGetterSetterParams(r), !o && r.key.name === "constructor" && r.value.this && this.raise(Te.ThisParamBannedInConstructor, {
        at: r.value.this
      })) : (a !== "init" && this.unexpected(), r.method = !1, this.eat(17) && (u = !0), r.value = this.flowParseTypeInitialiser(), r.variance = n), r.optional = u, this.finishNode(r, "ObjectTypeProperty");
    }
  }
  flowCheckGetterSetterParams(r) {
    const i = r.kind === "get" ? 0 : 1, s = r.value.params.length + (r.value.rest ? 1 : 0);
    r.value.this && this.raise(r.kind === "get" ? Te.GetterMayNotHaveThisParam : Te.SetterMayNotHaveThisParam, {
      at: r.value.this
    }), s !== i && this.raise(r.kind === "get" ? N.BadGetterArity : N.BadSetterArity, {
      at: r
    }), r.kind === "set" && r.value.rest && this.raise(N.BadSetterRestParameter, {
      at: r
    });
  }
  flowObjectTypeSemicolon() {
    !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
  }
  flowParseQualifiedTypeIdentifier(r, i) {
    var s;
    (s = r) != null || (r = this.state.startLoc);
    let n = i || this.flowParseRestrictedIdentifier(!0);
    for (; this.eat(16); ) {
      const a = this.startNodeAt(r);
      a.qualification = n, a.id = this.flowParseRestrictedIdentifier(!0), n = this.finishNode(a, "QualifiedTypeIdentifier");
    }
    return n;
  }
  flowParseGenericType(r, i) {
    const s = this.startNodeAt(r);
    return s.typeParameters = null, s.id = this.flowParseQualifiedTypeIdentifier(r, i), this.match(47) && (s.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(s, "GenericTypeAnnotation");
  }
  flowParseTypeofType() {
    const r = this.startNode();
    return this.expect(87), r.argument = this.flowParsePrimaryType(), this.finishNode(r, "TypeofTypeAnnotation");
  }
  flowParseTupleType() {
    const r = this.startNode();
    for (r.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (r.types.push(this.flowParseType()), !this.match(3)); )
      this.expect(12);
    return this.expect(3), this.finishNode(r, "TupleTypeAnnotation");
  }
  flowParseFunctionTypeParam(r) {
    let i = null, s = !1, n = null;
    const a = this.startNode(), o = this.lookahead(), l = this.state.type === 78;
    return o.type === 14 || o.type === 17 ? (l && !r && this.raise(Te.ThisParamMustBeFirst, {
      at: a
    }), i = this.parseIdentifier(l), this.eat(17) && (s = !0, l && this.raise(Te.ThisParamMayNotBeOptional, {
      at: a
    })), n = this.flowParseTypeInitialiser()) : n = this.flowParseType(), a.name = i, a.optional = s, a.typeAnnotation = n, this.finishNode(a, "FunctionTypeParam");
  }
  reinterpretTypeAsFunctionTypeParam(r) {
    const i = this.startNodeAt(r.loc.start);
    return i.name = null, i.optional = !1, i.typeAnnotation = r, this.finishNode(i, "FunctionTypeParam");
  }
  flowParseFunctionTypeParams(r = []) {
    let i = null, s = null;
    for (this.match(78) && (s = this.flowParseFunctionTypeParam(!0), s.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
      r.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
    return this.eat(21) && (i = this.flowParseFunctionTypeParam(!1)), {
      params: r,
      rest: i,
      _this: s
    };
  }
  flowIdentToTypeAnnotation(r, i, s) {
    switch (s.name) {
      case "any":
        return this.finishNode(i, "AnyTypeAnnotation");
      case "bool":
      case "boolean":
        return this.finishNode(i, "BooleanTypeAnnotation");
      case "mixed":
        return this.finishNode(i, "MixedTypeAnnotation");
      case "empty":
        return this.finishNode(i, "EmptyTypeAnnotation");
      case "number":
        return this.finishNode(i, "NumberTypeAnnotation");
      case "string":
        return this.finishNode(i, "StringTypeAnnotation");
      case "symbol":
        return this.finishNode(i, "SymbolTypeAnnotation");
      default:
        return this.checkNotUnderscore(s.name), this.flowParseGenericType(r, s);
    }
  }
  flowParsePrimaryType() {
    const r = this.state.startLoc, i = this.startNode();
    let s, n, a = !1;
    const o = this.state.noAnonFunctionType;
    switch (this.state.type) {
      case 5:
        return this.flowParseObjectType({
          allowStatic: !1,
          allowExact: !1,
          allowSpread: !0,
          allowProto: !1,
          allowInexact: !0
        });
      case 6:
        return this.flowParseObjectType({
          allowStatic: !1,
          allowExact: !0,
          allowSpread: !0,
          allowProto: !1,
          allowInexact: !1
        });
      case 0:
        return this.state.noAnonFunctionType = !1, n = this.flowParseTupleType(), this.state.noAnonFunctionType = o, n;
      case 47:
        return i.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), s = this.flowParseFunctionTypeParams(), i.params = s.params, i.rest = s.rest, i.this = s._this, this.expect(11), this.expect(19), i.returnType = this.flowParseType(), this.finishNode(i, "FunctionTypeAnnotation");
      case 10:
        if (this.next(), !this.match(11) && !this.match(21))
          if (ke(this.state.type) || this.match(78)) {
            const l = this.lookahead().type;
            a = l !== 17 && l !== 14;
          } else
            a = !0;
        if (a) {
          if (this.state.noAnonFunctionType = !1, n = this.flowParseType(), this.state.noAnonFunctionType = o, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19))
            return this.expect(11), n;
          this.eat(12);
        }
        return n ? s = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(n)]) : s = this.flowParseFunctionTypeParams(), i.params = s.params, i.rest = s.rest, i.this = s._this, this.expect(11), this.expect(19), i.returnType = this.flowParseType(), i.typeParameters = null, this.finishNode(i, "FunctionTypeAnnotation");
      case 131:
        return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
      case 85:
      case 86:
        return i.value = this.match(85), this.next(), this.finishNode(i, "BooleanLiteralTypeAnnotation");
      case 53:
        if (this.state.value === "-") {
          if (this.next(), this.match(132))
            return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", i);
          if (this.match(133))
            return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", i);
          throw this.raise(Te.UnexpectedSubtractionOperand, {
            at: this.state.startLoc
          });
        }
        this.unexpected();
        return;
      case 132:
        return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
      case 133:
        return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
      case 88:
        return this.next(), this.finishNode(i, "VoidTypeAnnotation");
      case 84:
        return this.next(), this.finishNode(i, "NullLiteralTypeAnnotation");
      case 78:
        return this.next(), this.finishNode(i, "ThisTypeAnnotation");
      case 55:
        return this.next(), this.finishNode(i, "ExistsTypeAnnotation");
      case 87:
        return this.flowParseTypeofType();
      default:
        if (na(this.state.type)) {
          const l = Ht(this.state.type);
          return this.next(), super.createIdentifier(i, l);
        } else if (ke(this.state.type))
          return this.isContextual(127) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(r, i, this.parseIdentifier());
    }
    this.unexpected();
  }
  flowParsePostfixType() {
    const r = this.state.startLoc;
    let i = this.flowParsePrimaryType(), s = !1;
    for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
      const n = this.startNodeAt(r), a = this.eat(18);
      s = s || a, this.expect(0), !a && this.match(3) ? (n.elementType = i, this.next(), i = this.finishNode(n, "ArrayTypeAnnotation")) : (n.objectType = i, n.indexType = this.flowParseType(), this.expect(3), s ? (n.optional = a, i = this.finishNode(n, "OptionalIndexedAccessType")) : i = this.finishNode(n, "IndexedAccessType"));
    }
    return i;
  }
  flowParsePrefixType() {
    const r = this.startNode();
    return this.eat(17) ? (r.typeAnnotation = this.flowParsePrefixType(), this.finishNode(r, "NullableTypeAnnotation")) : this.flowParsePostfixType();
  }
  flowParseAnonFunctionWithoutParens() {
    const r = this.flowParsePrefixType();
    if (!this.state.noAnonFunctionType && this.eat(19)) {
      const i = this.startNodeAt(r.loc.start);
      return i.params = [this.reinterpretTypeAsFunctionTypeParam(r)], i.rest = null, i.this = null, i.returnType = this.flowParseType(), i.typeParameters = null, this.finishNode(i, "FunctionTypeAnnotation");
    }
    return r;
  }
  flowParseIntersectionType() {
    const r = this.startNode();
    this.eat(45);
    const i = this.flowParseAnonFunctionWithoutParens();
    for (r.types = [i]; this.eat(45); )
      r.types.push(this.flowParseAnonFunctionWithoutParens());
    return r.types.length === 1 ? i : this.finishNode(r, "IntersectionTypeAnnotation");
  }
  flowParseUnionType() {
    const r = this.startNode();
    this.eat(43);
    const i = this.flowParseIntersectionType();
    for (r.types = [i]; this.eat(43); )
      r.types.push(this.flowParseIntersectionType());
    return r.types.length === 1 ? i : this.finishNode(r, "UnionTypeAnnotation");
  }
  flowParseType() {
    const r = this.state.inType;
    this.state.inType = !0;
    const i = this.flowParseUnionType();
    return this.state.inType = r, i;
  }
  flowParseTypeOrImplicitInstantiation() {
    if (this.state.type === 130 && this.state.value === "_") {
      const r = this.state.startLoc, i = this.parseIdentifier();
      return this.flowParseGenericType(r, i);
    } else
      return this.flowParseType();
  }
  flowParseTypeAnnotation() {
    const r = this.startNode();
    return r.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(r, "TypeAnnotation");
  }
  flowParseTypeAnnotatableIdentifier(r) {
    const i = r ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
    return this.match(14) && (i.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(i)), i;
  }
  typeCastToParameter(r) {
    return r.expression.typeAnnotation = r.typeAnnotation, this.resetEndLocation(r.expression, r.typeAnnotation.loc.end), r.expression;
  }
  flowParseVariance() {
    let r = null;
    return this.match(53) ? (r = this.startNode(), this.state.value === "+" ? r.kind = "plus" : r.kind = "minus", this.next(), this.finishNode(r, "Variance")) : r;
  }
  parseFunctionBody(r, i, s = !1) {
    if (i) {
      this.forwardNoArrowParamsConversionAt(r, () => super.parseFunctionBody(r, !0, s));
      return;
    }
    super.parseFunctionBody(r, !1, s);
  }
  parseFunctionBodyAndFinish(r, i, s = !1) {
    if (this.match(14)) {
      const n = this.startNode();
      [n.typeAnnotation, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), r.returnType = n.typeAnnotation ? this.finishNode(n, "TypeAnnotation") : null;
    }
    return super.parseFunctionBodyAndFinish(r, i, s);
  }
  parseStatementLike(r) {
    if (this.state.strict && this.isContextual(127)) {
      const s = this.lookahead();
      if (bt(s.type)) {
        const n = this.startNode();
        return this.next(), this.flowParseInterface(n);
      }
    } else if (this.shouldParseEnums() && this.isContextual(124)) {
      const s = this.startNode();
      return this.next(), this.flowParseEnumDeclaration(s);
    }
    const i = super.parseStatementLike(r);
    return this.flowPragma === void 0 && !this.isValidDirective(i) && (this.flowPragma = null), i;
  }
  parseExpressionStatement(r, i, s) {
    if (i.type === "Identifier") {
      if (i.name === "declare") {
        if (this.match(80) || ke(this.state.type) || this.match(68) || this.match(74) || this.match(82))
          return this.flowParseDeclare(r);
      } else if (ke(this.state.type)) {
        if (i.name === "interface")
          return this.flowParseInterface(r);
        if (i.name === "type")
          return this.flowParseTypeAlias(r);
        if (i.name === "opaque")
          return this.flowParseOpaqueType(r, !1);
      }
    }
    return super.parseExpressionStatement(r, i, s);
  }
  shouldParseExportDeclaration() {
    const {
      type: r
    } = this.state;
    return Eo(r) || this.shouldParseEnums() && r === 124 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
  }
  isExportDefaultSpecifier() {
    const {
      type: r
    } = this.state;
    return Eo(r) || this.shouldParseEnums() && r === 124 ? this.state.containsEsc : super.isExportDefaultSpecifier();
  }
  parseExportDefaultExpression() {
    if (this.shouldParseEnums() && this.isContextual(124)) {
      const r = this.startNode();
      return this.next(), this.flowParseEnumDeclaration(r);
    }
    return super.parseExportDefaultExpression();
  }
  parseConditional(r, i, s) {
    if (!this.match(17))
      return r;
    if (this.state.maybeInArrowParameters) {
      const h = this.lookaheadCharCode();
      if (h === 44 || h === 61 || h === 58 || h === 41)
        return this.setOptionalParametersError(s), r;
    }
    this.expect(17);
    const n = this.state.clone(), a = this.state.noArrowAt, o = this.startNodeAt(i);
    let {
      consequent: l,
      failed: u
    } = this.tryParseConditionalConsequent(), [c, p] = this.getArrowLikeExpressions(l);
    if (u || p.length > 0) {
      const h = [...a];
      if (p.length > 0) {
        this.state = n, this.state.noArrowAt = h;
        for (let y = 0; y < p.length; y++)
          h.push(p[y].start);
        ({
          consequent: l,
          failed: u
        } = this.tryParseConditionalConsequent()), [c, p] = this.getArrowLikeExpressions(l);
      }
      u && c.length > 1 && this.raise(Te.AmbiguousConditionalArrow, {
        at: n.startLoc
      }), u && c.length === 1 && (this.state = n, h.push(c[0].start), this.state.noArrowAt = h, {
        consequent: l,
        failed: u
      } = this.tryParseConditionalConsequent());
    }
    return this.getArrowLikeExpressions(l, !0), this.state.noArrowAt = a, this.expect(14), o.test = r, o.consequent = l, o.alternate = this.forwardNoArrowParamsConversionAt(o, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(o, "ConditionalExpression");
  }
  tryParseConditionalConsequent() {
    this.state.noArrowParamsConversionAt.push(this.state.start);
    const r = this.parseMaybeAssignAllowIn(), i = !this.match(14);
    return this.state.noArrowParamsConversionAt.pop(), {
      consequent: r,
      failed: i
    };
  }
  getArrowLikeExpressions(r, i) {
    const s = [r], n = [];
    for (; s.length !== 0; ) {
      const a = s.pop();
      a.type === "ArrowFunctionExpression" ? (a.typeParameters || !a.returnType ? this.finishArrowValidation(a) : n.push(a), s.push(a.body)) : a.type === "ConditionalExpression" && (s.push(a.consequent), s.push(a.alternate));
    }
    return i ? (n.forEach((a) => this.finishArrowValidation(a)), [n, []]) : zy(n, (a) => a.params.every((o) => this.isAssignable(o, !0)));
  }
  finishArrowValidation(r) {
    var i;
    this.toAssignableList(r.params, (i = r.extra) == null ? void 0 : i.trailingCommaLoc, !1), this.scope.enter(Mt | la), super.checkParams(r, !1, !0), this.scope.exit();
  }
  forwardNoArrowParamsConversionAt(r, i) {
    let s;
    return this.state.noArrowParamsConversionAt.indexOf(r.start) !== -1 ? (this.state.noArrowParamsConversionAt.push(this.state.start), s = i(), this.state.noArrowParamsConversionAt.pop()) : s = i(), s;
  }
  parseParenItem(r, i) {
    if (r = super.parseParenItem(r, i), this.eat(17) && (r.optional = !0, this.resetEndLocation(r)), this.match(14)) {
      const s = this.startNodeAt(i);
      return s.expression = r, s.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(s, "TypeCastExpression");
    }
    return r;
  }
  assertModuleNodeAllowed(r) {
    r.type === "ImportDeclaration" && (r.importKind === "type" || r.importKind === "typeof") || r.type === "ExportNamedDeclaration" && r.exportKind === "type" || r.type === "ExportAllDeclaration" && r.exportKind === "type" || super.assertModuleNodeAllowed(r);
  }
  parseExportDeclaration(r) {
    if (this.isContextual(128)) {
      r.exportKind = "type";
      const i = this.startNode();
      return this.next(), this.match(5) ? (r.specifiers = this.parseExportSpecifiers(!0), super.parseExportFrom(r), null) : this.flowParseTypeAlias(i);
    } else if (this.isContextual(129)) {
      r.exportKind = "type";
      const i = this.startNode();
      return this.next(), this.flowParseOpaqueType(i, !1);
    } else if (this.isContextual(127)) {
      r.exportKind = "type";
      const i = this.startNode();
      return this.next(), this.flowParseInterface(i);
    } else if (this.shouldParseEnums() && this.isContextual(124)) {
      r.exportKind = "value";
      const i = this.startNode();
      return this.next(), this.flowParseEnumDeclaration(i);
    } else
      return super.parseExportDeclaration(r);
  }
  eatExportStar(r) {
    return super.eatExportStar(r) ? !0 : this.isContextual(128) && this.lookahead().type === 55 ? (r.exportKind = "type", this.next(), this.next(), !0) : !1;
  }
  maybeParseExportNamespaceSpecifier(r) {
    const {
      startLoc: i
    } = this.state, s = super.maybeParseExportNamespaceSpecifier(r);
    return s && r.exportKind === "type" && this.unexpected(i), s;
  }
  parseClassId(r, i, s) {
    super.parseClassId(r, i, s), this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration());
  }
  parseClassMember(r, i, s) {
    const {
      startLoc: n
    } = this.state;
    if (this.isContextual(123)) {
      if (super.parseClassMemberFromModifier(r, i))
        return;
      i.declare = !0;
    }
    super.parseClassMember(r, i, s), i.declare && (i.type !== "ClassProperty" && i.type !== "ClassPrivateProperty" && i.type !== "PropertyDefinition" ? this.raise(Te.DeclareClassElement, {
      at: n
    }) : i.value && this.raise(Te.DeclareClassFieldInitializer, {
      at: i.value
    }));
  }
  isIterator(r) {
    return r === "iterator" || r === "asyncIterator";
  }
  readIterator() {
    const r = super.readWord1(), i = "@@" + r;
    (!this.isIterator(r) || !this.state.inType) && this.raise(N.InvalidIdentifier, {
      at: this.state.curPosition(),
      identifierName: i
    }), this.finishToken(130, i);
  }
  getTokenFromCode(r) {
    const i = this.input.charCodeAt(this.state.pos + 1);
    r === 123 && i === 124 ? this.finishOp(6, 2) : this.state.inType && (r === 62 || r === 60) ? this.finishOp(r === 62 ? 48 : 47, 1) : this.state.inType && r === 63 ? i === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : uy(r, i, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(r);
  }
  isAssignable(r, i) {
    return r.type === "TypeCastExpression" ? this.isAssignable(r.expression, i) : super.isAssignable(r, i);
  }
  toAssignable(r, i = !1) {
    !i && r.type === "AssignmentExpression" && r.left.type === "TypeCastExpression" && (r.left = this.typeCastToParameter(r.left)), super.toAssignable(r, i);
  }
  toAssignableList(r, i, s) {
    for (let n = 0; n < r.length; n++) {
      const a = r[n];
      (a == null ? void 0 : a.type) === "TypeCastExpression" && (r[n] = this.typeCastToParameter(a));
    }
    super.toAssignableList(r, i, s);
  }
  toReferencedList(r, i) {
    for (let n = 0; n < r.length; n++) {
      var s;
      const a = r[n];
      a && a.type === "TypeCastExpression" && !((s = a.extra) != null && s.parenthesized) && (r.length > 1 || !i) && this.raise(Te.TypeCastInPattern, {
        at: a.typeAnnotation
      });
    }
    return r;
  }
  parseArrayLike(r, i, s, n) {
    const a = super.parseArrayLike(r, i, s, n);
    return i && !this.state.maybeInArrowParameters && this.toReferencedList(a.elements), a;
  }
  isValidLVal(r, i, s) {
    return r === "TypeCastExpression" || super.isValidLVal(r, i, s);
  }
  parseClassProperty(r) {
    return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(r);
  }
  parseClassPrivateProperty(r) {
    return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(r);
  }
  isClassMethod() {
    return this.match(47) || super.isClassMethod();
  }
  isClassProperty() {
    return this.match(14) || super.isClassProperty();
  }
  isNonstaticConstructor(r) {
    return !this.match(14) && super.isNonstaticConstructor(r);
  }
  pushClassMethod(r, i, s, n, a, o) {
    if (i.variance && this.unexpected(i.variance.loc.start), delete i.variance, this.match(47) && (i.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(r, i, s, n, a, o), i.params && a) {
      const l = i.params;
      l.length > 0 && this.isThisParam(l[0]) && this.raise(Te.ThisParamBannedInConstructor, {
        at: i
      });
    } else if (i.type === "MethodDefinition" && a && i.value.params) {
      const l = i.value.params;
      l.length > 0 && this.isThisParam(l[0]) && this.raise(Te.ThisParamBannedInConstructor, {
        at: i
      });
    }
  }
  pushClassPrivateMethod(r, i, s, n) {
    i.variance && this.unexpected(i.variance.loc.start), delete i.variance, this.match(47) && (i.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(r, i, s, n);
  }
  parseClassSuper(r) {
    if (super.parseClassSuper(r), r.superClass && this.match(47) && (r.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(111)) {
      this.next();
      const i = r.implements = [];
      do {
        const s = this.startNode();
        s.id = this.flowParseRestrictedIdentifier(!0), this.match(47) ? s.typeParameters = this.flowParseTypeParameterInstantiation() : s.typeParameters = null, i.push(this.finishNode(s, "ClassImplements"));
      } while (this.eat(12));
    }
  }
  checkGetterSetterParams(r) {
    super.checkGetterSetterParams(r);
    const i = this.getObjectOrClassMethodParams(r);
    if (i.length > 0) {
      const s = i[0];
      this.isThisParam(s) && r.kind === "get" ? this.raise(Te.GetterMayNotHaveThisParam, {
        at: s
      }) : this.isThisParam(s) && this.raise(Te.SetterMayNotHaveThisParam, {
        at: s
      });
    }
  }
  parsePropertyNamePrefixOperator(r) {
    r.variance = this.flowParseVariance();
  }
  parseObjPropValue(r, i, s, n, a, o, l) {
    r.variance && this.unexpected(r.variance.loc.start), delete r.variance;
    let u;
    this.match(47) && !o && (u = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
    const c = super.parseObjPropValue(r, i, s, n, a, o, l);
    return u && ((c.value || c).typeParameters = u), c;
  }
  parseAssignableListItemTypes(r) {
    return this.eat(17) && (r.type !== "Identifier" && this.raise(Te.PatternIsOptional, {
      at: r
    }), this.isThisParam(r) && this.raise(Te.ThisParamMayNotBeOptional, {
      at: r
    }), r.optional = !0), this.match(14) ? r.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(r) && this.raise(Te.ThisParamAnnotationRequired, {
      at: r
    }), this.match(29) && this.isThisParam(r) && this.raise(Te.ThisParamNoDefault, {
      at: r
    }), this.resetEndLocation(r), r;
  }
  parseMaybeDefault(r, i) {
    const s = super.parseMaybeDefault(r, i);
    return s.type === "AssignmentPattern" && s.typeAnnotation && s.right.start < s.typeAnnotation.start && this.raise(Te.TypeBeforeInitializer, {
      at: s.typeAnnotation
    }), s;
  }
  checkImportReflection(r) {
    super.checkImportReflection(r), r.module && r.importKind !== "value" && this.raise(Te.ImportReflectionHasImportType, {
      at: r.specifiers[0].loc.start
    });
  }
  parseImportSpecifierLocal(r, i, s) {
    i.local = Io(r) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), r.specifiers.push(this.finishImportSpecifier(i, s));
  }
  isPotentialImportPhase(r) {
    if (super.isPotentialImportPhase(r))
      return !0;
    if (this.isContextual(128)) {
      if (!r)
        return !0;
      const i = this.lookaheadCharCode();
      return i === 123 || i === 42;
    }
    return !r && this.isContextual(87);
  }
  applyImportPhase(r, i, s, n) {
    if (super.applyImportPhase(r, i, s, n), i) {
      if (!s && this.match(65))
        return;
      r.exportKind = s === "type" ? s : "value";
    } else
      s === "type" && this.match(55) && this.unexpected(), r.importKind = s === "type" || s === "typeof" ? s : "value";
  }
  parseImportSpecifier(r, i, s, n, a) {
    const o = r.imported;
    let l = null;
    o.type === "Identifier" && (o.name === "type" ? l = "type" : o.name === "typeof" && (l = "typeof"));
    let u = !1;
    if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
      const p = this.parseIdentifier(!0);
      l !== null && !bt(this.state.type) ? (r.imported = p, r.importKind = l, r.local = Bt(p)) : (r.imported = o, r.importKind = null, r.local = this.parseIdentifier());
    } else {
      if (l !== null && bt(this.state.type))
        r.imported = this.parseIdentifier(!0), r.importKind = l;
      else {
        if (i)
          throw this.raise(N.ImportBindingIsString, {
            at: r,
            importName: o.value
          });
        r.imported = o, r.importKind = null;
      }
      this.eatContextual(93) ? r.local = this.parseIdentifier() : (u = !0, r.local = Bt(r.imported));
    }
    const c = Io(r);
    return s && c && this.raise(Te.ImportTypeShorthandOnlyInPureImport, {
      at: r
    }), (s || c) && this.checkReservedType(r.local.name, r.local.loc.start, !0), u && !s && !c && this.checkReservedWord(r.local.name, r.loc.start, !0, !0), this.finishImportSpecifier(r, "ImportSpecifier");
  }
  parseBindingAtom() {
    switch (this.state.type) {
      case 78:
        return this.parseIdentifier(!0);
      default:
        return super.parseBindingAtom();
    }
  }
  parseFunctionParams(r, i) {
    const s = r.kind;
    s !== "get" && s !== "set" && this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(r, i);
  }
  parseVarId(r, i) {
    super.parseVarId(r, i), this.match(14) && (r.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(r.id));
  }
  parseAsyncArrowFromCallExpression(r, i) {
    if (this.match(14)) {
      const s = this.state.noAnonFunctionType;
      this.state.noAnonFunctionType = !0, r.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = s;
    }
    return super.parseAsyncArrowFromCallExpression(r, i);
  }
  shouldParseAsyncArrow() {
    return this.match(14) || super.shouldParseAsyncArrow();
  }
  parseMaybeAssign(r, i) {
    var s;
    let n = null, a;
    if (this.hasPlugin("jsx") && (this.match(140) || this.match(47))) {
      if (n = this.state.clone(), a = this.tryParse(() => super.parseMaybeAssign(r, i), n), !a.error)
        return a.node;
      const {
        context: u
      } = this.state, c = u[u.length - 1];
      (c === Be.j_oTag || c === Be.j_expr) && u.pop();
    }
    if ((s = a) != null && s.error || this.match(47)) {
      var o, l;
      n = n || this.state.clone();
      let u;
      const c = this.tryParse((h) => {
        var y;
        u = this.flowParseTypeParameterDeclaration();
        const P = this.forwardNoArrowParamsConversionAt(u, () => {
          const w = super.parseMaybeAssign(r, i);
          return this.resetStartLocationFromNode(w, u), w;
        });
        (y = P.extra) != null && y.parenthesized && h();
        const v = this.maybeUnwrapTypeCastExpression(P);
        return v.type !== "ArrowFunctionExpression" && h(), v.typeParameters = u, this.resetStartLocationFromNode(v, u), P;
      }, n);
      let p = null;
      if (c.node && this.maybeUnwrapTypeCastExpression(c.node).type === "ArrowFunctionExpression") {
        if (!c.error && !c.aborted)
          return c.node.async && this.raise(Te.UnexpectedTypeParameterBeforeAsyncArrowFunction, {
            at: u
          }), c.node;
        p = c.node;
      }
      if ((o = a) != null && o.node)
        return this.state = a.failState, a.node;
      if (p)
        return this.state = c.failState, p;
      throw (l = a) != null && l.thrown ? a.error : c.thrown ? c.error : this.raise(Te.UnexpectedTokenAfterTypeParameter, {
        at: u
      });
    }
    return super.parseMaybeAssign(r, i);
  }
  parseArrow(r) {
    if (this.match(14)) {
      const i = this.tryParse(() => {
        const s = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = !0;
        const n = this.startNode();
        return [n.typeAnnotation, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = s, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), n;
      });
      if (i.thrown)
        return null;
      i.error && (this.state = i.failState), r.returnType = i.node.typeAnnotation ? this.finishNode(i.node, "TypeAnnotation") : null;
    }
    return super.parseArrow(r);
  }
  shouldParseArrow(r) {
    return this.match(14) || super.shouldParseArrow(r);
  }
  setArrowFunctionParameters(r, i) {
    this.state.noArrowParamsConversionAt.indexOf(r.start) !== -1 ? r.params = i : super.setArrowFunctionParameters(r, i);
  }
  checkParams(r, i, s, n = !0) {
    if (!(s && this.state.noArrowParamsConversionAt.indexOf(r.start) !== -1)) {
      for (let a = 0; a < r.params.length; a++)
        this.isThisParam(r.params[a]) && a > 0 && this.raise(Te.ThisParamMustBeFirst, {
          at: r.params[a]
        });
      super.checkParams(r, i, s, n);
    }
  }
  parseParenAndDistinguishExpression(r) {
    return super.parseParenAndDistinguishExpression(r && this.state.noArrowAt.indexOf(this.state.start) === -1);
  }
  parseSubscripts(r, i, s) {
    if (r.type === "Identifier" && r.name === "async" && this.state.noArrowAt.indexOf(i.index) !== -1) {
      this.next();
      const n = this.startNodeAt(i);
      n.callee = r, n.arguments = super.parseCallExpressionArguments(11, !1), r = this.finishNode(n, "CallExpression");
    } else if (r.type === "Identifier" && r.name === "async" && this.match(47)) {
      const n = this.state.clone(), a = this.tryParse((l) => this.parseAsyncArrowWithTypeParameters(i) || l(), n);
      if (!a.error && !a.aborted)
        return a.node;
      const o = this.tryParse(() => super.parseSubscripts(r, i, s), n);
      if (o.node && !o.error)
        return o.node;
      if (a.node)
        return this.state = a.failState, a.node;
      if (o.node)
        return this.state = o.failState, o.node;
      throw a.error || o.error;
    }
    return super.parseSubscripts(r, i, s);
  }
  parseSubscript(r, i, s, n) {
    if (this.match(18) && this.isLookaheadToken_lt()) {
      if (n.optionalChainMember = !0, s)
        return n.stop = !0, r;
      this.next();
      const a = this.startNodeAt(i);
      return a.callee = r, a.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), a.arguments = this.parseCallExpressionArguments(11, !1), a.optional = !0, this.finishCallExpression(a, !0);
    } else if (!s && this.shouldParseTypes() && this.match(47)) {
      const a = this.startNodeAt(i);
      a.callee = r;
      const o = this.tryParse(() => (a.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), a.arguments = super.parseCallExpressionArguments(11, !1), n.optionalChainMember && (a.optional = !1), this.finishCallExpression(a, n.optionalChainMember)));
      if (o.node)
        return o.error && (this.state = o.failState), o.node;
    }
    return super.parseSubscript(r, i, s, n);
  }
  parseNewCallee(r) {
    super.parseNewCallee(r);
    let i = null;
    this.shouldParseTypes() && this.match(47) && (i = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), r.typeArguments = i;
  }
  parseAsyncArrowWithTypeParameters(r) {
    const i = this.startNodeAt(r);
    if (this.parseFunctionParams(i, !1), !!this.parseArrow(i))
      return super.parseArrowExpression(i, void 0, !0);
  }
  readToken_mult_modulo(r) {
    const i = this.input.charCodeAt(this.state.pos + 1);
    if (r === 42 && i === 47 && this.state.hasFlowComment) {
      this.state.hasFlowComment = !1, this.state.pos += 2, this.nextToken();
      return;
    }
    super.readToken_mult_modulo(r);
  }
  readToken_pipe_amp(r) {
    const i = this.input.charCodeAt(this.state.pos + 1);
    if (r === 124 && i === 125) {
      this.finishOp(9, 2);
      return;
    }
    super.readToken_pipe_amp(r);
  }
  parseTopLevel(r, i) {
    const s = super.parseTopLevel(r, i);
    return this.state.hasFlowComment && this.raise(Te.UnterminatedFlowComment, {
      at: this.state.curPosition()
    }), s;
  }
  skipBlockComment() {
    if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
      if (this.state.hasFlowComment)
        throw this.raise(Te.NestedFlowComment, {
          at: this.state.startLoc
        });
      this.hasFlowCommentCompletion();
      const r = this.skipFlowComment();
      r && (this.state.pos += r, this.state.hasFlowComment = !0);
      return;
    }
    return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
  }
  skipFlowComment() {
    const {
      pos: r
    } = this.state;
    let i = 2;
    for (; [32, 9].includes(this.input.charCodeAt(r + i)); )
      i++;
    const s = this.input.charCodeAt(i + r), n = this.input.charCodeAt(i + r + 1);
    return s === 58 && n === 58 ? i + 2 : this.input.slice(i + r, i + r + 12) === "flow-include" ? i + 12 : s === 58 && n !== 58 ? i : !1;
  }
  hasFlowCommentCompletion() {
    if (this.input.indexOf("*/", this.state.pos) === -1)
      throw this.raise(N.UnterminatedComment, {
        at: this.state.curPosition()
      });
  }
  flowEnumErrorBooleanMemberNotInitialized(r, {
    enumName: i,
    memberName: s
  }) {
    this.raise(Te.EnumBooleanMemberNotInitialized, {
      at: r,
      memberName: s,
      enumName: i
    });
  }
  flowEnumErrorInvalidMemberInitializer(r, i) {
    return this.raise(i.explicitType ? i.explicitType === "symbol" ? Te.EnumInvalidMemberInitializerSymbolType : Te.EnumInvalidMemberInitializerPrimaryType : Te.EnumInvalidMemberInitializerUnknownType, Object.assign({
      at: r
    }, i));
  }
  flowEnumErrorNumberMemberNotInitialized(r, {
    enumName: i,
    memberName: s
  }) {
    this.raise(Te.EnumNumberMemberNotInitialized, {
      at: r,
      enumName: i,
      memberName: s
    });
  }
  flowEnumErrorStringMemberInconsistentlyInitailized(r, {
    enumName: i
  }) {
    this.raise(Te.EnumStringMemberInconsistentlyInitailized, {
      at: r,
      enumName: i
    });
  }
  flowEnumMemberInit() {
    const r = this.state.startLoc, i = () => this.match(12) || this.match(8);
    switch (this.state.type) {
      case 132: {
        const s = this.parseNumericLiteral(this.state.value);
        return i() ? {
          type: "number",
          loc: s.loc.start,
          value: s
        } : {
          type: "invalid",
          loc: r
        };
      }
      case 131: {
        const s = this.parseStringLiteral(this.state.value);
        return i() ? {
          type: "string",
          loc: s.loc.start,
          value: s
        } : {
          type: "invalid",
          loc: r
        };
      }
      case 85:
      case 86: {
        const s = this.parseBooleanLiteral(this.match(85));
        return i() ? {
          type: "boolean",
          loc: s.loc.start,
          value: s
        } : {
          type: "invalid",
          loc: r
        };
      }
      default:
        return {
          type: "invalid",
          loc: r
        };
    }
  }
  flowEnumMemberRaw() {
    const r = this.state.startLoc, i = this.parseIdentifier(!0), s = this.eat(29) ? this.flowEnumMemberInit() : {
      type: "none",
      loc: r
    };
    return {
      id: i,
      init: s
    };
  }
  flowEnumCheckExplicitTypeMismatch(r, i, s) {
    const {
      explicitType: n
    } = i;
    n !== null && n !== s && this.flowEnumErrorInvalidMemberInitializer(r, i);
  }
  flowEnumMembers({
    enumName: r,
    explicitType: i
  }) {
    const s = /* @__PURE__ */ new Set(), n = {
      booleanMembers: [],
      numberMembers: [],
      stringMembers: [],
      defaultedMembers: []
    };
    let a = !1;
    for (; !this.match(8); ) {
      if (this.eat(21)) {
        a = !0;
        break;
      }
      const o = this.startNode(), {
        id: l,
        init: u
      } = this.flowEnumMemberRaw(), c = l.name;
      if (c === "")
        continue;
      /^[a-z]/.test(c) && this.raise(Te.EnumInvalidMemberName, {
        at: l,
        memberName: c,
        suggestion: c[0].toUpperCase() + c.slice(1),
        enumName: r
      }), s.has(c) && this.raise(Te.EnumDuplicateMemberName, {
        at: l,
        memberName: c,
        enumName: r
      }), s.add(c);
      const p = {
        enumName: r,
        explicitType: i,
        memberName: c
      };
      switch (o.id = l, u.type) {
        case "boolean": {
          this.flowEnumCheckExplicitTypeMismatch(u.loc, p, "boolean"), o.init = u.value, n.booleanMembers.push(this.finishNode(o, "EnumBooleanMember"));
          break;
        }
        case "number": {
          this.flowEnumCheckExplicitTypeMismatch(u.loc, p, "number"), o.init = u.value, n.numberMembers.push(this.finishNode(o, "EnumNumberMember"));
          break;
        }
        case "string": {
          this.flowEnumCheckExplicitTypeMismatch(u.loc, p, "string"), o.init = u.value, n.stringMembers.push(this.finishNode(o, "EnumStringMember"));
          break;
        }
        case "invalid":
          throw this.flowEnumErrorInvalidMemberInitializer(u.loc, p);
        case "none":
          switch (i) {
            case "boolean":
              this.flowEnumErrorBooleanMemberNotInitialized(u.loc, p);
              break;
            case "number":
              this.flowEnumErrorNumberMemberNotInitialized(u.loc, p);
              break;
            default:
              n.defaultedMembers.push(this.finishNode(o, "EnumDefaultedMember"));
          }
      }
      this.match(8) || this.expect(12);
    }
    return {
      members: n,
      hasUnknownMembers: a
    };
  }
  flowEnumStringMembers(r, i, {
    enumName: s
  }) {
    if (r.length === 0)
      return i;
    if (i.length === 0)
      return r;
    if (i.length > r.length) {
      for (const n of r)
        this.flowEnumErrorStringMemberInconsistentlyInitailized(n, {
          enumName: s
        });
      return i;
    } else {
      for (const n of i)
        this.flowEnumErrorStringMemberInconsistentlyInitailized(n, {
          enumName: s
        });
      return r;
    }
  }
  flowEnumParseExplicitType({
    enumName: r
  }) {
    if (!this.eatContextual(101))
      return null;
    if (!ke(this.state.type))
      throw this.raise(Te.EnumInvalidExplicitTypeUnknownSupplied, {
        at: this.state.startLoc,
        enumName: r
      });
    const {
      value: i
    } = this.state;
    return this.next(), i !== "boolean" && i !== "number" && i !== "string" && i !== "symbol" && this.raise(Te.EnumInvalidExplicitType, {
      at: this.state.startLoc,
      enumName: r,
      invalidEnumType: i
    }), i;
  }
  flowEnumBody(r, i) {
    const s = i.name, n = i.loc.start, a = this.flowEnumParseExplicitType({
      enumName: s
    });
    this.expect(5);
    const {
      members: o,
      hasUnknownMembers: l
    } = this.flowEnumMembers({
      enumName: s,
      explicitType: a
    });
    switch (r.hasUnknownMembers = l, a) {
      case "boolean":
        return r.explicitType = !0, r.members = o.booleanMembers, this.expect(8), this.finishNode(r, "EnumBooleanBody");
      case "number":
        return r.explicitType = !0, r.members = o.numberMembers, this.expect(8), this.finishNode(r, "EnumNumberBody");
      case "string":
        return r.explicitType = !0, r.members = this.flowEnumStringMembers(o.stringMembers, o.defaultedMembers, {
          enumName: s
        }), this.expect(8), this.finishNode(r, "EnumStringBody");
      case "symbol":
        return r.members = o.defaultedMembers, this.expect(8), this.finishNode(r, "EnumSymbolBody");
      default: {
        const u = () => (r.members = [], this.expect(8), this.finishNode(r, "EnumStringBody"));
        r.explicitType = !1;
        const c = o.booleanMembers.length, p = o.numberMembers.length, h = o.stringMembers.length, y = o.defaultedMembers.length;
        if (!c && !p && !h && !y)
          return u();
        if (!c && !p)
          return r.members = this.flowEnumStringMembers(o.stringMembers, o.defaultedMembers, {
            enumName: s
          }), this.expect(8), this.finishNode(r, "EnumStringBody");
        if (!p && !h && c >= y) {
          for (const P of o.defaultedMembers)
            this.flowEnumErrorBooleanMemberNotInitialized(P.loc.start, {
              enumName: s,
              memberName: P.id.name
            });
          return r.members = o.booleanMembers, this.expect(8), this.finishNode(r, "EnumBooleanBody");
        } else if (!c && !h && p >= y) {
          for (const P of o.defaultedMembers)
            this.flowEnumErrorNumberMemberNotInitialized(P.loc.start, {
              enumName: s,
              memberName: P.id.name
            });
          return r.members = o.numberMembers, this.expect(8), this.finishNode(r, "EnumNumberBody");
        } else
          return this.raise(Te.EnumInconsistentMemberValues, {
            at: n,
            enumName: s
          }), u();
      }
    }
  }
  flowParseEnumDeclaration(r) {
    const i = this.parseIdentifier();
    return r.id = i, r.body = this.flowEnumBody(this.startNode(), i), this.finishNode(r, "EnumDeclaration");
  }
  isLookaheadToken_lt() {
    const r = this.nextTokenStart();
    if (this.input.charCodeAt(r) === 60) {
      const i = this.input.charCodeAt(r + 1);
      return i !== 60 && i !== 61;
    }
    return !1;
  }
  maybeUnwrapTypeCastExpression(r) {
    return r.type === "TypeCastExpression" ? r.expression : r;
  }
};
const eT = {
  __proto__: null,
  quot: '"',
  amp: "&",
  apos: "'",
  lt: "<",
  gt: ">",
  nbsp: " ",
  iexcl: "¡",
  cent: "¢",
  pound: "£",
  curren: "¤",
  yen: "¥",
  brvbar: "¦",
  sect: "§",
  uml: "¨",
  copy: "©",
  ordf: "ª",
  laquo: "«",
  not: "¬",
  shy: "­",
  reg: "®",
  macr: "¯",
  deg: "°",
  plusmn: "±",
  sup2: "²",
  sup3: "³",
  acute: "´",
  micro: "µ",
  para: "¶",
  middot: "·",
  cedil: "¸",
  sup1: "¹",
  ordm: "º",
  raquo: "»",
  frac14: "¼",
  frac12: "½",
  frac34: "¾",
  iquest: "¿",
  Agrave: "À",
  Aacute: "Á",
  Acirc: "Â",
  Atilde: "Ã",
  Auml: "Ä",
  Aring: "Å",
  AElig: "Æ",
  Ccedil: "Ç",
  Egrave: "È",
  Eacute: "É",
  Ecirc: "Ê",
  Euml: "Ë",
  Igrave: "Ì",
  Iacute: "Í",
  Icirc: "Î",
  Iuml: "Ï",
  ETH: "Ð",
  Ntilde: "Ñ",
  Ograve: "Ò",
  Oacute: "Ó",
  Ocirc: "Ô",
  Otilde: "Õ",
  Ouml: "Ö",
  times: "×",
  Oslash: "Ø",
  Ugrave: "Ù",
  Uacute: "Ú",
  Ucirc: "Û",
  Uuml: "Ü",
  Yacute: "Ý",
  THORN: "Þ",
  szlig: "ß",
  agrave: "à",
  aacute: "á",
  acirc: "â",
  atilde: "ã",
  auml: "ä",
  aring: "å",
  aelig: "æ",
  ccedil: "ç",
  egrave: "è",
  eacute: "é",
  ecirc: "ê",
  euml: "ë",
  igrave: "ì",
  iacute: "í",
  icirc: "î",
  iuml: "ï",
  eth: "ð",
  ntilde: "ñ",
  ograve: "ò",
  oacute: "ó",
  ocirc: "ô",
  otilde: "õ",
  ouml: "ö",
  divide: "÷",
  oslash: "ø",
  ugrave: "ù",
  uacute: "ú",
  ucirc: "û",
  uuml: "ü",
  yacute: "ý",
  thorn: "þ",
  yuml: "ÿ",
  OElig: "Œ",
  oelig: "œ",
  Scaron: "Š",
  scaron: "š",
  Yuml: "Ÿ",
  fnof: "ƒ",
  circ: "ˆ",
  tilde: "˜",
  Alpha: "Α",
  Beta: "Β",
  Gamma: "Γ",
  Delta: "Δ",
  Epsilon: "Ε",
  Zeta: "Ζ",
  Eta: "Η",
  Theta: "Θ",
  Iota: "Ι",
  Kappa: "Κ",
  Lambda: "Λ",
  Mu: "Μ",
  Nu: "Ν",
  Xi: "Ξ",
  Omicron: "Ο",
  Pi: "Π",
  Rho: "Ρ",
  Sigma: "Σ",
  Tau: "Τ",
  Upsilon: "Υ",
  Phi: "Φ",
  Chi: "Χ",
  Psi: "Ψ",
  Omega: "Ω",
  alpha: "α",
  beta: "β",
  gamma: "γ",
  delta: "δ",
  epsilon: "ε",
  zeta: "ζ",
  eta: "η",
  theta: "θ",
  iota: "ι",
  kappa: "κ",
  lambda: "λ",
  mu: "μ",
  nu: "ν",
  xi: "ξ",
  omicron: "ο",
  pi: "π",
  rho: "ρ",
  sigmaf: "ς",
  sigma: "σ",
  tau: "τ",
  upsilon: "υ",
  phi: "φ",
  chi: "χ",
  psi: "ψ",
  omega: "ω",
  thetasym: "ϑ",
  upsih: "ϒ",
  piv: "ϖ",
  ensp: " ",
  emsp: " ",
  thinsp: " ",
  zwnj: "‌",
  zwj: "‍",
  lrm: "‎",
  rlm: "‏",
  ndash: "–",
  mdash: "—",
  lsquo: "‘",
  rsquo: "’",
  sbquo: "‚",
  ldquo: "“",
  rdquo: "”",
  bdquo: "„",
  dagger: "†",
  Dagger: "‡",
  bull: "•",
  hellip: "…",
  permil: "‰",
  prime: "′",
  Prime: "″",
  lsaquo: "‹",
  rsaquo: "›",
  oline: "‾",
  frasl: "⁄",
  euro: "€",
  image: "ℑ",
  weierp: "℘",
  real: "ℜ",
  trade: "™",
  alefsym: "ℵ",
  larr: "←",
  uarr: "↑",
  rarr: "→",
  darr: "↓",
  harr: "↔",
  crarr: "↵",
  lArr: "⇐",
  uArr: "⇑",
  rArr: "⇒",
  dArr: "⇓",
  hArr: "⇔",
  forall: "∀",
  part: "∂",
  exist: "∃",
  empty: "∅",
  nabla: "∇",
  isin: "∈",
  notin: "∉",
  ni: "∋",
  prod: "∏",
  sum: "∑",
  minus: "−",
  lowast: "∗",
  radic: "√",
  prop: "∝",
  infin: "∞",
  ang: "∠",
  and: "∧",
  or: "∨",
  cap: "∩",
  cup: "∪",
  int: "∫",
  there4: "∴",
  sim: "∼",
  cong: "≅",
  asymp: "≈",
  ne: "≠",
  equiv: "≡",
  le: "≤",
  ge: "≥",
  sub: "⊂",
  sup: "⊃",
  nsub: "⊄",
  sube: "⊆",
  supe: "⊇",
  oplus: "⊕",
  otimes: "⊗",
  perp: "⊥",
  sdot: "⋅",
  lceil: "⌈",
  rceil: "⌉",
  lfloor: "⌊",
  rfloor: "⌋",
  lang: "〈",
  rang: "〉",
  loz: "◊",
  spades: "♠",
  clubs: "♣",
  hearts: "♥",
  diams: "♦"
}, rr = Lt`jsx`({
  AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
  MissingClosingTagElement: ({
    openingTagName: e
  }) => `Expected corresponding JSX closing tag for <${e}>.`,
  MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
  UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
  UnexpectedToken: ({
    unexpected: e,
    HTMLEntity: t
  }) => `Unexpected token \`${e}\`. Did you mean \`${t}\` or \`{'${e}'}\`?`,
  UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
  UnterminatedJsxContent: "Unterminated JSX contents.",
  UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
});
function Vt(e) {
  return e ? e.type === "JSXOpeningFragment" || e.type === "JSXClosingFragment" : !1;
}
function wr(e) {
  if (e.type === "JSXIdentifier")
    return e.name;
  if (e.type === "JSXNamespacedName")
    return e.namespace.name + ":" + e.name.name;
  if (e.type === "JSXMemberExpression")
    return wr(e.object) + "." + wr(e.property);
  throw new Error("Node had unexpected type: " + e.type);
}
var tT = (e) => class extends e {
  jsxReadToken() {
    let r = "", i = this.state.pos;
    for (; ; ) {
      if (this.state.pos >= this.length)
        throw this.raise(rr.UnterminatedJsxContent, {
          at: this.state.startLoc
        });
      const s = this.input.charCodeAt(this.state.pos);
      switch (s) {
        case 60:
        case 123:
          if (this.state.pos === this.state.start) {
            s === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(140)) : super.getTokenFromCode(s);
            return;
          }
          r += this.input.slice(i, this.state.pos), this.finishToken(139, r);
          return;
        case 38:
          r += this.input.slice(i, this.state.pos), r += this.jsxReadEntity(), i = this.state.pos;
          break;
        case 62:
        case 125:
        default:
          ii(s) ? (r += this.input.slice(i, this.state.pos), r += this.jsxReadNewLine(!0), i = this.state.pos) : ++this.state.pos;
      }
    }
  }
  jsxReadNewLine(r) {
    const i = this.input.charCodeAt(this.state.pos);
    let s;
    return ++this.state.pos, i === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, s = r ? `
` : `\r
`) : s = String.fromCharCode(i), ++this.state.curLine, this.state.lineStart = this.state.pos, s;
  }
  jsxReadString(r) {
    let i = "", s = ++this.state.pos;
    for (; ; ) {
      if (this.state.pos >= this.length)
        throw this.raise(N.UnterminatedString, {
          at: this.state.startLoc
        });
      const n = this.input.charCodeAt(this.state.pos);
      if (n === r)
        break;
      n === 38 ? (i += this.input.slice(s, this.state.pos), i += this.jsxReadEntity(), s = this.state.pos) : ii(n) ? (i += this.input.slice(s, this.state.pos), i += this.jsxReadNewLine(!1), s = this.state.pos) : ++this.state.pos;
    }
    i += this.input.slice(s, this.state.pos++), this.finishToken(131, i);
  }
  jsxReadEntity() {
    const r = ++this.state.pos;
    if (this.codePointAtPos(this.state.pos) === 35) {
      ++this.state.pos;
      let i = 10;
      this.codePointAtPos(this.state.pos) === 120 && (i = 16, ++this.state.pos);
      const s = this.readInt(i, void 0, !1, "bail");
      if (s !== null && this.codePointAtPos(this.state.pos) === 59)
        return ++this.state.pos, String.fromCodePoint(s);
    } else {
      let i = 0, s = !1;
      for (; i++ < 10 && this.state.pos < this.length && !(s = this.codePointAtPos(this.state.pos) == 59); )
        ++this.state.pos;
      if (s) {
        const n = this.input.slice(r, this.state.pos), a = eT[n];
        if (++this.state.pos, a)
          return a;
      }
    }
    return this.state.pos = r, "&";
  }
  jsxReadWord() {
    let r;
    const i = this.state.pos;
    do
      r = this.input.charCodeAt(++this.state.pos);
    while (Nr(r) || r === 45);
    this.finishToken(138, this.input.slice(i, this.state.pos));
  }
  jsxParseIdentifier() {
    const r = this.startNode();
    return this.match(138) ? r.name = this.state.value : na(this.state.type) ? r.name = Ht(this.state.type) : this.unexpected(), this.next(), this.finishNode(r, "JSXIdentifier");
  }
  jsxParseNamespacedName() {
    const r = this.state.startLoc, i = this.jsxParseIdentifier();
    if (!this.eat(14))
      return i;
    const s = this.startNodeAt(r);
    return s.namespace = i, s.name = this.jsxParseIdentifier(), this.finishNode(s, "JSXNamespacedName");
  }
  jsxParseElementName() {
    const r = this.state.startLoc;
    let i = this.jsxParseNamespacedName();
    if (i.type === "JSXNamespacedName")
      return i;
    for (; this.eat(16); ) {
      const s = this.startNodeAt(r);
      s.object = i, s.property = this.jsxParseIdentifier(), i = this.finishNode(s, "JSXMemberExpression");
    }
    return i;
  }
  jsxParseAttributeValue() {
    let r;
    switch (this.state.type) {
      case 5:
        return r = this.startNode(), this.setContext(Be.brace), this.next(), r = this.jsxParseExpressionContainer(r, Be.j_oTag), r.expression.type === "JSXEmptyExpression" && this.raise(rr.AttributeIsEmpty, {
          at: r
        }), r;
      case 140:
      case 131:
        return this.parseExprAtom();
      default:
        throw this.raise(rr.UnsupportedJsxValue, {
          at: this.state.startLoc
        });
    }
  }
  jsxParseEmptyExpression() {
    const r = this.startNodeAt(this.state.lastTokEndLoc);
    return this.finishNodeAt(r, "JSXEmptyExpression", this.state.startLoc);
  }
  jsxParseSpreadChild(r) {
    return this.next(), r.expression = this.parseExpression(), this.setContext(Be.j_expr), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXSpreadChild");
  }
  jsxParseExpressionContainer(r, i) {
    if (this.match(8))
      r.expression = this.jsxParseEmptyExpression();
    else {
      const s = this.parseExpression();
      r.expression = s;
    }
    return this.setContext(i), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXExpressionContainer");
  }
  jsxParseAttribute() {
    const r = this.startNode();
    return this.match(5) ? (this.setContext(Be.brace), this.next(), this.expect(21), r.argument = this.parseMaybeAssignAllowIn(), this.setContext(Be.j_oTag), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXSpreadAttribute")) : (r.name = this.jsxParseNamespacedName(), r.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(r, "JSXAttribute"));
  }
  jsxParseOpeningElementAt(r) {
    const i = this.startNodeAt(r);
    return this.eat(141) ? this.finishNode(i, "JSXOpeningFragment") : (i.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(i));
  }
  jsxParseOpeningElementAfterName(r) {
    const i = [];
    for (; !this.match(56) && !this.match(141); )
      i.push(this.jsxParseAttribute());
    return r.attributes = i, r.selfClosing = this.eat(56), this.expect(141), this.finishNode(r, "JSXOpeningElement");
  }
  jsxParseClosingElementAt(r) {
    const i = this.startNodeAt(r);
    return this.eat(141) ? this.finishNode(i, "JSXClosingFragment") : (i.name = this.jsxParseElementName(), this.expect(141), this.finishNode(i, "JSXClosingElement"));
  }
  jsxParseElementAt(r) {
    const i = this.startNodeAt(r), s = [], n = this.jsxParseOpeningElementAt(r);
    let a = null;
    if (!n.selfClosing) {
      e:
        for (; ; )
          switch (this.state.type) {
            case 140:
              if (r = this.state.startLoc, this.next(), this.eat(56)) {
                a = this.jsxParseClosingElementAt(r);
                break e;
              }
              s.push(this.jsxParseElementAt(r));
              break;
            case 139:
              s.push(this.parseExprAtom());
              break;
            case 5: {
              const o = this.startNode();
              this.setContext(Be.brace), this.next(), this.match(21) ? s.push(this.jsxParseSpreadChild(o)) : s.push(this.jsxParseExpressionContainer(o, Be.j_expr));
              break;
            }
            default:
              this.unexpected();
          }
      Vt(n) && !Vt(a) && a !== null ? this.raise(rr.MissingClosingTagFragment, {
        at: a
      }) : !Vt(n) && Vt(a) ? this.raise(rr.MissingClosingTagElement, {
        at: a,
        openingTagName: wr(n.name)
      }) : !Vt(n) && !Vt(a) && wr(a.name) !== wr(n.name) && this.raise(rr.MissingClosingTagElement, {
        at: a,
        openingTagName: wr(n.name)
      });
    }
    if (Vt(n) ? (i.openingFragment = n, i.closingFragment = a) : (i.openingElement = n, i.closingElement = a), i.children = s, this.match(47))
      throw this.raise(rr.UnwrappedAdjacentJSXElements, {
        at: this.state.startLoc
      });
    return Vt(n) ? this.finishNode(i, "JSXFragment") : this.finishNode(i, "JSXElement");
  }
  jsxParseElement() {
    const r = this.state.startLoc;
    return this.next(), this.jsxParseElementAt(r);
  }
  setContext(r) {
    const {
      context: i
    } = this.state;
    i[i.length - 1] = r;
  }
  parseExprAtom(r) {
    return this.match(139) ? this.parseLiteral(this.state.value, "JSXText") : this.match(140) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(140), this.jsxParseElement()) : super.parseExprAtom(r);
  }
  skipSpace() {
    this.curContext().preserveSpace || super.skipSpace();
  }
  getTokenFromCode(r) {
    const i = this.curContext();
    if (i === Be.j_expr) {
      this.jsxReadToken();
      return;
    }
    if (i === Be.j_oTag || i === Be.j_cTag) {
      if (Dt(r)) {
        this.jsxReadWord();
        return;
      }
      if (r === 62) {
        ++this.state.pos, this.finishToken(141);
        return;
      }
      if ((r === 34 || r === 39) && i === Be.j_oTag) {
        this.jsxReadString(r);
        return;
      }
    }
    if (r === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
      ++this.state.pos, this.finishToken(140);
      return;
    }
    super.getTokenFromCode(r);
  }
  updateContext(r) {
    const {
      context: i,
      type: s
    } = this.state;
    if (s === 56 && r === 140)
      i.splice(-2, 2, Be.j_cTag), this.state.canStartJSXElement = !1;
    else if (s === 140)
      i.push(Be.j_oTag);
    else if (s === 141) {
      const n = i[i.length - 1];
      n === Be.j_oTag && r === 56 || n === Be.j_cTag ? (i.pop(), this.state.canStartJSXElement = i[i.length - 1] === Be.j_expr) : (this.setContext(Be.j_expr), this.state.canStartJSXElement = !0);
    } else
      this.state.canStartJSXElement = Xm(s);
  }
};
class rT extends pa {
  constructor(...t) {
    super(...t), this.types = /* @__PURE__ */ new Set(), this.enums = /* @__PURE__ */ new Set(), this.constEnums = /* @__PURE__ */ new Set(), this.classes = /* @__PURE__ */ new Set(), this.exportOnlyBindings = /* @__PURE__ */ new Set();
  }
}
class iT extends ha {
  constructor(...t) {
    super(...t), this.importsStack = [];
  }
  createScope(t) {
    return this.importsStack.push(/* @__PURE__ */ new Set()), new rT(t);
  }
  enter(t) {
    t == _r && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(t);
  }
  exit() {
    const t = super.exit();
    return t == _r && this.importsStack.pop(), t;
  }
  hasImport(t, r) {
    const i = this.importsStack.length;
    if (this.importsStack[i - 1].has(t))
      return !0;
    if (!r && i > 1) {
      for (let s = 0; s < i - 1; s++)
        if (this.importsStack[s].has(t))
          return !0;
    }
    return !1;
  }
  declareName(t, r, i) {
    if (r & ri) {
      this.hasImport(t, !0) && this.parser.raise(N.VarRedeclaration, {
        at: i,
        identifierName: t
      }), this.importsStack[this.importsStack.length - 1].add(t);
      return;
    }
    const s = this.currentScope();
    if (r & ua) {
      this.maybeExportDefined(s, t), s.exportOnlyBindings.add(t);
      return;
    }
    super.declareName(t, r, i), r & fr && (r & vt || (this.checkRedeclarationInScope(s, t, r, i), this.maybeExportDefined(s, t)), s.types.add(t)), r & kn && s.enums.add(t), r & Ln && s.constEnums.add(t), r & fs && s.classes.add(t);
  }
  isRedeclaredInScope(t, r, i) {
    if (t.enums.has(r)) {
      if (i & kn) {
        const s = !!(i & Ln), n = t.constEnums.has(r);
        return s !== n;
      }
      return !0;
    }
    return i & fs && t.classes.has(r) ? t.lexical.has(r) ? !!(i & vt) : !1 : i & fr && t.types.has(r) ? !0 : super.isRedeclaredInScope(t, r, i);
  }
  checkLocalExport(t) {
    const {
      name: r
    } = t;
    if (this.hasImport(r))
      return;
    const i = this.scopeStack.length;
    for (let s = i - 1; s >= 0; s--) {
      const n = this.scopeStack[s];
      if (n.types.has(r) || n.exportOnlyBindings.has(r))
        return;
    }
    super.checkLocalExport(t);
  }
}
const sT = (e, t) => Object.hasOwnProperty.call(e, t) && e[t], lc = (e) => e.type === "ParenthesizedExpression" ? lc(e.expression) : e;
class nT extends Xy {
  toAssignable(t, r = !1) {
    var i, s;
    let n;
    switch ((t.type === "ParenthesizedExpression" || (i = t.extra) != null && i.parenthesized) && (n = lc(t), r ? n.type === "Identifier" ? this.expressionScope.recordArrowParameterBindingError(N.InvalidParenthesizedAssignment, {
      at: t
    }) : n.type !== "MemberExpression" && this.raise(N.InvalidParenthesizedAssignment, {
      at: t
    }) : this.raise(N.InvalidParenthesizedAssignment, {
      at: t
    })), t.type) {
      case "Identifier":
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        t.type = "ObjectPattern";
        for (let o = 0, l = t.properties.length, u = l - 1; o < l; o++) {
          var a;
          const c = t.properties[o], p = o === u;
          this.toAssignableObjectExpressionProp(c, p, r), p && c.type === "RestElement" && (a = t.extra) != null && a.trailingCommaLoc && this.raise(N.RestTrailingComma, {
            at: t.extra.trailingCommaLoc
          });
        }
        break;
      case "ObjectProperty": {
        const {
          key: o,
          value: l
        } = t;
        this.isPrivateName(o) && this.classScope.usePrivateName(this.getPrivateNameSV(o), o.loc.start), this.toAssignable(l, r);
        break;
      }
      case "SpreadElement":
        throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
      case "ArrayExpression":
        t.type = "ArrayPattern", this.toAssignableList(t.elements, (s = t.extra) == null ? void 0 : s.trailingCommaLoc, r);
        break;
      case "AssignmentExpression":
        t.operator !== "=" && this.raise(N.MissingEqInAssignment, {
          at: t.left.loc.end
        }), t.type = "AssignmentPattern", delete t.operator, this.toAssignable(t.left, r);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(n, r);
        break;
    }
  }
  toAssignableObjectExpressionProp(t, r, i) {
    if (t.type === "ObjectMethod")
      this.raise(t.kind === "get" || t.kind === "set" ? N.PatternHasAccessor : N.PatternHasMethod, {
        at: t.key
      });
    else if (t.type === "SpreadElement") {
      t.type = "RestElement";
      const s = t.argument;
      this.checkToRestConversion(s, !1), this.toAssignable(s, i), r || this.raise(N.RestTrailingComma, {
        at: t
      });
    } else
      this.toAssignable(t, i);
  }
  toAssignableList(t, r, i) {
    const s = t.length - 1;
    for (let n = 0; n <= s; n++) {
      const a = t[n];
      if (a) {
        if (a.type === "SpreadElement") {
          a.type = "RestElement";
          const o = a.argument;
          this.checkToRestConversion(o, !0), this.toAssignable(o, i);
        } else
          this.toAssignable(a, i);
        a.type === "RestElement" && (n < s ? this.raise(N.RestTrailingComma, {
          at: a
        }) : r && this.raise(N.RestTrailingComma, {
          at: r
        }));
      }
    }
  }
  isAssignable(t, r) {
    switch (t.type) {
      case "Identifier":
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        return !0;
      case "ObjectExpression": {
        const i = t.properties.length - 1;
        return t.properties.every((s, n) => s.type !== "ObjectMethod" && (n === i || s.type !== "SpreadElement") && this.isAssignable(s));
      }
      case "ObjectProperty":
        return this.isAssignable(t.value);
      case "SpreadElement":
        return this.isAssignable(t.argument);
      case "ArrayExpression":
        return t.elements.every((i) => i === null || this.isAssignable(i));
      case "AssignmentExpression":
        return t.operator === "=";
      case "ParenthesizedExpression":
        return this.isAssignable(t.expression);
      case "MemberExpression":
      case "OptionalMemberExpression":
        return !r;
      default:
        return !1;
    }
  }
  toReferencedList(t, r) {
    return t;
  }
  toReferencedListDeep(t, r) {
    this.toReferencedList(t, r);
    for (const i of t)
      (i == null ? void 0 : i.type) === "ArrayExpression" && this.toReferencedListDeep(i.elements);
  }
  parseSpread(t) {
    const r = this.startNode();
    return this.next(), r.argument = this.parseMaybeAssignAllowIn(t, void 0), this.finishNode(r, "SpreadElement");
  }
  parseRestBinding() {
    const t = this.startNode();
    return this.next(), t.argument = this.parseBindingAtom(), this.finishNode(t, "RestElement");
  }
  parseBindingAtom() {
    switch (this.state.type) {
      case 0: {
        const t = this.startNode();
        return this.next(), t.elements = this.parseBindingList(3, 93, 1), this.finishNode(t, "ArrayPattern");
      }
      case 5:
        return this.parseObjectLike(8, !0);
    }
    return this.parseIdentifier();
  }
  parseBindingList(t, r, i) {
    const s = i & 1, n = [];
    let a = !0;
    for (; !this.eat(t); )
      if (a ? a = !1 : this.expect(12), s && this.match(12))
        n.push(null);
      else {
        if (this.eat(t))
          break;
        if (this.match(21)) {
          if (n.push(this.parseAssignableListItemTypes(this.parseRestBinding(), i)), !this.checkCommaAfterRest(r)) {
            this.expect(t);
            break;
          }
        } else {
          const o = [];
          for (this.match(26) && this.hasPlugin("decorators") && this.raise(N.UnsupportedParameterDecorator, {
            at: this.state.startLoc
          }); this.match(26); )
            o.push(this.parseDecorator());
          n.push(this.parseAssignableListItem(i, o));
        }
      }
    return n;
  }
  parseBindingRestProperty(t) {
    return this.next(), t.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(t, "RestElement");
  }
  parseBindingProperty() {
    const t = this.startNode(), {
      type: r,
      startLoc: i
    } = this.state;
    return r === 21 ? this.parseBindingRestProperty(t) : (r === 136 ? (this.expectPlugin("destructuringPrivate", i), this.classScope.usePrivateName(this.state.value, i), t.key = this.parsePrivateName()) : this.parsePropertyName(t), t.method = !1, this.parseObjPropValue(t, i, !1, !1, !0, !1));
  }
  parseAssignableListItem(t, r) {
    const i = this.parseMaybeDefault();
    this.parseAssignableListItemTypes(i, t);
    const s = this.parseMaybeDefault(i.loc.start, i);
    return r.length && (i.decorators = r), s;
  }
  parseAssignableListItemTypes(t, r) {
    return t;
  }
  parseMaybeDefault(t, r) {
    var i, s;
    if ((i = t) != null || (t = this.state.startLoc), r = (s = r) != null ? s : this.parseBindingAtom(), !this.eat(29))
      return r;
    const n = this.startNodeAt(t);
    return n.left = r, n.right = this.parseMaybeAssignAllowIn(), this.finishNode(n, "AssignmentPattern");
  }
  isValidLVal(t, r, i) {
    return sT({
      AssignmentPattern: "left",
      RestElement: "argument",
      ObjectProperty: "value",
      ParenthesizedExpression: "expression",
      ArrayPattern: "elements",
      ObjectPattern: "properties"
    }, t);
  }
  checkLVal(t, {
    in: r,
    binding: i = Yt,
    checkClashes: s = !1,
    strictModeChanged: n = !1,
    hasParenthesizedAncestor: a = !1
  }) {
    var o;
    const l = t.type;
    if (this.isObjectMethod(t))
      return;
    if (l === "MemberExpression") {
      i !== Yt && this.raise(N.InvalidPropertyBindingPattern, {
        at: t
      });
      return;
    }
    if (l === "Identifier") {
      this.checkIdentifier(t, i, n);
      const {
        name: y
      } = t;
      s && (s.has(y) ? this.raise(N.ParamDupe, {
        at: t
      }) : s.add(y));
      return;
    }
    const u = this.isValidLVal(l, !(a || (o = t.extra) != null && o.parenthesized) && r.type === "AssignmentExpression", i);
    if (u === !0)
      return;
    if (u === !1) {
      const y = i === Yt ? N.InvalidLhs : N.InvalidLhsBinding;
      this.raise(y, {
        at: t,
        ancestor: r
      });
      return;
    }
    const [c, p] = Array.isArray(u) ? u : [u, l === "ParenthesizedExpression"], h = l === "ArrayPattern" || l === "ObjectPattern" || l === "ParenthesizedExpression" ? {
      type: l
    } : r;
    for (const y of [].concat(t[c]))
      y && this.checkLVal(y, {
        in: h,
        binding: i,
        checkClashes: s,
        strictModeChanged: n,
        hasParenthesizedAncestor: p
      });
  }
  checkIdentifier(t, r, i = !1) {
    this.state.strict && (i ? qu(t.name, this.inModule) : Ku(t.name)) && (r === Yt ? this.raise(N.StrictEvalArguments, {
      at: t,
      referenceName: t.name
    }) : this.raise(N.StrictEvalArgumentsBinding, {
      at: t,
      bindingName: t.name
    })), r & Ss && t.name === "let" && this.raise(N.LetInLexicalBinding, {
      at: t
    }), r & Yt || this.declareNameFromIdentifier(t, r);
  }
  declareNameFromIdentifier(t, r) {
    this.scope.declareName(t.name, r, t.loc.start);
  }
  checkToRestConversion(t, r) {
    switch (t.type) {
      case "ParenthesizedExpression":
        this.checkToRestConversion(t.expression, r);
        break;
      case "Identifier":
      case "MemberExpression":
        break;
      case "ArrayExpression":
      case "ObjectExpression":
        if (r)
          break;
      default:
        this.raise(N.InvalidRestAssignmentPattern, {
          at: t
        });
    }
  }
  checkCommaAfterRest(t) {
    return this.match(12) ? (this.raise(this.lookaheadCharCode() === t ? N.RestTrailingComma : N.ElementAfterRest, {
      at: this.state.startLoc
    }), !0) : !1;
  }
}
const aT = (e, t) => Object.hasOwnProperty.call(e, t) && e[t];
function oT(e) {
  if (e == null)
    throw new Error(`Unexpected ${e} value.`);
  return e;
}
function wo(e) {
  if (!e)
    throw new Error("Assert fail");
}
const le = Lt`typescript`({
  AbstractMethodHasImplementation: ({
    methodName: e
  }) => `Method '${e}' cannot have an implementation because it is marked abstract.`,
  AbstractPropertyHasInitializer: ({
    propertyName: e
  }) => `Property '${e}' cannot have an initializer because it is marked abstract.`,
  AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
  AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
  AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
  ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
  ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
  ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
  ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
  DeclareAccessor: ({
    kind: e
  }) => `'declare' is not allowed in ${e}ters.`,
  DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
  DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
  DuplicateAccessibilityModifier: ({
    modifier: e
  }) => "Accessibility modifier already seen.",
  DuplicateModifier: ({
    modifier: e
  }) => `Duplicate modifier: '${e}'.`,
  EmptyHeritageClauseType: ({
    token: e
  }) => `'${e}' list cannot be empty.`,
  EmptyTypeArguments: "Type argument list cannot be empty.",
  EmptyTypeParameters: "Type parameter list cannot be empty.",
  ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
  ImportAliasHasImportType: "An import alias can not use 'import type'.",
  ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
  IncompatibleModifiers: ({
    modifiers: e
  }) => `'${e[0]}' modifier cannot be used with '${e[1]}' modifier.`,
  IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
  IndexSignatureHasAccessibility: ({
    modifier: e
  }) => `Index signatures cannot have an accessibility modifier ('${e}').`,
  IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
  IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
  IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
  InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
  InvalidModifierOnTypeMember: ({
    modifier: e
  }) => `'${e}' modifier cannot appear on a type member.`,
  InvalidModifierOnTypeParameter: ({
    modifier: e
  }) => `'${e}' modifier cannot appear on a type parameter.`,
  InvalidModifierOnTypeParameterPositions: ({
    modifier: e
  }) => `'${e}' modifier can only appear on a type parameter of a class, interface or type alias.`,
  InvalidModifiersOrder: ({
    orderedModifiers: e
  }) => `'${e[0]}' modifier must precede '${e[1]}' modifier.`,
  InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
  InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
  MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
  MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.",
  NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
  NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
  OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
  OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
  PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
  PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
  PrivateElementHasAccessibility: ({
    modifier: e
  }) => `Private elements cannot have an accessibility modifier ('${e}').`,
  ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
  ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
  ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
  SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
  SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
  SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
  SingleTypeParameterWithoutTrailingComma: ({
    typeParameterName: e
  }) => `Single type parameter ${e} should have a trailing comma. Example usage: <${e},>.`,
  StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
  TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",
  TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
  TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
  TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
  TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
  UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
  UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
  UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
  UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
  UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
  UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
  UnsupportedSignatureParameterKind: ({
    type: e
  }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${e}.`
});
function lT(e) {
  switch (e) {
    case "any":
      return "TSAnyKeyword";
    case "boolean":
      return "TSBooleanKeyword";
    case "bigint":
      return "TSBigIntKeyword";
    case "never":
      return "TSNeverKeyword";
    case "number":
      return "TSNumberKeyword";
    case "object":
      return "TSObjectKeyword";
    case "string":
      return "TSStringKeyword";
    case "symbol":
      return "TSSymbolKeyword";
    case "undefined":
      return "TSUndefinedKeyword";
    case "unknown":
      return "TSUnknownKeyword";
    default:
      return;
  }
}
function Oo(e) {
  return e === "private" || e === "public" || e === "protected";
}
function uT(e) {
  return e === "in" || e === "out";
}
var cT = (e) => class extends e {
  constructor(...r) {
    super(...r), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
      allowedModifiers: ["in", "out"],
      disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
      errorTemplate: le.InvalidModifierOnTypeParameter
    }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
      allowedModifiers: ["const"],
      disallowedModifiers: ["in", "out"],
      errorTemplate: le.InvalidModifierOnTypeParameterPositions
    }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
      allowedModifiers: ["in", "out", "const"],
      disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
      errorTemplate: le.InvalidModifierOnTypeParameter
    });
  }
  getScopeHandler() {
    return iT;
  }
  tsIsIdentifier() {
    return ke(this.state.type);
  }
  tsTokenCanFollowModifier() {
    return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(136) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
  }
  tsNextTokenCanFollowModifier() {
    return this.next(), this.tsTokenCanFollowModifier();
  }
  tsParseModifier(r, i) {
    if (!ke(this.state.type) && this.state.type !== 58 && this.state.type !== 75)
      return;
    const s = this.state.value;
    if (r.indexOf(s) !== -1) {
      if (i && this.tsIsStartOfStaticBlocks())
        return;
      if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
        return s;
    }
  }
  tsParseModifiers({
    allowedModifiers: r,
    disallowedModifiers: i,
    stopOnStartOfClassStaticBlock: s,
    errorTemplate: n = le.InvalidModifierOnTypeMember
  }, a) {
    const o = (u, c, p, h) => {
      c === p && a[h] && this.raise(le.InvalidModifiersOrder, {
        at: u,
        orderedModifiers: [p, h]
      });
    }, l = (u, c, p, h) => {
      (a[p] && c === h || a[h] && c === p) && this.raise(le.IncompatibleModifiers, {
        at: u,
        modifiers: [p, h]
      });
    };
    for (; ; ) {
      const {
        startLoc: u
      } = this.state, c = this.tsParseModifier(r.concat(i ?? []), s);
      if (!c)
        break;
      Oo(c) ? a.accessibility ? this.raise(le.DuplicateAccessibilityModifier, {
        at: u,
        modifier: c
      }) : (o(u, c, c, "override"), o(u, c, c, "static"), o(u, c, c, "readonly"), a.accessibility = c) : uT(c) ? (a[c] && this.raise(le.DuplicateModifier, {
        at: u,
        modifier: c
      }), a[c] = !0, o(u, c, "in", "out")) : (Object.hasOwnProperty.call(a, c) ? this.raise(le.DuplicateModifier, {
        at: u,
        modifier: c
      }) : (o(u, c, "static", "readonly"), o(u, c, "static", "override"), o(u, c, "override", "readonly"), o(u, c, "abstract", "override"), l(u, c, "declare", "override"), l(u, c, "static", "abstract")), a[c] = !0), i != null && i.includes(c) && this.raise(n, {
        at: u,
        modifier: c
      });
    }
  }
  tsIsListTerminator(r) {
    switch (r) {
      case "EnumMembers":
      case "TypeMembers":
        return this.match(8);
      case "HeritageClauseElement":
        return this.match(5);
      case "TupleElementTypes":
        return this.match(3);
      case "TypeParametersOrArguments":
        return this.match(48);
    }
  }
  tsParseList(r, i) {
    const s = [];
    for (; !this.tsIsListTerminator(r); )
      s.push(i());
    return s;
  }
  tsParseDelimitedList(r, i, s) {
    return oT(this.tsParseDelimitedListWorker(r, i, !0, s));
  }
  tsParseDelimitedListWorker(r, i, s, n) {
    const a = [];
    let o = -1;
    for (; !this.tsIsListTerminator(r); ) {
      o = -1;
      const l = i();
      if (l == null)
        return;
      if (a.push(l), this.eat(12)) {
        o = this.state.lastTokStart;
        continue;
      }
      if (this.tsIsListTerminator(r))
        break;
      s && this.expect(12);
      return;
    }
    return n && (n.value = o), a;
  }
  tsParseBracketedList(r, i, s, n, a) {
    n || (s ? this.expect(0) : this.expect(47));
    const o = this.tsParseDelimitedList(r, i, a);
    return s ? this.expect(3) : this.expect(48), o;
  }
  tsParseImportType() {
    const r = this.startNode();
    return this.expect(83), this.expect(10), this.match(131) || this.raise(le.UnsupportedImportTypeArgument, {
      at: this.state.startLoc
    }), r.argument = super.parseExprAtom(), this.expect(11), this.eat(16) && (r.qualifier = this.tsParseEntityName()), this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(r, "TSImportType");
  }
  tsParseEntityName(r = !0) {
    let i = this.parseIdentifier(r);
    for (; this.eat(16); ) {
      const s = this.startNodeAtNode(i);
      s.left = i, s.right = this.parseIdentifier(r), i = this.finishNode(s, "TSQualifiedName");
    }
    return i;
  }
  tsParseTypeReference() {
    const r = this.startNode();
    return r.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(r, "TSTypeReference");
  }
  tsParseThisTypePredicate(r) {
    this.next();
    const i = this.startNodeAtNode(r);
    return i.parameterName = r, i.typeAnnotation = this.tsParseTypeAnnotation(!1), i.asserts = !1, this.finishNode(i, "TSTypePredicate");
  }
  tsParseThisTypeNode() {
    const r = this.startNode();
    return this.next(), this.finishNode(r, "TSThisType");
  }
  tsParseTypeQuery() {
    const r = this.startNode();
    return this.expect(87), this.match(83) ? r.exprName = this.tsParseImportType() : r.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(r, "TSTypeQuery");
  }
  tsParseTypeParameter(r) {
    const i = this.startNode();
    return r(i), i.name = this.tsParseTypeParameterName(), i.constraint = this.tsEatThenParseType(81), i.default = this.tsEatThenParseType(29), this.finishNode(i, "TSTypeParameter");
  }
  tsTryParseTypeParameters(r) {
    if (this.match(47))
      return this.tsParseTypeParameters(r);
  }
  tsParseTypeParameters(r) {
    const i = this.startNode();
    this.match(47) || this.match(140) ? this.next() : this.unexpected();
    const s = {
      value: -1
    };
    return i.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, r), !1, !0, s), i.params.length === 0 && this.raise(le.EmptyTypeParameters, {
      at: i
    }), s.value !== -1 && this.addExtra(i, "trailingComma", s.value), this.finishNode(i, "TSTypeParameterDeclaration");
  }
  tsFillSignature(r, i) {
    const s = r === 19, n = "parameters", a = "typeAnnotation";
    i.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), i[n] = this.tsParseBindingListForSignature(), s ? i[a] = this.tsParseTypeOrTypePredicateAnnotation(r) : this.match(r) && (i[a] = this.tsParseTypeOrTypePredicateAnnotation(r));
  }
  tsParseBindingListForSignature() {
    const r = super.parseBindingList(11, 41, 2);
    for (const i of r) {
      const {
        type: s
      } = i;
      (s === "AssignmentPattern" || s === "TSParameterProperty") && this.raise(le.UnsupportedSignatureParameterKind, {
        at: i,
        type: s
      });
    }
    return r;
  }
  tsParseTypeMemberSemicolon() {
    !this.eat(12) && !this.isLineTerminator() && this.expect(13);
  }
  tsParseSignatureMember(r, i) {
    return this.tsFillSignature(14, i), this.tsParseTypeMemberSemicolon(), this.finishNode(i, r);
  }
  tsIsUnambiguouslyIndexSignature() {
    return this.next(), ke(this.state.type) ? (this.next(), this.match(14)) : !1;
  }
  tsTryParseIndexSignature(r) {
    if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
      return;
    this.expect(0);
    const i = this.parseIdentifier();
    i.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(i), this.expect(3), r.parameters = [i];
    const s = this.tsTryParseTypeAnnotation();
    return s && (r.typeAnnotation = s), this.tsParseTypeMemberSemicolon(), this.finishNode(r, "TSIndexSignature");
  }
  tsParsePropertyOrMethodSignature(r, i) {
    this.eat(17) && (r.optional = !0);
    const s = r;
    if (this.match(10) || this.match(47)) {
      i && this.raise(le.ReadonlyForMethodSignature, {
        at: r
      });
      const n = s;
      n.kind && this.match(47) && this.raise(le.AccesorCannotHaveTypeParameters, {
        at: this.state.curPosition()
      }), this.tsFillSignature(14, n), this.tsParseTypeMemberSemicolon();
      const a = "parameters", o = "typeAnnotation";
      if (n.kind === "get")
        n[a].length > 0 && (this.raise(N.BadGetterArity, {
          at: this.state.curPosition()
        }), this.isThisParam(n[a][0]) && this.raise(le.AccesorCannotDeclareThisParameter, {
          at: this.state.curPosition()
        }));
      else if (n.kind === "set") {
        if (n[a].length !== 1)
          this.raise(N.BadSetterArity, {
            at: this.state.curPosition()
          });
        else {
          const l = n[a][0];
          this.isThisParam(l) && this.raise(le.AccesorCannotDeclareThisParameter, {
            at: this.state.curPosition()
          }), l.type === "Identifier" && l.optional && this.raise(le.SetAccesorCannotHaveOptionalParameter, {
            at: this.state.curPosition()
          }), l.type === "RestElement" && this.raise(le.SetAccesorCannotHaveRestParameter, {
            at: this.state.curPosition()
          });
        }
        n[o] && this.raise(le.SetAccesorCannotHaveReturnType, {
          at: n[o]
        });
      } else
        n.kind = "method";
      return this.finishNode(n, "TSMethodSignature");
    } else {
      const n = s;
      i && (n.readonly = !0);
      const a = this.tsTryParseTypeAnnotation();
      return a && (n.typeAnnotation = a), this.tsParseTypeMemberSemicolon(), this.finishNode(n, "TSPropertySignature");
    }
  }
  tsParseTypeMember() {
    const r = this.startNode();
    if (this.match(10) || this.match(47))
      return this.tsParseSignatureMember("TSCallSignatureDeclaration", r);
    if (this.match(77)) {
      const s = this.startNode();
      return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", r) : (r.key = this.createIdentifier(s, "new"), this.tsParsePropertyOrMethodSignature(r, !1));
    }
    this.tsParseModifiers({
      allowedModifiers: ["readonly"],
      disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
    }, r);
    const i = this.tsTryParseIndexSignature(r);
    return i || (super.parsePropertyName(r), !r.computed && r.key.type === "Identifier" && (r.key.name === "get" || r.key.name === "set") && this.tsTokenCanFollowModifier() && (r.kind = r.key.name, super.parsePropertyName(r)), this.tsParsePropertyOrMethodSignature(r, !!r.readonly));
  }
  tsParseTypeLiteral() {
    const r = this.startNode();
    return r.members = this.tsParseObjectTypeMembers(), this.finishNode(r, "TSTypeLiteral");
  }
  tsParseObjectTypeMembers() {
    this.expect(5);
    const r = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
    return this.expect(8), r;
  }
  tsIsStartOfMappedType() {
    return this.next(), this.eat(53) ? this.isContextual(120) : (this.isContextual(120) && this.next(), !this.match(0) || (this.next(), !this.tsIsIdentifier()) ? !1 : (this.next(), this.match(58)));
  }
  tsParseMappedTypeParameter() {
    const r = this.startNode();
    return r.name = this.tsParseTypeParameterName(), r.constraint = this.tsExpectThenParseType(58), this.finishNode(r, "TSTypeParameter");
  }
  tsParseMappedType() {
    const r = this.startNode();
    return this.expect(5), this.match(53) ? (r.readonly = this.state.value, this.next(), this.expectContextual(120)) : this.eatContextual(120) && (r.readonly = !0), this.expect(0), r.typeParameter = this.tsParseMappedTypeParameter(), r.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (r.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (r.optional = !0), r.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(r, "TSMappedType");
  }
  tsParseTupleType() {
    const r = this.startNode();
    r.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
    let i = !1, s = null;
    return r.elementTypes.forEach((n) => {
      var a;
      const {
        type: o
      } = n;
      i && o !== "TSRestType" && o !== "TSOptionalType" && !(o === "TSNamedTupleMember" && n.optional) && this.raise(le.OptionalTypeBeforeRequired, {
        at: n
      }), i || (i = o === "TSNamedTupleMember" && n.optional || o === "TSOptionalType");
      let l = o;
      o === "TSRestType" && (n = n.typeAnnotation, l = n.type);
      const u = l === "TSNamedTupleMember";
      (a = s) != null || (s = u), s !== u && this.raise(le.MixedLabeledAndUnlabeledElements, {
        at: n
      });
    }), this.finishNode(r, "TSTupleType");
  }
  tsParseTupleElementType() {
    const {
      startLoc: r
    } = this.state, i = this.eat(21);
    let s, n, a, o;
    const u = bt(this.state.type) ? this.lookaheadCharCode() : null;
    if (u === 58)
      s = !0, a = !1, n = this.parseIdentifier(!0), this.expect(14), o = this.tsParseType();
    else if (u === 63) {
      a = !0;
      const c = this.state.startLoc, p = this.state.value, h = this.tsParseNonArrayType();
      this.lookaheadCharCode() === 58 ? (s = !0, n = this.createIdentifier(this.startNodeAt(c), p), this.expect(17), this.expect(14), o = this.tsParseType()) : (s = !1, o = h, this.expect(17));
    } else
      o = this.tsParseType(), a = this.eat(17), s = this.eat(14);
    if (s) {
      let c;
      n ? (c = this.startNodeAtNode(n), c.optional = a, c.label = n, c.elementType = o, this.eat(17) && (c.optional = !0, this.raise(le.TupleOptionalAfterType, {
        at: this.state.lastTokStartLoc
      }))) : (c = this.startNodeAtNode(o), c.optional = a, this.raise(le.InvalidTupleMemberLabel, {
        at: o
      }), c.label = o, c.elementType = this.tsParseType()), o = this.finishNode(c, "TSNamedTupleMember");
    } else if (a) {
      const c = this.startNodeAtNode(o);
      c.typeAnnotation = o, o = this.finishNode(c, "TSOptionalType");
    }
    if (i) {
      const c = this.startNodeAt(r);
      c.typeAnnotation = o, o = this.finishNode(c, "TSRestType");
    }
    return o;
  }
  tsParseParenthesizedType() {
    const r = this.startNode();
    return this.expect(10), r.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(r, "TSParenthesizedType");
  }
  tsParseFunctionOrConstructorType(r, i) {
    const s = this.startNode();
    return r === "TSConstructorType" && (s.abstract = !!i, i && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, s)), this.finishNode(s, r);
  }
  tsParseLiteralTypeNode() {
    const r = this.startNode();
    switch (this.state.type) {
      case 132:
      case 133:
      case 131:
      case 85:
      case 86:
        r.literal = super.parseExprAtom();
        break;
      default:
        this.unexpected();
    }
    return this.finishNode(r, "TSLiteralType");
  }
  tsParseTemplateLiteralType() {
    const r = this.startNode();
    return r.literal = super.parseTemplate(!1), this.finishNode(r, "TSLiteralType");
  }
  parseTemplateSubstitution() {
    return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
  }
  tsParseThisTypeOrThisTypePredicate() {
    const r = this.tsParseThisTypeNode();
    return this.isContextual(114) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(r) : r;
  }
  tsParseNonArrayType() {
    switch (this.state.type) {
      case 131:
      case 132:
      case 133:
      case 85:
      case 86:
        return this.tsParseLiteralTypeNode();
      case 53:
        if (this.state.value === "-") {
          const r = this.startNode(), i = this.lookahead();
          return i.type !== 132 && i.type !== 133 && this.unexpected(), r.literal = this.parseMaybeUnary(), this.finishNode(r, "TSLiteralType");
        }
        break;
      case 78:
        return this.tsParseThisTypeOrThisTypePredicate();
      case 87:
        return this.tsParseTypeQuery();
      case 83:
        return this.tsParseImportType();
      case 5:
        return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
      case 0:
        return this.tsParseTupleType();
      case 10:
        return this.tsParseParenthesizedType();
      case 25:
      case 24:
        return this.tsParseTemplateLiteralType();
      default: {
        const {
          type: r
        } = this.state;
        if (ke(r) || r === 88 || r === 84) {
          const i = r === 88 ? "TSVoidKeyword" : r === 84 ? "TSNullKeyword" : lT(this.state.value);
          if (i !== void 0 && this.lookaheadCharCode() !== 46) {
            const s = this.startNode();
            return this.next(), this.finishNode(s, i);
          }
          return this.tsParseTypeReference();
        }
      }
    }
    this.unexpected();
  }
  tsParseArrayTypeOrHigher() {
    let r = this.tsParseNonArrayType();
    for (; !this.hasPrecedingLineBreak() && this.eat(0); )
      if (this.match(3)) {
        const i = this.startNodeAtNode(r);
        i.elementType = r, this.expect(3), r = this.finishNode(i, "TSArrayType");
      } else {
        const i = this.startNodeAtNode(r);
        i.objectType = r, i.indexType = this.tsParseType(), this.expect(3), r = this.finishNode(i, "TSIndexedAccessType");
      }
    return r;
  }
  tsParseTypeOperator() {
    const r = this.startNode(), i = this.state.value;
    return this.next(), r.operator = i, r.typeAnnotation = this.tsParseTypeOperatorOrHigher(), i === "readonly" && this.tsCheckTypeAnnotationForReadOnly(r), this.finishNode(r, "TSTypeOperator");
  }
  tsCheckTypeAnnotationForReadOnly(r) {
    switch (r.typeAnnotation.type) {
      case "TSTupleType":
      case "TSArrayType":
        return;
      default:
        this.raise(le.UnexpectedReadonly, {
          at: r
        });
    }
  }
  tsParseInferType() {
    const r = this.startNode();
    this.expectContextual(113);
    const i = this.startNode();
    return i.name = this.tsParseTypeParameterName(), i.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), r.typeParameter = this.finishNode(i, "TSTypeParameter"), this.finishNode(r, "TSInferType");
  }
  tsParseConstraintForInferType() {
    if (this.eat(81)) {
      const r = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
      if (this.state.inDisallowConditionalTypesContext || !this.match(17))
        return r;
    }
  }
  tsParseTypeOperatorOrHigher() {
    return Zm(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(113) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
  }
  tsParseUnionOrIntersectionType(r, i, s) {
    const n = this.startNode(), a = this.eat(s), o = [];
    do
      o.push(i());
    while (this.eat(s));
    return o.length === 1 && !a ? o[0] : (n.types = o, this.finishNode(n, r));
  }
  tsParseIntersectionTypeOrHigher() {
    return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
  }
  tsParseUnionTypeOrHigher() {
    return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
  }
  tsIsStartOfFunctionType() {
    return this.match(47) ? !0 : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
  }
  tsSkipParameterStart() {
    if (ke(this.state.type) || this.match(78))
      return this.next(), !0;
    if (this.match(5)) {
      const {
        errors: r
      } = this.state, i = r.length;
      try {
        return this.parseObjectLike(8, !0), r.length === i;
      } catch {
        return !1;
      }
    }
    if (this.match(0)) {
      this.next();
      const {
        errors: r
      } = this.state, i = r.length;
      try {
        return super.parseBindingList(3, 93, 1), r.length === i;
      } catch {
        return !1;
      }
    }
    return !1;
  }
  tsIsUnambiguouslyStartOfFunctionType() {
    return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
  }
  tsParseTypeOrTypePredicateAnnotation(r) {
    return this.tsInType(() => {
      const i = this.startNode();
      this.expect(r);
      const s = this.startNode(), n = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
      if (n && this.match(78)) {
        let l = this.tsParseThisTypeOrThisTypePredicate();
        return l.type === "TSThisType" ? (s.parameterName = l, s.asserts = !0, s.typeAnnotation = null, l = this.finishNode(s, "TSTypePredicate")) : (this.resetStartLocationFromNode(l, s), l.asserts = !0), i.typeAnnotation = l, this.finishNode(i, "TSTypeAnnotation");
      }
      const a = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
      if (!a)
        return n ? (s.parameterName = this.parseIdentifier(), s.asserts = n, s.typeAnnotation = null, i.typeAnnotation = this.finishNode(s, "TSTypePredicate"), this.finishNode(i, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, i);
      const o = this.tsParseTypeAnnotation(!1);
      return s.parameterName = a, s.typeAnnotation = o, s.asserts = n, i.typeAnnotation = this.finishNode(s, "TSTypePredicate"), this.finishNode(i, "TSTypeAnnotation");
    });
  }
  tsTryParseTypeOrTypePredicateAnnotation() {
    if (this.match(14))
      return this.tsParseTypeOrTypePredicateAnnotation(14);
  }
  tsTryParseTypeAnnotation() {
    if (this.match(14))
      return this.tsParseTypeAnnotation();
  }
  tsTryParseType() {
    return this.tsEatThenParseType(14);
  }
  tsParseTypePredicatePrefix() {
    const r = this.parseIdentifier();
    if (this.isContextual(114) && !this.hasPrecedingLineBreak())
      return this.next(), r;
  }
  tsParseTypePredicateAsserts() {
    if (this.state.type !== 107)
      return !1;
    const r = this.state.containsEsc;
    return this.next(), !ke(this.state.type) && !this.match(78) ? !1 : (r && this.raise(N.InvalidEscapedReservedWord, {
      at: this.state.lastTokStartLoc,
      reservedWord: "asserts"
    }), !0);
  }
  tsParseTypeAnnotation(r = !0, i = this.startNode()) {
    return this.tsInType(() => {
      r && this.expect(14), i.typeAnnotation = this.tsParseType();
    }), this.finishNode(i, "TSTypeAnnotation");
  }
  tsParseType() {
    wo(this.state.inType);
    const r = this.tsParseNonConditionalType();
    if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
      return r;
    const i = this.startNodeAtNode(r);
    return i.checkType = r, i.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), i.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), i.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(i, "TSConditionalType");
  }
  isAbstractConstructorSignature() {
    return this.isContextual(122) && this.lookahead().type === 77;
  }
  tsParseNonConditionalType() {
    return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
  }
  tsParseTypeAssertion() {
    this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(le.ReservedTypeAssertion, {
      at: this.state.startLoc
    });
    const r = this.startNode();
    return r.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.expect(48), r.expression = this.parseMaybeUnary(), this.finishNode(r, "TSTypeAssertion");
  }
  tsParseHeritageClause(r) {
    const i = this.state.startLoc, s = this.tsParseDelimitedList("HeritageClauseElement", () => {
      const n = this.startNode();
      return n.expression = this.tsParseEntityName(), this.match(47) && (n.typeParameters = this.tsParseTypeArguments()), this.finishNode(n, "TSExpressionWithTypeArguments");
    });
    return s.length || this.raise(le.EmptyHeritageClauseType, {
      at: i,
      token: r
    }), s;
  }
  tsParseInterfaceDeclaration(r, i = {}) {
    if (this.hasFollowingLineBreak())
      return null;
    this.expectContextual(127), i.declare && (r.declare = !0), ke(this.state.type) ? (r.id = this.parseIdentifier(), this.checkIdentifier(r.id, hy)) : (r.id = null, this.raise(le.MissingInterfaceName, {
      at: this.state.startLoc
    })), r.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers), this.eat(81) && (r.extends = this.tsParseHeritageClause("extends"));
    const s = this.startNode();
    return s.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), r.body = this.finishNode(s, "TSInterfaceBody"), this.finishNode(r, "TSInterfaceDeclaration");
  }
  tsParseTypeAliasDeclaration(r) {
    return r.id = this.parseIdentifier(), this.checkIdentifier(r.id, dy), r.typeAnnotation = this.tsInType(() => {
      if (r.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(112) && this.lookahead().type !== 16) {
        const i = this.startNode();
        return this.next(), this.finishNode(i, "TSIntrinsicKeyword");
      }
      return this.tsParseType();
    }), this.semicolon(), this.finishNode(r, "TSTypeAliasDeclaration");
  }
  tsInNoContext(r) {
    const i = this.state.context;
    this.state.context = [i[0]];
    try {
      return r();
    } finally {
      this.state.context = i;
    }
  }
  tsInType(r) {
    const i = this.state.inType;
    this.state.inType = !0;
    try {
      return r();
    } finally {
      this.state.inType = i;
    }
  }
  tsInDisallowConditionalTypesContext(r) {
    const i = this.state.inDisallowConditionalTypesContext;
    this.state.inDisallowConditionalTypesContext = !0;
    try {
      return r();
    } finally {
      this.state.inDisallowConditionalTypesContext = i;
    }
  }
  tsInAllowConditionalTypesContext(r) {
    const i = this.state.inDisallowConditionalTypesContext;
    this.state.inDisallowConditionalTypesContext = !1;
    try {
      return r();
    } finally {
      this.state.inDisallowConditionalTypesContext = i;
    }
  }
  tsEatThenParseType(r) {
    if (this.match(r))
      return this.tsNextThenParseType();
  }
  tsExpectThenParseType(r) {
    return this.tsInType(() => (this.expect(r), this.tsParseType()));
  }
  tsNextThenParseType() {
    return this.tsInType(() => (this.next(), this.tsParseType()));
  }
  tsParseEnumMember() {
    const r = this.startNode();
    return r.id = this.match(131) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0), this.eat(29) && (r.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(r, "TSEnumMember");
  }
  tsParseEnumDeclaration(r, i = {}) {
    return i.const && (r.const = !0), i.declare && (r.declare = !0), this.expectContextual(124), r.id = this.parseIdentifier(), this.checkIdentifier(r.id, r.const ? yy : zu), this.expect(5), r.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(r, "TSEnumDeclaration");
  }
  tsParseModuleBlock() {
    const r = this.startNode();
    return this.scope.enter(Cr), this.expect(5), super.parseBlockOrModuleBlockBody(r.body = [], void 0, !0, 8), this.scope.exit(), this.finishNode(r, "TSModuleBlock");
  }
  tsParseModuleOrNamespaceDeclaration(r, i = !1) {
    if (r.id = this.parseIdentifier(), i || this.checkIdentifier(r.id, Ty), this.eat(16)) {
      const s = this.startNode();
      this.tsParseModuleOrNamespaceDeclaration(s, !0), r.body = s;
    } else
      this.scope.enter(_r), this.prodParam.enter(kr), r.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
    return this.finishNode(r, "TSModuleDeclaration");
  }
  tsParseAmbientExternalModuleDeclaration(r) {
    return this.isContextual(110) ? (r.global = !0, r.id = this.parseIdentifier()) : this.match(131) ? r.id = super.parseStringLiteral(this.state.value) : this.unexpected(), this.match(5) ? (this.scope.enter(_r), this.prodParam.enter(kr), r.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(r, "TSModuleDeclaration");
  }
  tsParseImportEqualsDeclaration(r, i, s) {
    r.isExport = s || !1, r.id = i || this.parseIdentifier(), this.checkIdentifier(r.id, ri), this.expect(29);
    const n = this.tsParseModuleReference();
    return r.importKind === "type" && n.type !== "TSExternalModuleReference" && this.raise(le.ImportAliasHasImportType, {
      at: n
    }), r.moduleReference = n, this.semicolon(), this.finishNode(r, "TSImportEqualsDeclaration");
  }
  tsIsExternalModuleReference() {
    return this.isContextual(117) && this.lookaheadCharCode() === 40;
  }
  tsParseModuleReference() {
    return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(!1);
  }
  tsParseExternalModuleReference() {
    const r = this.startNode();
    return this.expectContextual(117), this.expect(10), this.match(131) || this.unexpected(), r.expression = super.parseExprAtom(), this.expect(11), this.sawUnambiguousESM = !0, this.finishNode(r, "TSExternalModuleReference");
  }
  tsLookAhead(r) {
    const i = this.state.clone(), s = r();
    return this.state = i, s;
  }
  tsTryParseAndCatch(r) {
    const i = this.tryParse((s) => r() || s());
    if (!(i.aborted || !i.node))
      return i.error && (this.state = i.failState), i.node;
  }
  tsTryParse(r) {
    const i = this.state.clone(), s = r();
    if (s !== void 0 && s !== !1)
      return s;
    this.state = i;
  }
  tsTryParseDeclare(r) {
    if (this.isLineTerminator())
      return;
    let i = this.state.type, s;
    return this.isContextual(99) && (i = 74, s = "let"), this.tsInAmbientContext(() => {
      switch (i) {
        case 68:
          return r.declare = !0, super.parseFunctionStatement(r, !1, !1);
        case 80:
          return r.declare = !0, this.parseClass(r, !0, !1);
        case 124:
          return this.tsParseEnumDeclaration(r, {
            declare: !0
          });
        case 110:
          return this.tsParseAmbientExternalModuleDeclaration(r);
        case 75:
        case 74:
          return !this.match(75) || !this.isLookaheadContextual("enum") ? (r.declare = !0, this.parseVarStatement(r, s || this.state.value, !0)) : (this.expect(75), this.tsParseEnumDeclaration(r, {
            const: !0,
            declare: !0
          }));
        case 127: {
          const n = this.tsParseInterfaceDeclaration(r, {
            declare: !0
          });
          if (n)
            return n;
        }
        default:
          if (ke(i))
            return this.tsParseDeclaration(r, this.state.value, !0, null);
      }
    });
  }
  tsTryParseExportDeclaration() {
    return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
  }
  tsParseExpressionStatement(r, i, s) {
    switch (i.name) {
      case "declare": {
        const n = this.tsTryParseDeclare(r);
        return n && (n.declare = !0), n;
      }
      case "global":
        if (this.match(5)) {
          this.scope.enter(_r), this.prodParam.enter(kr);
          const n = r;
          return n.global = !0, n.id = i, n.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(n, "TSModuleDeclaration");
        }
        break;
      default:
        return this.tsParseDeclaration(r, i.name, !1, s);
    }
  }
  tsParseDeclaration(r, i, s, n) {
    switch (i) {
      case "abstract":
        if (this.tsCheckLineTerminator(s) && (this.match(80) || ke(this.state.type)))
          return this.tsParseAbstractDeclaration(r, n);
        break;
      case "module":
        if (this.tsCheckLineTerminator(s)) {
          if (this.match(131))
            return this.tsParseAmbientExternalModuleDeclaration(r);
          if (ke(this.state.type))
            return this.tsParseModuleOrNamespaceDeclaration(r);
        }
        break;
      case "namespace":
        if (this.tsCheckLineTerminator(s) && ke(this.state.type))
          return this.tsParseModuleOrNamespaceDeclaration(r);
        break;
      case "type":
        if (this.tsCheckLineTerminator(s) && ke(this.state.type))
          return this.tsParseTypeAliasDeclaration(r);
        break;
    }
  }
  tsCheckLineTerminator(r) {
    return r ? this.hasFollowingLineBreak() ? !1 : (this.next(), !0) : !this.isLineTerminator();
  }
  tsTryParseGenericAsyncArrowFunction(r) {
    if (!this.match(47))
      return;
    const i = this.state.maybeInArrowParameters;
    this.state.maybeInArrowParameters = !0;
    const s = this.tsTryParseAndCatch(() => {
      const n = this.startNodeAt(r);
      return n.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(n), n.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), n;
    });
    if (this.state.maybeInArrowParameters = i, !!s)
      return super.parseArrowExpression(s, null, !0);
  }
  tsParseTypeArgumentsInExpression() {
    if (this.reScan_lt() === 47)
      return this.tsParseTypeArguments();
  }
  tsParseTypeArguments() {
    const r = this.startNode();
    return r.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), r.params.length === 0 ? this.raise(le.EmptyTypeArguments, {
      at: r
    }) : !this.state.inType && this.curContext() === Be.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(r, "TSTypeParameterInstantiation");
  }
  tsIsDeclarationStart() {
    return ey(this.state.type);
  }
  isExportDefaultSpecifier() {
    return this.tsIsDeclarationStart() ? !1 : super.isExportDefaultSpecifier();
  }
  parseAssignableListItem(r, i) {
    const s = this.state.startLoc, n = {};
    this.tsParseModifiers({
      allowedModifiers: ["public", "private", "protected", "override", "readonly"]
    }, n);
    const a = n.accessibility, o = n.override, l = n.readonly;
    !(r & 4) && (a || l || o) && this.raise(le.UnexpectedParameterModifier, {
      at: s
    });
    const u = this.parseMaybeDefault();
    this.parseAssignableListItemTypes(u, r);
    const c = this.parseMaybeDefault(u.loc.start, u);
    if (a || l || o) {
      const p = this.startNodeAt(s);
      return i.length && (p.decorators = i), a && (p.accessibility = a), l && (p.readonly = l), o && (p.override = o), c.type !== "Identifier" && c.type !== "AssignmentPattern" && this.raise(le.UnsupportedParameterPropertyKind, {
        at: p
      }), p.parameter = c, this.finishNode(p, "TSParameterProperty");
    }
    return i.length && (u.decorators = i), c;
  }
  isSimpleParameter(r) {
    return r.type === "TSParameterProperty" && super.isSimpleParameter(r.parameter) || super.isSimpleParameter(r);
  }
  tsDisallowOptionalPattern(r) {
    for (const i of r.params)
      i.type !== "Identifier" && i.optional && !this.state.isAmbientContext && this.raise(le.PatternIsOptional, {
        at: i
      });
  }
  setArrowFunctionParameters(r, i, s) {
    super.setArrowFunctionParameters(r, i, s), this.tsDisallowOptionalPattern(r);
  }
  parseFunctionBodyAndFinish(r, i, s = !1) {
    this.match(14) && (r.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
    const n = i === "FunctionDeclaration" ? "TSDeclareFunction" : i === "ClassMethod" || i === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
    return n && !this.match(5) && this.isLineTerminator() ? this.finishNode(r, n) : n === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(le.DeclareFunctionHasImplementation, {
      at: r
    }), r.declare) ? super.parseFunctionBodyAndFinish(r, n, s) : (this.tsDisallowOptionalPattern(r), super.parseFunctionBodyAndFinish(r, i, s));
  }
  registerFunctionStatementId(r) {
    !r.body && r.id ? this.checkIdentifier(r.id, Po) : super.registerFunctionStatementId(r);
  }
  tsCheckForInvalidTypeCasts(r) {
    r.forEach((i) => {
      (i == null ? void 0 : i.type) === "TSTypeCastExpression" && this.raise(le.UnexpectedTypeAnnotation, {
        at: i.typeAnnotation
      });
    });
  }
  toReferencedList(r, i) {
    return this.tsCheckForInvalidTypeCasts(r), r;
  }
  parseArrayLike(r, i, s, n) {
    const a = super.parseArrayLike(r, i, s, n);
    return a.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(a.elements), a;
  }
  parseSubscript(r, i, s, n) {
    if (!this.hasPrecedingLineBreak() && this.match(35)) {
      this.state.canStartJSXElement = !1, this.next();
      const o = this.startNodeAt(i);
      return o.expression = r, this.finishNode(o, "TSNonNullExpression");
    }
    let a = !1;
    if (this.match(18) && this.lookaheadCharCode() === 60) {
      if (s)
        return n.stop = !0, r;
      n.optionalChainMember = a = !0, this.next();
    }
    if (this.match(47) || this.match(51)) {
      let o;
      const l = this.tsTryParseAndCatch(() => {
        if (!s && this.atPossibleAsyncArrow(r)) {
          const h = this.tsTryParseGenericAsyncArrowFunction(i);
          if (h)
            return h;
        }
        const u = this.tsParseTypeArgumentsInExpression();
        if (!u)
          return;
        if (a && !this.match(10)) {
          o = this.state.curPosition();
          return;
        }
        if (ls(this.state.type)) {
          const h = super.parseTaggedTemplateExpression(r, i, n);
          return h.typeParameters = u, h;
        }
        if (!s && this.eat(10)) {
          const h = this.startNodeAt(i);
          return h.callee = r, h.arguments = this.parseCallExpressionArguments(11, !1), this.tsCheckForInvalidTypeCasts(h.arguments), h.typeParameters = u, n.optionalChainMember && (h.optional = a), this.finishCallExpression(h, n.optionalChainMember);
        }
        const c = this.state.type;
        if (c === 48 || c === 52 || c !== 10 && _n(c) && !this.hasPrecedingLineBreak())
          return;
        const p = this.startNodeAt(i);
        return p.expression = r, p.typeParameters = u, this.finishNode(p, "TSInstantiationExpression");
      });
      if (o && this.unexpected(o, 10), l)
        return l.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(le.InvalidPropertyAccessAfterInstantiationExpression, {
          at: this.state.startLoc
        }), l;
    }
    return super.parseSubscript(r, i, s, n);
  }
  parseNewCallee(r) {
    var i;
    super.parseNewCallee(r);
    const {
      callee: s
    } = r;
    s.type === "TSInstantiationExpression" && !((i = s.extra) != null && i.parenthesized) && (r.typeParameters = s.typeParameters, r.callee = s.expression);
  }
  parseExprOp(r, i, s) {
    let n;
    if (Zi(58) > s && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (n = this.isContextual(118)))) {
      const a = this.startNodeAt(i);
      return a.expression = r, a.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (n && this.raise(N.UnexpectedKeyword, {
        at: this.state.startLoc,
        keyword: "const"
      }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(a, n ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(a, i, s);
    }
    return super.parseExprOp(r, i, s);
  }
  checkReservedWord(r, i, s, n) {
    this.state.isAmbientContext || super.checkReservedWord(r, i, s, n);
  }
  checkImportReflection(r) {
    super.checkImportReflection(r), r.module && r.importKind !== "value" && this.raise(le.ImportReflectionHasImportType, {
      at: r.specifiers[0].loc.start
    });
  }
  checkDuplicateExports() {
  }
  isPotentialImportPhase(r) {
    if (super.isPotentialImportPhase(r))
      return !0;
    if (this.isContextual(128)) {
      const i = this.lookaheadCharCode();
      return r ? i === 123 || i === 42 : i !== 61;
    }
    return !r && this.isContextual(87);
  }
  applyImportPhase(r, i, s, n) {
    super.applyImportPhase(r, i, s, n), i ? r.exportKind = s === "type" ? "type" : "value" : r.importKind = s === "type" || s === "typeof" ? s : "value";
  }
  parseImport(r) {
    if (this.match(131))
      return r.importKind = "value", super.parseImport(r);
    let i;
    if (ke(this.state.type) && this.lookaheadCharCode() === 61)
      return r.importKind = "value", this.tsParseImportEqualsDeclaration(r);
    if (this.isContextual(128)) {
      const s = this.parseMaybeImportPhase(r, !1);
      if (this.lookaheadCharCode() === 61)
        return this.tsParseImportEqualsDeclaration(r, s);
      i = super.parseImportSpecifiersAndAfter(r, s);
    } else
      i = super.parseImport(r);
    return i.importKind === "type" && i.specifiers.length > 1 && i.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(le.TypeImportCannotSpecifyDefaultAndNamed, {
      at: i
    }), i;
  }
  parseExport(r, i) {
    if (this.match(83)) {
      this.next();
      let s = null;
      return this.isContextual(128) && this.isPotentialImportPhase(!1) ? s = this.parseMaybeImportPhase(r, !1) : r.importKind = "value", this.tsParseImportEqualsDeclaration(r, s, !0);
    } else if (this.eat(29)) {
      const s = r;
      return s.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(s, "TSExportAssignment");
    } else if (this.eatContextual(93)) {
      const s = r;
      return this.expectContextual(126), s.id = this.parseIdentifier(), this.semicolon(), this.finishNode(s, "TSNamespaceExportDeclaration");
    } else
      return super.parseExport(r, i);
  }
  isAbstractClass() {
    return this.isContextual(122) && this.lookahead().type === 80;
  }
  parseExportDefaultExpression() {
    if (this.isAbstractClass()) {
      const r = this.startNode();
      return this.next(), r.abstract = !0, this.parseClass(r, !0, !0);
    }
    if (this.match(127)) {
      const r = this.tsParseInterfaceDeclaration(this.startNode());
      if (r)
        return r;
    }
    return super.parseExportDefaultExpression();
  }
  parseVarStatement(r, i, s = !1) {
    const {
      isAmbientContext: n
    } = this.state, a = super.parseVarStatement(r, i, s || n);
    if (!n)
      return a;
    for (const {
      id: o,
      init: l
    } of a.declarations)
      l && (i !== "const" || o.typeAnnotation ? this.raise(le.InitializerNotAllowedInAmbientContext, {
        at: l
      }) : pT(l, this.hasPlugin("estree")) || this.raise(le.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, {
        at: l
      }));
    return a;
  }
  parseStatementContent(r, i) {
    if (this.match(75) && this.isLookaheadContextual("enum")) {
      const s = this.startNode();
      return this.expect(75), this.tsParseEnumDeclaration(s, {
        const: !0
      });
    }
    if (this.isContextual(124))
      return this.tsParseEnumDeclaration(this.startNode());
    if (this.isContextual(127)) {
      const s = this.tsParseInterfaceDeclaration(this.startNode());
      if (s)
        return s;
    }
    return super.parseStatementContent(r, i);
  }
  parseAccessModifier() {
    return this.tsParseModifier(["public", "protected", "private"]);
  }
  tsHasSomeModifiers(r, i) {
    return i.some((s) => Oo(s) ? r.accessibility === s : !!r[s]);
  }
  tsIsStartOfStaticBlocks() {
    return this.isContextual(104) && this.lookaheadCharCode() === 123;
  }
  parseClassMember(r, i, s) {
    const n = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
    this.tsParseModifiers({
      allowedModifiers: n,
      disallowedModifiers: ["in", "out"],
      stopOnStartOfClassStaticBlock: !0,
      errorTemplate: le.InvalidModifierOnTypeParameterPositions
    }, i);
    const a = () => {
      this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(i, n) && this.raise(le.StaticBlockCannotHaveModifier, {
        at: this.state.curPosition()
      }), super.parseClassStaticBlock(r, i)) : this.parseClassMemberWithIsStatic(r, i, s, !!i.static);
    };
    i.declare ? this.tsInAmbientContext(a) : a();
  }
  parseClassMemberWithIsStatic(r, i, s, n) {
    const a = this.tsTryParseIndexSignature(i);
    if (a) {
      r.body.push(a), i.abstract && this.raise(le.IndexSignatureHasAbstract, {
        at: i
      }), i.accessibility && this.raise(le.IndexSignatureHasAccessibility, {
        at: i,
        modifier: i.accessibility
      }), i.declare && this.raise(le.IndexSignatureHasDeclare, {
        at: i
      }), i.override && this.raise(le.IndexSignatureHasOverride, {
        at: i
      });
      return;
    }
    !this.state.inAbstractClass && i.abstract && this.raise(le.NonAbstractClassHasAbstractMethod, {
      at: i
    }), i.override && (s.hadSuperClass || this.raise(le.OverrideNotInSubClass, {
      at: i
    })), super.parseClassMemberWithIsStatic(r, i, s, n);
  }
  parsePostMemberNameModifiers(r) {
    this.eat(17) && (r.optional = !0), r.readonly && this.match(10) && this.raise(le.ClassMethodHasReadonly, {
      at: r
    }), r.declare && this.match(10) && this.raise(le.ClassMethodHasDeclare, {
      at: r
    });
  }
  parseExpressionStatement(r, i, s) {
    return (i.type === "Identifier" ? this.tsParseExpressionStatement(r, i, s) : void 0) || super.parseExpressionStatement(r, i, s);
  }
  shouldParseExportDeclaration() {
    return this.tsIsDeclarationStart() ? !0 : super.shouldParseExportDeclaration();
  }
  parseConditional(r, i, s) {
    if (!this.state.maybeInArrowParameters || !this.match(17))
      return super.parseConditional(r, i, s);
    const n = this.tryParse(() => super.parseConditional(r, i));
    return n.node ? (n.error && (this.state = n.failState), n.node) : (n.error && super.setOptionalParametersError(s, n.error), r);
  }
  parseParenItem(r, i) {
    if (r = super.parseParenItem(r, i), this.eat(17) && (r.optional = !0, this.resetEndLocation(r)), this.match(14)) {
      const s = this.startNodeAt(i);
      return s.expression = r, s.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(s, "TSTypeCastExpression");
    }
    return r;
  }
  parseExportDeclaration(r) {
    if (!this.state.isAmbientContext && this.isContextual(123))
      return this.tsInAmbientContext(() => this.parseExportDeclaration(r));
    const i = this.state.startLoc, s = this.eatContextual(123);
    if (s && (this.isContextual(123) || !this.shouldParseExportDeclaration()))
      throw this.raise(le.ExpectedAmbientAfterExportDeclare, {
        at: this.state.startLoc
      });
    const a = ke(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(r);
    return a ? ((a.type === "TSInterfaceDeclaration" || a.type === "TSTypeAliasDeclaration" || s) && (r.exportKind = "type"), s && (this.resetStartLocation(a, i), a.declare = !0), a) : null;
  }
  parseClassId(r, i, s, n) {
    if ((!i || s) && this.isContextual(111))
      return;
    super.parseClassId(r, i, s, r.declare ? Po : Hu);
    const a = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
    a && (r.typeParameters = a);
  }
  parseClassPropertyAnnotation(r) {
    r.optional || (this.eat(35) ? r.definite = !0 : this.eat(17) && (r.optional = !0));
    const i = this.tsTryParseTypeAnnotation();
    i && (r.typeAnnotation = i);
  }
  parseClassProperty(r) {
    if (this.parseClassPropertyAnnotation(r), this.state.isAmbientContext && !(r.readonly && !r.typeAnnotation) && this.match(29) && this.raise(le.DeclareClassFieldHasInitializer, {
      at: this.state.startLoc
    }), r.abstract && this.match(29)) {
      const {
        key: i
      } = r;
      this.raise(le.AbstractPropertyHasInitializer, {
        at: this.state.startLoc,
        propertyName: i.type === "Identifier" && !r.computed ? i.name : `[${this.input.slice(i.start, i.end)}]`
      });
    }
    return super.parseClassProperty(r);
  }
  parseClassPrivateProperty(r) {
    return r.abstract && this.raise(le.PrivateElementHasAbstract, {
      at: r
    }), r.accessibility && this.raise(le.PrivateElementHasAccessibility, {
      at: r,
      modifier: r.accessibility
    }), this.parseClassPropertyAnnotation(r), super.parseClassPrivateProperty(r);
  }
  parseClassAccessorProperty(r) {
    return this.parseClassPropertyAnnotation(r), r.optional && this.raise(le.AccessorCannotBeOptional, {
      at: r
    }), super.parseClassAccessorProperty(r);
  }
  pushClassMethod(r, i, s, n, a, o) {
    const l = this.tsTryParseTypeParameters(this.tsParseConstModifier);
    l && a && this.raise(le.ConstructorHasTypeParameters, {
      at: l
    });
    const {
      declare: u = !1,
      kind: c
    } = i;
    u && (c === "get" || c === "set") && this.raise(le.DeclareAccessor, {
      at: i,
      kind: c
    }), l && (i.typeParameters = l), super.pushClassMethod(r, i, s, n, a, o);
  }
  pushClassPrivateMethod(r, i, s, n) {
    const a = this.tsTryParseTypeParameters(this.tsParseConstModifier);
    a && (i.typeParameters = a), super.pushClassPrivateMethod(r, i, s, n);
  }
  declareClassPrivateMethodInScope(r, i) {
    r.type !== "TSDeclareMethod" && (r.type === "MethodDefinition" && !r.value.body || super.declareClassPrivateMethodInScope(r, i));
  }
  parseClassSuper(r) {
    super.parseClassSuper(r), r.superClass && (this.match(47) || this.match(51)) && (r.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(111) && (r.implements = this.tsParseHeritageClause("implements"));
  }
  parseObjPropValue(r, i, s, n, a, o, l) {
    const u = this.tsTryParseTypeParameters(this.tsParseConstModifier);
    return u && (r.typeParameters = u), super.parseObjPropValue(r, i, s, n, a, o, l);
  }
  parseFunctionParams(r, i) {
    const s = this.tsTryParseTypeParameters(this.tsParseConstModifier);
    s && (r.typeParameters = s), super.parseFunctionParams(r, i);
  }
  parseVarId(r, i) {
    super.parseVarId(r, i), r.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (r.definite = !0);
    const s = this.tsTryParseTypeAnnotation();
    s && (r.id.typeAnnotation = s, this.resetEndLocation(r.id));
  }
  parseAsyncArrowFromCallExpression(r, i) {
    return this.match(14) && (r.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(r, i);
  }
  parseMaybeAssign(r, i) {
    var s, n, a, o, l;
    let u, c, p;
    if (this.hasPlugin("jsx") && (this.match(140) || this.match(47))) {
      if (u = this.state.clone(), c = this.tryParse(() => super.parseMaybeAssign(r, i), u), !c.error)
        return c.node;
      const {
        context: P
      } = this.state, v = P[P.length - 1];
      (v === Be.j_oTag || v === Be.j_expr) && P.pop();
    }
    if (!((s = c) != null && s.error) && !this.match(47))
      return super.parseMaybeAssign(r, i);
    (!u || u === this.state) && (u = this.state.clone());
    let h;
    const y = this.tryParse((P) => {
      var v, w;
      h = this.tsParseTypeParameters(this.tsParseConstModifier);
      const x = super.parseMaybeAssign(r, i);
      return (x.type !== "ArrowFunctionExpression" || (v = x.extra) != null && v.parenthesized) && P(), ((w = h) == null ? void 0 : w.params.length) !== 0 && this.resetStartLocationFromNode(x, h), x.typeParameters = h, x;
    }, u);
    if (!y.error && !y.aborted)
      return h && this.reportReservedArrowTypeParam(h), y.node;
    if (!c && (wo(!this.hasPlugin("jsx")), p = this.tryParse(() => super.parseMaybeAssign(r, i), u), !p.error))
      return p.node;
    if ((n = c) != null && n.node)
      return this.state = c.failState, c.node;
    if (y.node)
      return this.state = y.failState, h && this.reportReservedArrowTypeParam(h), y.node;
    if ((a = p) != null && a.node)
      return this.state = p.failState, p.node;
    throw ((o = c) == null ? void 0 : o.error) || y.error || ((l = p) == null ? void 0 : l.error);
  }
  reportReservedArrowTypeParam(r) {
    var i;
    r.params.length === 1 && !r.params[0].constraint && !((i = r.extra) != null && i.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(le.ReservedArrowTypeParam, {
      at: r
    });
  }
  parseMaybeUnary(r, i) {
    return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(r, i);
  }
  parseArrow(r) {
    if (this.match(14)) {
      const i = this.tryParse((s) => {
        const n = this.tsParseTypeOrTypePredicateAnnotation(14);
        return (this.canInsertSemicolon() || !this.match(19)) && s(), n;
      });
      if (i.aborted)
        return;
      i.thrown || (i.error && (this.state = i.failState), r.returnType = i.node);
    }
    return super.parseArrow(r);
  }
  parseAssignableListItemTypes(r, i) {
    if (!(i & 2))
      return r;
    this.eat(17) && (r.optional = !0);
    const s = this.tsTryParseTypeAnnotation();
    return s && (r.typeAnnotation = s), this.resetEndLocation(r), r;
  }
  isAssignable(r, i) {
    switch (r.type) {
      case "TSTypeCastExpression":
        return this.isAssignable(r.expression, i);
      case "TSParameterProperty":
        return !0;
      default:
        return super.isAssignable(r, i);
    }
  }
  toAssignable(r, i = !1) {
    switch (r.type) {
      case "ParenthesizedExpression":
        this.toAssignableParenthesizedExpression(r, i);
        break;
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSNonNullExpression":
      case "TSTypeAssertion":
        i ? this.expressionScope.recordArrowParameterBindingError(le.UnexpectedTypeCastInParameter, {
          at: r
        }) : this.raise(le.UnexpectedTypeCastInParameter, {
          at: r
        }), this.toAssignable(r.expression, i);
        break;
      case "AssignmentExpression":
        !i && r.left.type === "TSTypeCastExpression" && (r.left = this.typeCastToParameter(r.left));
      default:
        super.toAssignable(r, i);
    }
  }
  toAssignableParenthesizedExpression(r, i) {
    switch (r.expression.type) {
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSNonNullExpression":
      case "TSTypeAssertion":
      case "ParenthesizedExpression":
        this.toAssignable(r.expression, i);
        break;
      default:
        super.toAssignable(r, i);
    }
  }
  checkToRestConversion(r, i) {
    switch (r.type) {
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        this.checkToRestConversion(r.expression, !1);
        break;
      default:
        super.checkToRestConversion(r, i);
    }
  }
  isValidLVal(r, i, s) {
    return aT({
      TSTypeCastExpression: !0,
      TSParameterProperty: "parameter",
      TSNonNullExpression: "expression",
      TSAsExpression: (s !== Yt || !i) && ["expression", !0],
      TSSatisfiesExpression: (s !== Yt || !i) && ["expression", !0],
      TSTypeAssertion: (s !== Yt || !i) && ["expression", !0]
    }, r) || super.isValidLVal(r, i, s);
  }
  parseBindingAtom() {
    return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
  }
  parseMaybeDecoratorArguments(r) {
    if (this.match(47) || this.match(51)) {
      const i = this.tsParseTypeArgumentsInExpression();
      if (this.match(10)) {
        const s = super.parseMaybeDecoratorArguments(r);
        return s.typeParameters = i, s;
      }
      this.unexpected(null, 10);
    }
    return super.parseMaybeDecoratorArguments(r);
  }
  checkCommaAfterRest(r) {
    return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === r ? (this.next(), !1) : super.checkCommaAfterRest(r);
  }
  isClassMethod() {
    return this.match(47) || super.isClassMethod();
  }
  isClassProperty() {
    return this.match(35) || this.match(14) || super.isClassProperty();
  }
  parseMaybeDefault(r, i) {
    const s = super.parseMaybeDefault(r, i);
    return s.type === "AssignmentPattern" && s.typeAnnotation && s.right.start < s.typeAnnotation.start && this.raise(le.TypeAnnotationAfterAssign, {
      at: s.typeAnnotation
    }), s;
  }
  getTokenFromCode(r) {
    if (this.state.inType) {
      if (r === 62) {
        this.finishOp(48, 1);
        return;
      }
      if (r === 60) {
        this.finishOp(47, 1);
        return;
      }
    }
    super.getTokenFromCode(r);
  }
  reScan_lt_gt() {
    const {
      type: r
    } = this.state;
    r === 47 ? (this.state.pos -= 1, this.readToken_lt()) : r === 48 && (this.state.pos -= 1, this.readToken_gt());
  }
  reScan_lt() {
    const {
      type: r
    } = this.state;
    return r === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : r;
  }
  toAssignableList(r, i, s) {
    for (let n = 0; n < r.length; n++) {
      const a = r[n];
      (a == null ? void 0 : a.type) === "TSTypeCastExpression" && (r[n] = this.typeCastToParameter(a));
    }
    super.toAssignableList(r, i, s);
  }
  typeCastToParameter(r) {
    return r.expression.typeAnnotation = r.typeAnnotation, this.resetEndLocation(r.expression, r.typeAnnotation.loc.end), r.expression;
  }
  shouldParseArrow(r) {
    return this.match(14) ? r.every((i) => this.isAssignable(i, !0)) : super.shouldParseArrow(r);
  }
  shouldParseAsyncArrow() {
    return this.match(14) || super.shouldParseAsyncArrow();
  }
  canHaveLeadingDecorator() {
    return super.canHaveLeadingDecorator() || this.isAbstractClass();
  }
  jsxParseOpeningElementAfterName(r) {
    if (this.match(47) || this.match(51)) {
      const i = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
      i && (r.typeParameters = i);
    }
    return super.jsxParseOpeningElementAfterName(r);
  }
  getGetterSetterExpectedParamCount(r) {
    const i = super.getGetterSetterExpectedParamCount(r), n = this.getObjectOrClassMethodParams(r)[0];
    return n && this.isThisParam(n) ? i + 1 : i;
  }
  parseCatchClauseParam() {
    const r = super.parseCatchClauseParam(), i = this.tsTryParseTypeAnnotation();
    return i && (r.typeAnnotation = i, this.resetEndLocation(r)), r;
  }
  tsInAmbientContext(r) {
    const i = this.state.isAmbientContext;
    this.state.isAmbientContext = !0;
    try {
      return r();
    } finally {
      this.state.isAmbientContext = i;
    }
  }
  parseClass(r, i, s) {
    const n = this.state.inAbstractClass;
    this.state.inAbstractClass = !!r.abstract;
    try {
      return super.parseClass(r, i, s);
    } finally {
      this.state.inAbstractClass = n;
    }
  }
  tsParseAbstractDeclaration(r, i) {
    if (this.match(80))
      return r.abstract = !0, this.maybeTakeDecorators(i, this.parseClass(r, !0, !1));
    if (this.isContextual(127)) {
      if (!this.hasFollowingLineBreak())
        return r.abstract = !0, this.raise(le.NonClassMethodPropertyHasAbstractModifer, {
          at: r
        }), this.tsParseInterfaceDeclaration(r);
    } else
      this.unexpected(null, 80);
  }
  parseMethod(r, i, s, n, a, o, l) {
    const u = super.parseMethod(r, i, s, n, a, o, l);
    if (u.abstract && (this.hasPlugin("estree") ? !!u.value.body : !!u.body)) {
      const {
        key: p
      } = u;
      this.raise(le.AbstractMethodHasImplementation, {
        at: u,
        methodName: p.type === "Identifier" && !u.computed ? p.name : `[${this.input.slice(p.start, p.end)}]`
      });
    }
    return u;
  }
  tsParseTypeParameterName() {
    return this.parseIdentifier().name;
  }
  shouldParseAsAmbientContext() {
    return !!this.getPluginOption("typescript", "dts");
  }
  parse() {
    return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
  }
  getExpression() {
    return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
  }
  parseExportSpecifier(r, i, s, n) {
    return !i && n ? (this.parseTypeOnlyImportExportSpecifier(r, !1, s), this.finishNode(r, "ExportSpecifier")) : (r.exportKind = "value", super.parseExportSpecifier(r, i, s, n));
  }
  parseImportSpecifier(r, i, s, n, a) {
    return !i && n ? (this.parseTypeOnlyImportExportSpecifier(r, !0, s), this.finishNode(r, "ImportSpecifier")) : (r.importKind = "value", super.parseImportSpecifier(r, i, s, n, s ? xo : ri));
  }
  parseTypeOnlyImportExportSpecifier(r, i, s) {
    const n = i ? "imported" : "local", a = i ? "local" : "exported";
    let o = r[n], l, u = !1, c = !0;
    const p = o.loc.start;
    if (this.isContextual(93)) {
      const y = this.parseIdentifier();
      if (this.isContextual(93)) {
        const P = this.parseIdentifier();
        bt(this.state.type) ? (u = !0, o = y, l = i ? this.parseIdentifier() : this.parseModuleExportName(), c = !1) : (l = P, c = !1);
      } else
        bt(this.state.type) ? (c = !1, l = i ? this.parseIdentifier() : this.parseModuleExportName()) : (u = !0, o = y);
    } else
      bt(this.state.type) && (u = !0, i ? (o = this.parseIdentifier(!0), this.isContextual(93) || this.checkReservedWord(o.name, o.loc.start, !0, !0)) : o = this.parseModuleExportName());
    u && s && this.raise(i ? le.TypeModifierIsUsedInTypeImports : le.TypeModifierIsUsedInTypeExports, {
      at: p
    }), r[n] = o, r[a] = l;
    const h = i ? "importKind" : "exportKind";
    r[h] = u ? "type" : "value", c && this.eatContextual(93) && (r[a] = i ? this.parseIdentifier() : this.parseModuleExportName()), r[a] || (r[a] = Bt(r[n])), i && this.checkIdentifier(r[a], u ? xo : ri);
  }
};
function fT(e) {
  if (e.type !== "MemberExpression")
    return !1;
  const {
    computed: t,
    property: r
  } = e;
  return t && r.type !== "StringLiteral" && (r.type !== "TemplateLiteral" || r.expressions.length > 0) ? !1 : cc(e.object);
}
function pT(e, t) {
  var r;
  const {
    type: i
  } = e;
  if ((r = e.extra) != null && r.parenthesized)
    return !1;
  if (t) {
    if (i === "Literal") {
      const {
        value: s
      } = e;
      if (typeof s == "string" || typeof s == "boolean")
        return !0;
    }
  } else if (i === "StringLiteral" || i === "BooleanLiteral")
    return !0;
  return !!(uc(e, t) || hT(e, t) || i === "TemplateLiteral" && e.expressions.length === 0 || fT(e));
}
function uc(e, t) {
  return t ? e.type === "Literal" && (typeof e.value == "number" || "bigint" in e) : e.type === "NumericLiteral" || e.type === "BigIntLiteral";
}
function hT(e, t) {
  if (e.type === "UnaryExpression") {
    const {
      operator: r,
      argument: i
    } = e;
    if (r === "-" && uc(i, t))
      return !0;
  }
  return !1;
}
function cc(e) {
  return e.type === "Identifier" ? !0 : e.type !== "MemberExpression" || e.computed ? !1 : cc(e.object);
}
const No = Lt`placeholders`({
  ClassNameIsRequired: "A class name is required.",
  UnexpectedSpace: "Unexpected space in placeholder."
});
var dT = (e) => class extends e {
  parsePlaceholder(r) {
    if (this.match(142)) {
      const i = this.startNode();
      return this.next(), this.assertNoSpace(), i.name = super.parseIdentifier(!0), this.assertNoSpace(), this.expect(142), this.finishPlaceholder(i, r);
    }
  }
  finishPlaceholder(r, i) {
    const s = !!(r.expectedNode && r.type === "Placeholder");
    return r.expectedNode = i, s ? r : this.finishNode(r, "Placeholder");
  }
  getTokenFromCode(r) {
    r === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(142, 2) : super.getTokenFromCode(r);
  }
  parseExprAtom(r) {
    return this.parsePlaceholder("Expression") || super.parseExprAtom(r);
  }
  parseIdentifier(r) {
    return this.parsePlaceholder("Identifier") || super.parseIdentifier(r);
  }
  checkReservedWord(r, i, s, n) {
    r !== void 0 && super.checkReservedWord(r, i, s, n);
  }
  parseBindingAtom() {
    return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
  }
  isValidLVal(r, i, s) {
    return r === "Placeholder" || super.isValidLVal(r, i, s);
  }
  toAssignable(r, i) {
    r && r.type === "Placeholder" && r.expectedNode === "Expression" ? r.expectedNode = "Pattern" : super.toAssignable(r, i);
  }
  chStartsBindingIdentifier(r, i) {
    return !!(super.chStartsBindingIdentifier(r, i) || this.lookahead().type === 142);
  }
  verifyBreakContinue(r, i) {
    r.label && r.label.type === "Placeholder" || super.verifyBreakContinue(r, i);
  }
  parseExpressionStatement(r, i) {
    if (i.type !== "Placeholder" || i.extra && i.extra.parenthesized)
      return super.parseExpressionStatement(r, i);
    if (this.match(14)) {
      const s = r;
      return s.label = this.finishPlaceholder(i, "Identifier"), this.next(), s.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(), this.finishNode(s, "LabeledStatement");
    }
    return this.semicolon(), r.name = i.name, this.finishPlaceholder(r, "Statement");
  }
  parseBlock(r, i, s) {
    return this.parsePlaceholder("BlockStatement") || super.parseBlock(r, i, s);
  }
  parseFunctionId(r) {
    return this.parsePlaceholder("Identifier") || super.parseFunctionId(r);
  }
  parseClass(r, i, s) {
    const n = i ? "ClassDeclaration" : "ClassExpression";
    this.next();
    const a = this.state.strict, o = this.parsePlaceholder("Identifier");
    if (o)
      if (this.match(81) || this.match(142) || this.match(5))
        r.id = o;
      else {
        if (s || !i)
          return r.id = null, r.body = this.finishPlaceholder(o, "ClassBody"), this.finishNode(r, n);
        throw this.raise(No.ClassNameIsRequired, {
          at: this.state.startLoc
        });
      }
    else
      this.parseClassId(r, i, s);
    return super.parseClassSuper(r), r.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!r.superClass, a), this.finishNode(r, n);
  }
  parseExport(r, i) {
    const s = this.parsePlaceholder("Identifier");
    if (!s)
      return super.parseExport(r, i);
    if (!this.isContextual(97) && !this.match(12))
      return r.specifiers = [], r.source = null, r.declaration = this.finishPlaceholder(s, "Declaration"), this.finishNode(r, "ExportNamedDeclaration");
    this.expectPlugin("exportDefaultFrom");
    const n = this.startNode();
    return n.exported = s, r.specifiers = [this.finishNode(n, "ExportDefaultSpecifier")], super.parseExport(r, i);
  }
  isExportDefaultSpecifier() {
    if (this.match(65)) {
      const r = this.nextTokenStart();
      if (this.isUnparsedContextual(r, "from") && this.input.startsWith(Ht(142), this.nextTokenStartSince(r + 4)))
        return !0;
    }
    return super.isExportDefaultSpecifier();
  }
  maybeParseExportDefaultSpecifier(r, i) {
    var s;
    return (s = r.specifiers) != null && s.length ? !0 : super.maybeParseExportDefaultSpecifier(r, i);
  }
  checkExport(r) {
    const {
      specifiers: i
    } = r;
    i != null && i.length && (r.specifiers = i.filter((s) => s.exported.type === "Placeholder")), super.checkExport(r), r.specifiers = i;
  }
  parseImport(r) {
    const i = this.parsePlaceholder("Identifier");
    if (!i)
      return super.parseImport(r);
    if (r.specifiers = [], !this.isContextual(97) && !this.match(12))
      return r.source = this.finishPlaceholder(i, "StringLiteral"), this.semicolon(), this.finishNode(r, "ImportDeclaration");
    const s = this.startNodeAtNode(i);
    return s.local = i, r.specifiers.push(this.finishNode(s, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(r) || this.parseNamedImportSpecifiers(r)), this.expectContextual(97), r.source = this.parseImportSource(), this.semicolon(), this.finishNode(r, "ImportDeclaration");
  }
  parseImportSource() {
    return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
  }
  assertNoSpace() {
    this.state.start > this.state.lastTokEndLoc.index && this.raise(No.UnexpectedSpace, {
      at: this.state.lastTokEndLoc
    });
  }
}, mT = (e) => class extends e {
  parseV8Intrinsic() {
    if (this.match(54)) {
      const r = this.state.startLoc, i = this.startNode();
      if (this.next(), ke(this.state.type)) {
        const s = this.parseIdentifierName(), n = this.createIdentifier(i, s);
        if (n.type = "V8IntrinsicIdentifier", this.match(10))
          return n;
      }
      this.unexpected(r);
    }
  }
  parseExprAtom(r) {
    return this.parseV8Intrinsic() || super.parseExprAtom(r);
  }
};
function Xe(e, t) {
  const [r, i] = typeof t == "string" ? [t, {}] : t, s = Object.keys(i), n = s.length === 0;
  return e.some((a) => {
    if (typeof a == "string")
      return n && a === r;
    {
      const [o, l] = a;
      if (o !== r)
        return !1;
      for (const u of s)
        if (l[u] !== i[u])
          return !1;
      return !0;
    }
  });
}
function ir(e, t, r) {
  const i = e.find((s) => Array.isArray(s) ? s[0] === t : s === t);
  return i && Array.isArray(i) && i.length > 1 ? i[1][r] : null;
}
const _o = ["minimal", "fsharp", "hack", "smart"], Do = ["^^", "@@", "^", "%", "#"], ko = ["hash", "bar"];
function yT(e) {
  if (Xe(e, "decorators")) {
    if (Xe(e, "decorators-legacy"))
      throw new Error("Cannot use the decorators and decorators-legacy plugin together");
    const t = ir(e, "decorators", "decoratorsBeforeExport");
    if (t != null && typeof t != "boolean")
      throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
    const r = ir(e, "decorators", "allowCallParenthesized");
    if (r != null && typeof r != "boolean")
      throw new Error("'allowCallParenthesized' must be a boolean.");
  }
  if (Xe(e, "flow") && Xe(e, "typescript"))
    throw new Error("Cannot combine flow and typescript plugins.");
  if (Xe(e, "placeholders") && Xe(e, "v8intrinsic"))
    throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
  if (Xe(e, "pipelineOperator")) {
    const t = ir(e, "pipelineOperator", "proposal");
    if (!_o.includes(t)) {
      const i = _o.map((s) => `"${s}"`).join(", ");
      throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${i}.`);
    }
    const r = Xe(e, ["recordAndTuple", {
      syntaxType: "hash"
    }]);
    if (t === "hack") {
      if (Xe(e, "placeholders"))
        throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
      if (Xe(e, "v8intrinsic"))
        throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
      const i = ir(e, "pipelineOperator", "topicToken");
      if (!Do.includes(i)) {
        const s = Do.map((n) => `"${n}"`).join(", ");
        throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${s}.`);
      }
      if (i === "#" && r)
        throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
    } else if (t === "smart" && r)
      throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
  }
  if (Xe(e, "moduleAttributes")) {
    if (Xe(e, "importAssertions") || Xe(e, "importAttributes"))
      throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
    if (ir(e, "moduleAttributes", "version") !== "may-2020")
      throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
  }
  if (Xe(e, "importAssertions") && Xe(e, "importAttributes"))
    throw new Error("Cannot combine importAssertions and importAttributes plugins.");
  if (Xe(e, "recordAndTuple") && ir(e, "recordAndTuple", "syntaxType") != null && !ko.includes(ir(e, "recordAndTuple", "syntaxType")))
    throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + ko.map((t) => `'${t}'`).join(", "));
  if (Xe(e, "asyncDoExpressions") && !Xe(e, "doExpressions")) {
    const t = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
    throw t.missingPlugins = "doExpressions", t;
  }
}
const fc = {
  estree: Km,
  jsx: tT,
  flow: Zy,
  typescript: cT,
  v8intrinsic: mT,
  placeholders: dT
}, TT = Object.keys(fc), Lo = {
  sourceType: "script",
  sourceFilename: void 0,
  startColumn: 0,
  startLine: 1,
  allowAwaitOutsideFunction: !1,
  allowReturnOutsideFunction: !1,
  allowNewTargetOutsideFunction: !1,
  allowImportExportEverywhere: !1,
  allowSuperOutsideMethod: !1,
  allowUndeclaredExports: !1,
  plugins: [],
  strictMode: null,
  ranges: !1,
  tokens: !1,
  createParenthesizedExpressions: !1,
  errorRecovery: !1,
  attachComment: !0,
  annexB: !0
};
function ST(e) {
  if (e && e.annexB != null && e.annexB !== !1)
    throw new Error("The `annexB` option can only be set to `false`.");
  const t = {};
  for (const r of Object.keys(Lo))
    t[r] = e && e[r] != null ? e[r] : Lo[r];
  return t;
}
class bT extends nT {
  checkProto(t, r, i, s) {
    if (t.type === "SpreadElement" || this.isObjectMethod(t) || t.computed || t.shorthand)
      return;
    const n = t.key;
    if ((n.type === "Identifier" ? n.name : n.value) === "__proto__") {
      if (r) {
        this.raise(N.RecordNoProto, {
          at: n
        });
        return;
      }
      i.used && (s ? s.doubleProtoLoc === null && (s.doubleProtoLoc = n.loc.start) : this.raise(N.DuplicateProto, {
        at: n
      })), i.used = !0;
    }
  }
  shouldExitDescending(t, r) {
    return t.type === "ArrowFunctionExpression" && t.start === r;
  }
  getExpression() {
    this.enterInitialScopes(), this.nextToken();
    const t = this.parseExpression();
    return this.match(137) || this.unexpected(), this.finalizeRemainingComments(), t.comments = this.state.comments, t.errors = this.state.errors, this.options.tokens && (t.tokens = this.tokens), t;
  }
  parseExpression(t, r) {
    return t ? this.disallowInAnd(() => this.parseExpressionBase(r)) : this.allowInAnd(() => this.parseExpressionBase(r));
  }
  parseExpressionBase(t) {
    const r = this.state.startLoc, i = this.parseMaybeAssign(t);
    if (this.match(12)) {
      const s = this.startNodeAt(r);
      for (s.expressions = [i]; this.eat(12); )
        s.expressions.push(this.parseMaybeAssign(t));
      return this.toReferencedList(s.expressions), this.finishNode(s, "SequenceExpression");
    }
    return i;
  }
  parseMaybeAssignDisallowIn(t, r) {
    return this.disallowInAnd(() => this.parseMaybeAssign(t, r));
  }
  parseMaybeAssignAllowIn(t, r) {
    return this.allowInAnd(() => this.parseMaybeAssign(t, r));
  }
  setOptionalParametersError(t, r) {
    var i;
    t.optionalParametersLoc = (i = r == null ? void 0 : r.loc) != null ? i : this.state.startLoc;
  }
  parseMaybeAssign(t, r) {
    const i = this.state.startLoc;
    if (this.isContextual(106) && this.prodParam.hasYield) {
      let o = this.parseYield();
      return r && (o = r.call(this, o, i)), o;
    }
    let s;
    t ? s = !1 : (t = new is(), s = !0);
    const {
      type: n
    } = this.state;
    (n === 10 || ke(n)) && (this.state.potentialArrowAt = this.state.start);
    let a = this.parseMaybeConditional(t);
    if (r && (a = r.call(this, a, i)), Jm(this.state.type)) {
      const o = this.startNodeAt(i), l = this.state.value;
      if (o.operator = l, this.match(29)) {
        this.toAssignable(a, !0), o.left = a;
        const u = i.index;
        t.doubleProtoLoc != null && t.doubleProtoLoc.index >= u && (t.doubleProtoLoc = null), t.shorthandAssignLoc != null && t.shorthandAssignLoc.index >= u && (t.shorthandAssignLoc = null), t.privateKeyLoc != null && t.privateKeyLoc.index >= u && (this.checkDestructuringPrivate(t), t.privateKeyLoc = null);
      } else
        o.left = a;
      return this.next(), o.right = this.parseMaybeAssign(), this.checkLVal(a, {
        in: this.finishNode(o, "AssignmentExpression")
      }), o;
    } else
      s && this.checkExpressionErrors(t, !0);
    return a;
  }
  parseMaybeConditional(t) {
    const r = this.state.startLoc, i = this.state.potentialArrowAt, s = this.parseExprOps(t);
    return this.shouldExitDescending(s, i) ? s : this.parseConditional(s, r, t);
  }
  parseConditional(t, r, i) {
    if (this.eat(17)) {
      const s = this.startNodeAt(r);
      return s.test = t, s.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), s.alternate = this.parseMaybeAssign(), this.finishNode(s, "ConditionalExpression");
    }
    return t;
  }
  parseMaybeUnaryOrPrivate(t) {
    return this.match(136) ? this.parsePrivateName() : this.parseMaybeUnary(t);
  }
  parseExprOps(t) {
    const r = this.state.startLoc, i = this.state.potentialArrowAt, s = this.parseMaybeUnaryOrPrivate(t);
    return this.shouldExitDescending(s, i) ? s : this.parseExprOp(s, r, -1);
  }
  parseExprOp(t, r, i) {
    if (this.isPrivateName(t)) {
      const n = this.getPrivateNameSV(t);
      (i >= Zi(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(N.PrivateInExpectedIn, {
        at: t,
        identifierName: n
      }), this.classScope.usePrivateName(n, t.loc.start);
    }
    const s = this.state.type;
    if (Gm(s) && (this.prodParam.hasIn || !this.match(58))) {
      let n = Zi(s);
      if (n > i) {
        if (s === 39) {
          if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
            return t;
          this.checkPipelineAtInfixOperator(t, r);
        }
        const a = this.startNodeAt(r);
        a.left = t, a.operator = this.state.value;
        const o = s === 41 || s === 42, l = s === 40;
        if (l && (n = Zi(42)), this.next(), s === 39 && this.hasPlugin(["pipelineOperator", {
          proposal: "minimal"
        }]) && this.state.type === 96 && this.prodParam.hasAwait)
          throw this.raise(N.UnexpectedAwaitAfterPipelineBody, {
            at: this.state.startLoc
          });
        a.right = this.parseExprOpRightExpr(s, n);
        const u = this.finishNode(a, o || l ? "LogicalExpression" : "BinaryExpression"), c = this.state.type;
        if (l && (c === 41 || c === 42) || o && c === 40)
          throw this.raise(N.MixingCoalesceWithLogical, {
            at: this.state.startLoc
          });
        return this.parseExprOp(u, r, i);
      }
    }
    return t;
  }
  parseExprOpRightExpr(t, r) {
    const i = this.state.startLoc;
    switch (t) {
      case 39:
        switch (this.getPluginOption("pipelineOperator", "proposal")) {
          case "hack":
            return this.withTopicBindingContext(() => this.parseHackPipeBody());
          case "smart":
            return this.withTopicBindingContext(() => {
              if (this.prodParam.hasYield && this.isContextual(106))
                throw this.raise(N.PipeBodyIsTighter, {
                  at: this.state.startLoc
                });
              return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(t, r), i);
            });
          case "fsharp":
            return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(r));
        }
      default:
        return this.parseExprOpBaseRightExpr(t, r);
    }
  }
  parseExprOpBaseRightExpr(t, r) {
    const i = this.state.startLoc;
    return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), i, ty(t) ? r - 1 : r);
  }
  parseHackPipeBody() {
    var t;
    const {
      startLoc: r
    } = this.state, i = this.parseMaybeAssign();
    return Fm.has(i.type) && !((t = i.extra) != null && t.parenthesized) && this.raise(N.PipeUnparenthesizedBody, {
      at: r,
      type: i.type
    }), this.topicReferenceWasUsedInCurrentContext() || this.raise(N.PipeTopicUnused, {
      at: r
    }), i;
  }
  checkExponentialAfterUnary(t) {
    this.match(57) && this.raise(N.UnexpectedTokenUnaryExponentiation, {
      at: t.argument
    });
  }
  parseMaybeUnary(t, r) {
    const i = this.state.startLoc, s = this.isContextual(96);
    if (s && this.isAwaitAllowed()) {
      this.next();
      const l = this.parseAwait(i);
      return r || this.checkExponentialAfterUnary(l), l;
    }
    const n = this.match(34), a = this.startNode();
    if (Qm(this.state.type)) {
      a.operator = this.state.value, a.prefix = !0, this.match(72) && this.expectPlugin("throwExpressions");
      const l = this.match(89);
      if (this.next(), a.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(t, !0), this.state.strict && l) {
        const u = a.argument;
        u.type === "Identifier" ? this.raise(N.StrictDelete, {
          at: a
        }) : this.hasPropertyAsPrivateName(u) && this.raise(N.DeletePrivateField, {
          at: a
        });
      }
      if (!n)
        return r || this.checkExponentialAfterUnary(a), this.finishNode(a, "UnaryExpression");
    }
    const o = this.parseUpdate(a, n, t);
    if (s) {
      const {
        type: l
      } = this.state;
      if ((this.hasPlugin("v8intrinsic") ? _n(l) : _n(l) && !this.match(54)) && !this.isAmbiguousAwait())
        return this.raiseOverwrite(N.AwaitNotInAsyncContext, {
          at: i
        }), this.parseAwait(i);
    }
    return o;
  }
  parseUpdate(t, r, i) {
    if (r) {
      const a = t;
      return this.checkLVal(a.argument, {
        in: this.finishNode(a, "UpdateExpression")
      }), t;
    }
    const s = this.state.startLoc;
    let n = this.parseExprSubscripts(i);
    if (this.checkExpressionErrors(i, !1))
      return n;
    for (; zm(this.state.type) && !this.canInsertSemicolon(); ) {
      const a = this.startNodeAt(s);
      a.operator = this.state.value, a.prefix = !1, a.argument = n, this.next(), this.checkLVal(n, {
        in: n = this.finishNode(a, "UpdateExpression")
      });
    }
    return n;
  }
  parseExprSubscripts(t) {
    const r = this.state.startLoc, i = this.state.potentialArrowAt, s = this.parseExprAtom(t);
    return this.shouldExitDescending(s, i) ? s : this.parseSubscripts(s, r);
  }
  parseSubscripts(t, r, i) {
    const s = {
      optionalChainMember: !1,
      maybeAsyncArrow: this.atPossibleAsyncArrow(t),
      stop: !1
    };
    do
      t = this.parseSubscript(t, r, i, s), s.maybeAsyncArrow = !1;
    while (!s.stop);
    return t;
  }
  parseSubscript(t, r, i, s) {
    const {
      type: n
    } = this.state;
    if (!i && n === 15)
      return this.parseBind(t, r, i, s);
    if (ls(n))
      return this.parseTaggedTemplateExpression(t, r, s);
    let a = !1;
    if (n === 18) {
      if (i && (this.raise(N.OptionalChainingNoNew, {
        at: this.state.startLoc
      }), this.lookaheadCharCode() === 40))
        return s.stop = !0, t;
      s.optionalChainMember = a = !0, this.next();
    }
    if (!i && this.match(10))
      return this.parseCoverCallAndAsyncArrowHead(t, r, s, a);
    {
      const o = this.eat(0);
      return o || a || this.eat(16) ? this.parseMember(t, r, s, o, a) : (s.stop = !0, t);
    }
  }
  parseMember(t, r, i, s, n) {
    const a = this.startNodeAt(r);
    return a.object = t, a.computed = s, s ? (a.property = this.parseExpression(), this.expect(3)) : this.match(136) ? (t.type === "Super" && this.raise(N.SuperPrivateField, {
      at: r
    }), this.classScope.usePrivateName(this.state.value, this.state.startLoc), a.property = this.parsePrivateName()) : a.property = this.parseIdentifier(!0), i.optionalChainMember ? (a.optional = n, this.finishNode(a, "OptionalMemberExpression")) : this.finishNode(a, "MemberExpression");
  }
  parseBind(t, r, i, s) {
    const n = this.startNodeAt(r);
    return n.object = t, this.next(), n.callee = this.parseNoCallExpr(), s.stop = !0, this.parseSubscripts(this.finishNode(n, "BindExpression"), r, i);
  }
  parseCoverCallAndAsyncArrowHead(t, r, i, s) {
    const n = this.state.maybeInArrowParameters;
    let a = null;
    this.state.maybeInArrowParameters = !0, this.next();
    const o = this.startNodeAt(r);
    o.callee = t;
    const {
      maybeAsyncArrow: l,
      optionalChainMember: u
    } = i;
    l && (this.expressionScope.enter(Vy()), a = new is()), u && (o.optional = s), s ? o.arguments = this.parseCallExpressionArguments(11) : o.arguments = this.parseCallExpressionArguments(11, t.type === "Import", t.type !== "Super", o, a);
    let c = this.finishCallExpression(o, u);
    return l && this.shouldParseAsyncArrow() && !s ? (i.stop = !0, this.checkDestructuringPrivate(a), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), c = this.parseAsyncArrowFromCallExpression(this.startNodeAt(r), c)) : (l && (this.checkExpressionErrors(a, !0), this.expressionScope.exit()), this.toReferencedArguments(c)), this.state.maybeInArrowParameters = n, c;
  }
  toReferencedArguments(t, r) {
    this.toReferencedListDeep(t.arguments, r);
  }
  parseTaggedTemplateExpression(t, r, i) {
    const s = this.startNodeAt(r);
    return s.tag = t, s.quasi = this.parseTemplate(!0), i.optionalChainMember && this.raise(N.OptionalChainingNoTemplate, {
      at: r
    }), this.finishNode(s, "TaggedTemplateExpression");
  }
  atPossibleAsyncArrow(t) {
    return t.type === "Identifier" && t.name === "async" && this.state.lastTokEndLoc.index === t.end && !this.canInsertSemicolon() && t.end - t.start === 5 && t.start === this.state.potentialArrowAt;
  }
  expectImportAttributesPlugin() {
    this.hasPlugin("importAssertions") || this.expectPlugin("importAttributes");
  }
  finishCallExpression(t, r) {
    if (t.callee.type === "Import")
      if (t.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectImportAttributesPlugin()), t.arguments.length === 0 || t.arguments.length > 2)
        this.raise(N.ImportCallArity, {
          at: t,
          maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1
        });
      else
        for (const i of t.arguments)
          i.type === "SpreadElement" && this.raise(N.ImportCallSpreadArgument, {
            at: i
          });
    return this.finishNode(t, r ? "OptionalCallExpression" : "CallExpression");
  }
  parseCallExpressionArguments(t, r, i, s, n) {
    const a = [];
    let o = !0;
    const l = this.state.inFSharpPipelineDirectBody;
    for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(t); ) {
      if (o)
        o = !1;
      else if (this.expect(12), this.match(t)) {
        r && !this.hasPlugin("importAttributes") && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes") && this.raise(N.ImportCallArgumentTrailingComma, {
          at: this.state.lastTokStartLoc
        }), s && this.addTrailingCommaExtraToNode(s), this.next();
        break;
      }
      a.push(this.parseExprListItem(!1, n, i));
    }
    return this.state.inFSharpPipelineDirectBody = l, a;
  }
  shouldParseAsyncArrow() {
    return this.match(19) && !this.canInsertSemicolon();
  }
  parseAsyncArrowFromCallExpression(t, r) {
    var i;
    return this.resetPreviousNodeTrailingComments(r), this.expect(19), this.parseArrowExpression(t, r.arguments, !0, (i = r.extra) == null ? void 0 : i.trailingCommaLoc), r.innerComments && ai(t, r.innerComments), r.callee.trailingComments && ai(t, r.callee.trailingComments), t;
  }
  parseNoCallExpr() {
    const t = this.state.startLoc;
    return this.parseSubscripts(this.parseExprAtom(), t, !0);
  }
  parseExprAtom(t) {
    let r, i = null;
    const {
      type: s
    } = this.state;
    switch (s) {
      case 79:
        return this.parseSuper();
      case 83:
        return r = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(r) : (this.match(10) || this.raise(N.UnsupportedImport, {
          at: this.state.lastTokStartLoc
        }), this.finishNode(r, "Import"));
      case 78:
        return r = this.startNode(), this.next(), this.finishNode(r, "ThisExpression");
      case 90:
        return this.parseDo(this.startNode(), !1);
      case 56:
      case 31:
        return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
      case 132:
        return this.parseNumericLiteral(this.state.value);
      case 133:
        return this.parseBigIntLiteral(this.state.value);
      case 134:
        return this.parseDecimalLiteral(this.state.value);
      case 131:
        return this.parseStringLiteral(this.state.value);
      case 84:
        return this.parseNullLiteral();
      case 85:
        return this.parseBooleanLiteral(!0);
      case 86:
        return this.parseBooleanLiteral(!1);
      case 10: {
        const n = this.state.potentialArrowAt === this.state.start;
        return this.parseParenAndDistinguishExpression(n);
      }
      case 2:
      case 1:
        return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0);
      case 0:
        return this.parseArrayLike(3, !0, !1, t);
      case 6:
      case 7:
        return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0);
      case 5:
        return this.parseObjectLike(8, !1, !1, t);
      case 68:
        return this.parseFunctionOrFunctionSent();
      case 26:
        i = this.parseDecorators();
      case 80:
        return this.parseClass(this.maybeTakeDecorators(i, this.startNode()), !1);
      case 77:
        return this.parseNewOrNewTarget();
      case 25:
      case 24:
        return this.parseTemplate(!1);
      case 15: {
        r = this.startNode(), this.next(), r.object = null;
        const n = r.callee = this.parseNoCallExpr();
        if (n.type === "MemberExpression")
          return this.finishNode(r, "BindExpression");
        throw this.raise(N.UnsupportedBind, {
          at: n
        });
      }
      case 136:
        return this.raise(N.PrivateInExpectedIn, {
          at: this.state.startLoc,
          identifierName: this.state.value
        }), this.parsePrivateName();
      case 33:
        return this.parseTopicReferenceThenEqualsSign(54, "%");
      case 32:
        return this.parseTopicReferenceThenEqualsSign(44, "^");
      case 37:
      case 38:
        return this.parseTopicReference("hack");
      case 44:
      case 54:
      case 27: {
        const n = this.getPluginOption("pipelineOperator", "proposal");
        if (n)
          return this.parseTopicReference(n);
        this.unexpected();
        break;
      }
      case 47: {
        const n = this.input.codePointAt(this.nextTokenStart());
        Dt(n) || n === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
        break;
      }
      default:
        if (ke(s)) {
          if (this.isContextual(125) && this.lookaheadInLineCharCode() === 123)
            return this.parseModuleExpression();
          const n = this.state.potentialArrowAt === this.state.start, a = this.state.containsEsc, o = this.parseIdentifier();
          if (!a && o.name === "async" && !this.canInsertSemicolon()) {
            const {
              type: l
            } = this.state;
            if (l === 68)
              return this.resetPreviousNodeTrailingComments(o), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(o));
            if (ke(l))
              return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(o)) : o;
            if (l === 90)
              return this.resetPreviousNodeTrailingComments(o), this.parseDo(this.startNodeAtNode(o), !0);
          }
          return n && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(o), [o], !1)) : o;
        } else
          this.unexpected();
    }
  }
  parseTopicReferenceThenEqualsSign(t, r) {
    const i = this.getPluginOption("pipelineOperator", "proposal");
    if (i)
      return this.state.type = t, this.state.value = r, this.state.pos--, this.state.end--, this.state.endLoc = nt(this.state.endLoc, -1), this.parseTopicReference(i);
    this.unexpected();
  }
  parseTopicReference(t) {
    const r = this.startNode(), i = this.state.startLoc, s = this.state.type;
    return this.next(), this.finishTopicReference(r, i, t, s);
  }
  finishTopicReference(t, r, i, s) {
    if (this.testTopicReferenceConfiguration(i, r, s)) {
      const n = i === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
      return this.topicReferenceIsAllowedInCurrentContext() || this.raise(i === "smart" ? N.PrimaryTopicNotAllowed : N.PipeTopicUnbound, {
        at: r
      }), this.registerTopicReference(), this.finishNode(t, n);
    } else
      throw this.raise(N.PipeTopicUnconfiguredToken, {
        at: r,
        token: Ht(s)
      });
  }
  testTopicReferenceConfiguration(t, r, i) {
    switch (t) {
      case "hack":
        return this.hasPlugin(["pipelineOperator", {
          topicToken: Ht(i)
        }]);
      case "smart":
        return i === 27;
      default:
        throw this.raise(N.PipeTopicRequiresHackPipes, {
          at: r
        });
    }
  }
  parseAsyncArrowUnaryFunction(t) {
    this.prodParam.enter(rs(!0, this.prodParam.hasYield));
    const r = [this.parseIdentifier()];
    return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(N.LineTerminatorBeforeArrow, {
      at: this.state.curPosition()
    }), this.expect(19), this.parseArrowExpression(t, r, !0);
  }
  parseDo(t, r) {
    this.expectPlugin("doExpressions"), r && this.expectPlugin("asyncDoExpressions"), t.async = r, this.next();
    const i = this.state.labels;
    return this.state.labels = [], r ? (this.prodParam.enter(gs), t.body = this.parseBlock(), this.prodParam.exit()) : t.body = this.parseBlock(), this.state.labels = i, this.finishNode(t, "DoExpression");
  }
  parseSuper() {
    const t = this.startNode();
    return this.next(), this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod ? this.raise(N.SuperNotAllowed, {
      at: t
    }) : !this.scope.allowSuper && !this.options.allowSuperOutsideMethod && this.raise(N.UnexpectedSuper, {
      at: t
    }), !this.match(10) && !this.match(0) && !this.match(16) && this.raise(N.UnsupportedSuper, {
      at: t
    }), this.finishNode(t, "Super");
  }
  parsePrivateName() {
    const t = this.startNode(), r = this.startNodeAt(nt(this.state.startLoc, 1)), i = this.state.value;
    return this.next(), t.id = this.createIdentifier(r, i), this.finishNode(t, "PrivateName");
  }
  parseFunctionOrFunctionSent() {
    const t = this.startNode();
    if (this.next(), this.prodParam.hasYield && this.match(16)) {
      const r = this.createIdentifier(this.startNodeAtNode(t), "function");
      return this.next(), this.match(102) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(t, r, "sent");
    }
    return this.parseFunction(t);
  }
  parseMetaProperty(t, r, i) {
    t.meta = r;
    const s = this.state.containsEsc;
    return t.property = this.parseIdentifier(!0), (t.property.name !== i || s) && this.raise(N.UnsupportedMetaProperty, {
      at: t.property,
      target: r.name,
      onlyValidPropertyName: i
    }), this.finishNode(t, "MetaProperty");
  }
  parseImportMetaProperty(t) {
    const r = this.createIdentifier(this.startNodeAtNode(t), "import");
    return this.next(), this.isContextual(100) && (this.inModule || this.raise(N.ImportMetaOutsideModule, {
      at: r
    }), this.sawUnambiguousESM = !0), this.parseMetaProperty(t, r, "meta");
  }
  parseLiteralAtNode(t, r, i) {
    return this.addExtra(i, "rawValue", t), this.addExtra(i, "raw", this.input.slice(i.start, this.state.end)), i.value = t, this.next(), this.finishNode(i, r);
  }
  parseLiteral(t, r) {
    const i = this.startNode();
    return this.parseLiteralAtNode(t, r, i);
  }
  parseStringLiteral(t) {
    return this.parseLiteral(t, "StringLiteral");
  }
  parseNumericLiteral(t) {
    return this.parseLiteral(t, "NumericLiteral");
  }
  parseBigIntLiteral(t) {
    return this.parseLiteral(t, "BigIntLiteral");
  }
  parseDecimalLiteral(t) {
    return this.parseLiteral(t, "DecimalLiteral");
  }
  parseRegExpLiteral(t) {
    const r = this.parseLiteral(t.value, "RegExpLiteral");
    return r.pattern = t.pattern, r.flags = t.flags, r;
  }
  parseBooleanLiteral(t) {
    const r = this.startNode();
    return r.value = t, this.next(), this.finishNode(r, "BooleanLiteral");
  }
  parseNullLiteral() {
    const t = this.startNode();
    return this.next(), this.finishNode(t, "NullLiteral");
  }
  parseParenAndDistinguishExpression(t) {
    const r = this.state.startLoc;
    let i;
    this.next(), this.expressionScope.enter(Uy());
    const s = this.state.maybeInArrowParameters, n = this.state.inFSharpPipelineDirectBody;
    this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
    const a = this.state.startLoc, o = [], l = new is();
    let u = !0, c, p;
    for (; !this.match(11); ) {
      if (u)
        u = !1;
      else if (this.expect(12, l.optionalParametersLoc === null ? null : l.optionalParametersLoc), this.match(11)) {
        p = this.state.startLoc;
        break;
      }
      if (this.match(21)) {
        const P = this.state.startLoc;
        if (c = this.state.startLoc, o.push(this.parseParenItem(this.parseRestBinding(), P)), !this.checkCommaAfterRest(41))
          break;
      } else
        o.push(this.parseMaybeAssignAllowIn(l, this.parseParenItem));
    }
    const h = this.state.lastTokEndLoc;
    this.expect(11), this.state.maybeInArrowParameters = s, this.state.inFSharpPipelineDirectBody = n;
    let y = this.startNodeAt(r);
    return t && this.shouldParseArrow(o) && (y = this.parseArrow(y)) ? (this.checkDestructuringPrivate(l), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(y, o, !1), y) : (this.expressionScope.exit(), o.length || this.unexpected(this.state.lastTokStartLoc), p && this.unexpected(p), c && this.unexpected(c), this.checkExpressionErrors(l, !0), this.toReferencedListDeep(o, !0), o.length > 1 ? (i = this.startNodeAt(a), i.expressions = o, this.finishNode(i, "SequenceExpression"), this.resetEndLocation(i, h)) : i = o[0], this.wrapParenthesis(r, i));
  }
  wrapParenthesis(t, r) {
    if (!this.options.createParenthesizedExpressions)
      return this.addExtra(r, "parenthesized", !0), this.addExtra(r, "parenStart", t.index), this.takeSurroundingComments(r, t.index, this.state.lastTokEndLoc.index), r;
    const i = this.startNodeAt(t);
    return i.expression = r, this.finishNode(i, "ParenthesizedExpression");
  }
  shouldParseArrow(t) {
    return !this.canInsertSemicolon();
  }
  parseArrow(t) {
    if (this.eat(19))
      return t;
  }
  parseParenItem(t, r) {
    return t;
  }
  parseNewOrNewTarget() {
    const t = this.startNode();
    if (this.next(), this.match(16)) {
      const r = this.createIdentifier(this.startNodeAtNode(t), "new");
      this.next();
      const i = this.parseMetaProperty(t, r, "target");
      return !this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction && this.raise(N.UnexpectedNewTarget, {
        at: i
      }), i;
    }
    return this.parseNew(t);
  }
  parseNew(t) {
    if (this.parseNewCallee(t), this.eat(10)) {
      const r = this.parseExprList(11);
      this.toReferencedList(r), t.arguments = r;
    } else
      t.arguments = [];
    return this.finishNode(t, "NewExpression");
  }
  parseNewCallee(t) {
    t.callee = this.parseNoCallExpr(), t.callee.type === "Import" && this.raise(N.ImportCallNotNewExpression, {
      at: t.callee
    });
  }
  parseTemplateElement(t) {
    const {
      start: r,
      startLoc: i,
      end: s,
      value: n
    } = this.state, a = r + 1, o = this.startNodeAt(nt(i, 1));
    n === null && (t || this.raise(N.InvalidEscapeSequenceTemplate, {
      at: nt(this.state.firstInvalidTemplateEscapePos, 1)
    }));
    const l = this.match(24), u = l ? -1 : -2, c = s + u;
    o.value = {
      raw: this.input.slice(a, c).replace(/\r\n?/g, `
`),
      cooked: n === null ? null : n.slice(1, u)
    }, o.tail = l, this.next();
    const p = this.finishNode(o, "TemplateElement");
    return this.resetEndLocation(p, nt(this.state.lastTokEndLoc, u)), p;
  }
  parseTemplate(t) {
    const r = this.startNode();
    r.expressions = [];
    let i = this.parseTemplateElement(t);
    for (r.quasis = [i]; !i.tail; )
      r.expressions.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), r.quasis.push(i = this.parseTemplateElement(t));
    return this.finishNode(r, "TemplateLiteral");
  }
  parseTemplateSubstitution() {
    return this.parseExpression();
  }
  parseObjectLike(t, r, i, s) {
    i && this.expectPlugin("recordAndTuple");
    const n = this.state.inFSharpPipelineDirectBody;
    this.state.inFSharpPipelineDirectBody = !1;
    const a = /* @__PURE__ */ Object.create(null);
    let o = !0;
    const l = this.startNode();
    for (l.properties = [], this.next(); !this.match(t); ) {
      if (o)
        o = !1;
      else if (this.expect(12), this.match(t)) {
        this.addTrailingCommaExtraToNode(l);
        break;
      }
      let c;
      r ? c = this.parseBindingProperty() : (c = this.parsePropertyDefinition(s), this.checkProto(c, i, a, s)), i && !this.isObjectProperty(c) && c.type !== "SpreadElement" && this.raise(N.InvalidRecordProperty, {
        at: c
      }), c.shorthand && this.addExtra(c, "shorthand", !0), l.properties.push(c);
    }
    this.next(), this.state.inFSharpPipelineDirectBody = n;
    let u = "ObjectExpression";
    return r ? u = "ObjectPattern" : i && (u = "RecordExpression"), this.finishNode(l, u);
  }
  addTrailingCommaExtraToNode(t) {
    this.addExtra(t, "trailingComma", this.state.lastTokStart), this.addExtra(t, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
  }
  maybeAsyncOrAccessorProp(t) {
    return !t.computed && t.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
  }
  parsePropertyDefinition(t) {
    let r = [];
    if (this.match(26))
      for (this.hasPlugin("decorators") && this.raise(N.UnsupportedPropertyDecorator, {
        at: this.state.startLoc
      }); this.match(26); )
        r.push(this.parseDecorator());
    const i = this.startNode();
    let s = !1, n = !1, a;
    if (this.match(21))
      return r.length && this.unexpected(), this.parseSpread();
    r.length && (i.decorators = r, r = []), i.method = !1, t && (a = this.state.startLoc);
    let o = this.eat(55);
    this.parsePropertyNamePrefixOperator(i);
    const l = this.state.containsEsc, u = this.parsePropertyName(i, t);
    if (!o && !l && this.maybeAsyncOrAccessorProp(i)) {
      const c = u.name;
      c === "async" && !this.hasPrecedingLineBreak() && (s = !0, this.resetPreviousNodeTrailingComments(u), o = this.eat(55), this.parsePropertyName(i)), (c === "get" || c === "set") && (n = !0, this.resetPreviousNodeTrailingComments(u), i.kind = c, this.match(55) && (o = !0, this.raise(N.AccessorIsGenerator, {
        at: this.state.curPosition(),
        kind: c
      }), this.next()), this.parsePropertyName(i));
    }
    return this.parseObjPropValue(i, a, o, s, !1, n, t);
  }
  getGetterSetterExpectedParamCount(t) {
    return t.kind === "get" ? 0 : 1;
  }
  getObjectOrClassMethodParams(t) {
    return t.params;
  }
  checkGetterSetterParams(t) {
    var r;
    const i = this.getGetterSetterExpectedParamCount(t), s = this.getObjectOrClassMethodParams(t);
    s.length !== i && this.raise(t.kind === "get" ? N.BadGetterArity : N.BadSetterArity, {
      at: t
    }), t.kind === "set" && ((r = s[s.length - 1]) == null ? void 0 : r.type) === "RestElement" && this.raise(N.BadSetterRestParameter, {
      at: t
    });
  }
  parseObjectMethod(t, r, i, s, n) {
    if (n) {
      const a = this.parseMethod(t, r, !1, !1, !1, "ObjectMethod");
      return this.checkGetterSetterParams(a), a;
    }
    if (i || r || this.match(10))
      return s && this.unexpected(), t.kind = "method", t.method = !0, this.parseMethod(t, r, i, !1, !1, "ObjectMethod");
  }
  parseObjectProperty(t, r, i, s) {
    if (t.shorthand = !1, this.eat(14))
      return t.value = i ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(s), this.finishNode(t, "ObjectProperty");
    if (!t.computed && t.key.type === "Identifier") {
      if (this.checkReservedWord(t.key.name, t.key.loc.start, !0, !1), i)
        t.value = this.parseMaybeDefault(r, Bt(t.key));
      else if (this.match(29)) {
        const n = this.state.startLoc;
        s != null ? s.shorthandAssignLoc === null && (s.shorthandAssignLoc = n) : this.raise(N.InvalidCoverInitializedName, {
          at: n
        }), t.value = this.parseMaybeDefault(r, Bt(t.key));
      } else
        t.value = Bt(t.key);
      return t.shorthand = !0, this.finishNode(t, "ObjectProperty");
    }
  }
  parseObjPropValue(t, r, i, s, n, a, o) {
    const l = this.parseObjectMethod(t, i, s, n, a) || this.parseObjectProperty(t, r, n, o);
    return l || this.unexpected(), l;
  }
  parsePropertyName(t, r) {
    if (this.eat(0))
      t.computed = !0, t.key = this.parseMaybeAssignAllowIn(), this.expect(3);
    else {
      const {
        type: i,
        value: s
      } = this.state;
      let n;
      if (bt(i))
        n = this.parseIdentifier(!0);
      else
        switch (i) {
          case 132:
            n = this.parseNumericLiteral(s);
            break;
          case 131:
            n = this.parseStringLiteral(s);
            break;
          case 133:
            n = this.parseBigIntLiteral(s);
            break;
          case 134:
            n = this.parseDecimalLiteral(s);
            break;
          case 136: {
            const a = this.state.startLoc;
            r != null ? r.privateKeyLoc === null && (r.privateKeyLoc = a) : this.raise(N.UnexpectedPrivateField, {
              at: a
            }), n = this.parsePrivateName();
            break;
          }
          default:
            this.unexpected();
        }
      t.key = n, i !== 136 && (t.computed = !1);
    }
    return t.key;
  }
  initFunction(t, r) {
    t.id = null, t.generator = !1, t.async = r;
  }
  parseMethod(t, r, i, s, n, a, o = !1) {
    this.initFunction(t, i), t.generator = r, this.scope.enter(Mt | us | (o ? ar : 0) | (n ? Yu : 0)), this.prodParam.enter(rs(i, t.generator)), this.parseFunctionParams(t, s);
    const l = this.parseFunctionBodyAndFinish(t, a, !0);
    return this.prodParam.exit(), this.scope.exit(), l;
  }
  parseArrayLike(t, r, i, s) {
    i && this.expectPlugin("recordAndTuple");
    const n = this.state.inFSharpPipelineDirectBody;
    this.state.inFSharpPipelineDirectBody = !1;
    const a = this.startNode();
    return this.next(), a.elements = this.parseExprList(t, !i, s, a), this.state.inFSharpPipelineDirectBody = n, this.finishNode(a, i ? "TupleExpression" : "ArrayExpression");
  }
  parseArrowExpression(t, r, i, s) {
    this.scope.enter(Mt | la);
    let n = rs(i, !1);
    !this.match(5) && this.prodParam.hasIn && (n |= xr), this.prodParam.enter(n), this.initFunction(t, i);
    const a = this.state.maybeInArrowParameters;
    return r && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(t, r, s)), this.state.maybeInArrowParameters = !1, this.parseFunctionBody(t, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = a, this.finishNode(t, "ArrowFunctionExpression");
  }
  setArrowFunctionParameters(t, r, i) {
    this.toAssignableList(r, i, !1), t.params = r;
  }
  parseFunctionBodyAndFinish(t, r, i = !1) {
    return this.parseFunctionBody(t, !1, i), this.finishNode(t, r);
  }
  parseFunctionBody(t, r, i = !1) {
    const s = r && !this.match(5);
    if (this.expressionScope.enter(nc()), s)
      t.body = this.parseMaybeAssign(), this.checkParams(t, !1, r, !1);
    else {
      const n = this.state.strict, a = this.state.labels;
      this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | oc), t.body = this.parseBlock(!0, !1, (o) => {
        const l = !this.isSimpleParamList(t.params);
        o && l && this.raise(N.IllegalLanguageModeDirective, {
          at: (t.kind === "method" || t.kind === "constructor") && t.key ? t.key.loc.end : t
        });
        const u = !n && this.state.strict;
        this.checkParams(t, !this.state.strict && !r && !i && !l, r, u), this.state.strict && t.id && this.checkIdentifier(t.id, my, u);
      }), this.prodParam.exit(), this.state.labels = a;
    }
    this.expressionScope.exit();
  }
  isSimpleParameter(t) {
    return t.type === "Identifier";
  }
  isSimpleParamList(t) {
    for (let r = 0, i = t.length; r < i; r++)
      if (!this.isSimpleParameter(t[r]))
        return !1;
    return !0;
  }
  checkParams(t, r, i, s = !0) {
    const n = !r && /* @__PURE__ */ new Set(), a = {
      type: "FormalParameters"
    };
    for (const o of t.params)
      this.checkLVal(o, {
        in: a,
        binding: ps,
        checkClashes: n,
        strictModeChanged: s
      });
  }
  parseExprList(t, r, i, s) {
    const n = [];
    let a = !0;
    for (; !this.eat(t); ) {
      if (a)
        a = !1;
      else if (this.expect(12), this.match(t)) {
        s && this.addTrailingCommaExtraToNode(s), this.next();
        break;
      }
      n.push(this.parseExprListItem(r, i));
    }
    return n;
  }
  parseExprListItem(t, r, i) {
    let s;
    if (this.match(12))
      t || this.raise(N.UnexpectedToken, {
        at: this.state.curPosition(),
        unexpected: ","
      }), s = null;
    else if (this.match(21)) {
      const n = this.state.startLoc;
      s = this.parseParenItem(this.parseSpread(r), n);
    } else if (this.match(17)) {
      this.expectPlugin("partialApplication"), i || this.raise(N.UnexpectedArgumentPlaceholder, {
        at: this.state.startLoc
      });
      const n = this.startNode();
      this.next(), s = this.finishNode(n, "ArgumentPlaceholder");
    } else
      s = this.parseMaybeAssignAllowIn(r, this.parseParenItem);
    return s;
  }
  parseIdentifier(t) {
    const r = this.startNode(), i = this.parseIdentifierName(t);
    return this.createIdentifier(r, i);
  }
  createIdentifier(t, r) {
    return t.name = r, t.loc.identifierName = r, this.finishNode(t, "Identifier");
  }
  parseIdentifierName(t) {
    let r;
    const {
      startLoc: i,
      type: s
    } = this.state;
    bt(s) ? r = this.state.value : this.unexpected();
    const n = Ym(s);
    return t ? n && this.replaceToken(130) : this.checkReservedWord(r, i, n, !1), this.next(), r;
  }
  checkReservedWord(t, r, i, s) {
    if (t.length > 10 || !fy(t))
      return;
    if (i && ly(t)) {
      this.raise(N.UnexpectedKeyword, {
        at: r,
        keyword: t
      });
      return;
    }
    if ((this.state.strict ? s ? qu : Vu : Uu)(t, this.inModule)) {
      this.raise(N.UnexpectedReservedWord, {
        at: r,
        reservedWord: t
      });
      return;
    } else if (t === "yield") {
      if (this.prodParam.hasYield) {
        this.raise(N.YieldBindingIdentifier, {
          at: r
        });
        return;
      }
    } else if (t === "await") {
      if (this.prodParam.hasAwait) {
        this.raise(N.AwaitBindingIdentifier, {
          at: r
        });
        return;
      }
      if (this.scope.inStaticBlock) {
        this.raise(N.AwaitBindingIdentifierInStaticBlock, {
          at: r
        });
        return;
      }
      this.expressionScope.recordAsyncArrowParametersError({
        at: r
      });
    } else if (t === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
      this.raise(N.ArgumentsInClass, {
        at: r
      });
      return;
    }
  }
  isAwaitAllowed() {
    return !!(this.prodParam.hasAwait || this.options.allowAwaitOutsideFunction && !this.scope.inFunction);
  }
  parseAwait(t) {
    const r = this.startNodeAt(t);
    return this.expressionScope.recordParameterInitializerError(N.AwaitExpressionFormalParameter, {
      at: r
    }), this.eat(55) && this.raise(N.ObsoleteAwaitStar, {
      at: r
    }), !this.scope.inFunction && !this.options.allowAwaitOutsideFunction && (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = !0 : this.sawUnambiguousESM = !0), this.state.soloAwait || (r.argument = this.parseMaybeUnary(null, !0)), this.finishNode(r, "AwaitExpression");
  }
  isAmbiguousAwait() {
    if (this.hasPrecedingLineBreak())
      return !0;
    const {
      type: t
    } = this.state;
    return t === 53 || t === 10 || t === 0 || ls(t) || t === 101 && !this.state.containsEsc || t === 135 || t === 56 || this.hasPlugin("v8intrinsic") && t === 54;
  }
  parseYield() {
    const t = this.startNode();
    this.expressionScope.recordParameterInitializerError(N.YieldInParameter, {
      at: t
    }), this.next();
    let r = !1, i = null;
    if (!this.hasPrecedingLineBreak())
      switch (r = this.eat(55), this.state.type) {
        case 13:
        case 137:
        case 8:
        case 11:
        case 3:
        case 9:
        case 14:
        case 12:
          if (!r)
            break;
        default:
          i = this.parseMaybeAssign();
      }
    return t.delegate = r, t.argument = i, this.finishNode(t, "YieldExpression");
  }
  checkPipelineAtInfixOperator(t, r) {
    this.hasPlugin(["pipelineOperator", {
      proposal: "smart"
    }]) && t.type === "SequenceExpression" && this.raise(N.PipelineHeadSequenceExpression, {
      at: r
    });
  }
  parseSmartPipelineBodyInStyle(t, r) {
    if (this.isSimpleReference(t)) {
      const i = this.startNodeAt(r);
      return i.callee = t, this.finishNode(i, "PipelineBareFunction");
    } else {
      const i = this.startNodeAt(r);
      return this.checkSmartPipeTopicBodyEarlyErrors(r), i.expression = t, this.finishNode(i, "PipelineTopicExpression");
    }
  }
  isSimpleReference(t) {
    switch (t.type) {
      case "MemberExpression":
        return !t.computed && this.isSimpleReference(t.object);
      case "Identifier":
        return !0;
      default:
        return !1;
    }
  }
  checkSmartPipeTopicBodyEarlyErrors(t) {
    if (this.match(19))
      throw this.raise(N.PipelineBodyNoArrow, {
        at: this.state.startLoc
      });
    this.topicReferenceWasUsedInCurrentContext() || this.raise(N.PipelineTopicUnused, {
      at: t
    });
  }
  withTopicBindingContext(t) {
    const r = this.state.topicContext;
    this.state.topicContext = {
      maxNumOfResolvableTopics: 1,
      maxTopicIndex: null
    };
    try {
      return t();
    } finally {
      this.state.topicContext = r;
    }
  }
  withSmartMixTopicForbiddingContext(t) {
    if (this.hasPlugin(["pipelineOperator", {
      proposal: "smart"
    }])) {
      const r = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      };
      try {
        return t();
      } finally {
        this.state.topicContext = r;
      }
    } else
      return t();
  }
  withSoloAwaitPermittingContext(t) {
    const r = this.state.soloAwait;
    this.state.soloAwait = !0;
    try {
      return t();
    } finally {
      this.state.soloAwait = r;
    }
  }
  allowInAnd(t) {
    const r = this.prodParam.currentFlags();
    if (xr & ~r) {
      this.prodParam.enter(r | xr);
      try {
        return t();
      } finally {
        this.prodParam.exit();
      }
    }
    return t();
  }
  disallowInAnd(t) {
    const r = this.prodParam.currentFlags();
    if (xr & r) {
      this.prodParam.enter(r & ~xr);
      try {
        return t();
      } finally {
        this.prodParam.exit();
      }
    }
    return t();
  }
  registerTopicReference() {
    this.state.topicContext.maxTopicIndex = 0;
  }
  topicReferenceIsAllowedInCurrentContext() {
    return this.state.topicContext.maxNumOfResolvableTopics >= 1;
  }
  topicReferenceWasUsedInCurrentContext() {
    return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
  }
  parseFSharpPipelineBody(t) {
    const r = this.state.startLoc;
    this.state.potentialArrowAt = this.state.start;
    const i = this.state.inFSharpPipelineDirectBody;
    this.state.inFSharpPipelineDirectBody = !0;
    const s = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r, t);
    return this.state.inFSharpPipelineDirectBody = i, s;
  }
  parseModuleExpression() {
    this.expectPlugin("moduleBlocks");
    const t = this.startNode();
    this.next(), this.match(5) || this.unexpected(null, 5);
    const r = this.startNodeAt(this.state.endLoc);
    this.next();
    const i = this.initializeScopes(!0);
    this.enterInitialScopes();
    try {
      t.body = this.parseProgram(r, 8, "module");
    } finally {
      i();
    }
    return this.finishNode(t, "ModuleExpression");
  }
  parsePropertyNamePrefixOperator(t) {
  }
}
const cn = {
  kind: "loop"
}, gT = {
  kind: "switch"
}, ET = /[\uD800-\uDFFF]/u, fn = /in(?:stanceof)?/y;
function PT(e, t) {
  for (let r = 0; r < e.length; r++) {
    const i = e[r], {
      type: s
    } = i;
    if (typeof s == "number") {
      {
        if (s === 136) {
          const {
            loc: n,
            start: a,
            value: o,
            end: l
          } = i, u = a + 1, c = nt(n.start, 1);
          e.splice(r, 1, new qt({
            type: Ot(27),
            value: "#",
            start: a,
            end: u,
            startLoc: n.start,
            endLoc: c
          }), new qt({
            type: Ot(130),
            value: o,
            start: u,
            end: l,
            startLoc: c,
            endLoc: n.end
          })), r++;
          continue;
        }
        if (ls(s)) {
          const {
            loc: n,
            start: a,
            value: o,
            end: l
          } = i, u = a + 1, c = nt(n.start, 1);
          let p;
          t.charCodeAt(a) === 96 ? p = new qt({
            type: Ot(22),
            value: "`",
            start: a,
            end: u,
            startLoc: n.start,
            endLoc: c
          }) : p = new qt({
            type: Ot(8),
            value: "}",
            start: a,
            end: u,
            startLoc: n.start,
            endLoc: c
          });
          let h, y, P, v;
          s === 24 ? (y = l - 1, P = nt(n.end, -1), h = o === null ? null : o.slice(1, -1), v = new qt({
            type: Ot(22),
            value: "`",
            start: y,
            end: l,
            startLoc: P,
            endLoc: n.end
          })) : (y = l - 2, P = nt(n.end, -2), h = o === null ? null : o.slice(1, -2), v = new qt({
            type: Ot(23),
            value: "${",
            start: y,
            end: l,
            startLoc: P,
            endLoc: n.end
          })), e.splice(r, 1, p, new qt({
            type: Ot(20),
            value: h,
            start: u,
            end: y,
            startLoc: c,
            endLoc: P
          }), v), r += 2;
          continue;
        }
      }
      i.type = Ot(s);
    }
  }
  return e;
}
class xT extends bT {
  parseTopLevel(t, r) {
    return t.program = this.parseProgram(r), t.comments = this.state.comments, this.options.tokens && (t.tokens = PT(this.tokens, this.input)), this.finishNode(t, "File");
  }
  parseProgram(t, r = 137, i = this.options.sourceType) {
    if (t.sourceType = i, t.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(t, !0, !0, r), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
      for (const [n, a] of Array.from(this.scope.undefinedExports))
        this.raise(N.ModuleExportUndefined, {
          at: a,
          localName: n
        });
    let s;
    return r === 137 ? s = this.finishNode(t, "Program") : s = this.finishNodeAt(t, "Program", nt(this.state.startLoc, -1)), s;
  }
  stmtToDirective(t) {
    const r = t;
    r.type = "Directive", r.value = r.expression, delete r.expression;
    const i = r.value, s = i.value, n = this.input.slice(i.start, i.end), a = i.value = n.slice(1, -1);
    return this.addExtra(i, "raw", n), this.addExtra(i, "rawValue", a), this.addExtra(i, "expressionValue", s), i.type = "DirectiveLiteral", r;
  }
  parseInterpreterDirective() {
    if (!this.match(28))
      return null;
    const t = this.startNode();
    return t.value = this.state.value, this.next(), this.finishNode(t, "InterpreterDirective");
  }
  isLet() {
    return this.isContextual(99) ? this.hasFollowingBindingAtom() : !1;
  }
  chStartsBindingIdentifier(t, r) {
    if (Dt(t)) {
      if (fn.lastIndex = r, fn.test(this.input)) {
        const i = this.codePointAtPos(fn.lastIndex);
        if (!Nr(i) && i !== 92)
          return !1;
      }
      return !0;
    } else
      return t === 92;
  }
  chStartsBindingPattern(t) {
    return t === 91 || t === 123;
  }
  hasFollowingBindingAtom() {
    const t = this.nextTokenStart(), r = this.codePointAtPos(t);
    return this.chStartsBindingPattern(r) || this.chStartsBindingIdentifier(r, t);
  }
  hasInLineFollowingBindingIdentifier() {
    const t = this.nextTokenInLineStart(), r = this.codePointAtPos(t);
    return this.chStartsBindingIdentifier(r, t);
  }
  startsUsingForOf() {
    const {
      type: t,
      containsEsc: r
    } = this.lookahead();
    if (t === 101 && !r)
      return !1;
    if (ke(t) && !this.hasFollowingLineBreak())
      return this.expectPlugin("explicitResourceManagement"), !0;
  }
  startsAwaitUsing() {
    let t = this.nextTokenInLineStart();
    if (this.isUnparsedContextual(t, "using")) {
      t = this.nextTokenInLineStartSince(t + 5);
      const r = this.codePointAtPos(t);
      if (this.chStartsBindingIdentifier(r, t))
        return this.expectPlugin("explicitResourceManagement"), !0;
    }
    return !1;
  }
  parseModuleItem() {
    return this.parseStatementLike(15);
  }
  parseStatementListItem() {
    return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
  }
  parseStatementOrSloppyAnnexBFunctionDeclaration(t = !1) {
    let r = 0;
    return this.options.annexB && !this.state.strict && (r |= 4, t && (r |= 8)), this.parseStatementLike(r);
  }
  parseStatement() {
    return this.parseStatementLike(0);
  }
  parseStatementLike(t) {
    let r = null;
    return this.match(26) && (r = this.parseDecorators(!0)), this.parseStatementContent(t, r);
  }
  parseStatementContent(t, r) {
    const i = this.state.type, s = this.startNode(), n = !!(t & 2), a = !!(t & 4), o = t & 1;
    switch (i) {
      case 60:
        return this.parseBreakContinueStatement(s, !0);
      case 63:
        return this.parseBreakContinueStatement(s, !1);
      case 64:
        return this.parseDebuggerStatement(s);
      case 90:
        return this.parseDoWhileStatement(s);
      case 91:
        return this.parseForStatement(s);
      case 68:
        if (this.lookaheadCharCode() === 46)
          break;
        return a || this.raise(this.state.strict ? N.StrictFunction : this.options.annexB ? N.SloppyFunctionAnnexB : N.SloppyFunction, {
          at: this.state.startLoc
        }), this.parseFunctionStatement(s, !1, !n && a);
      case 80:
        return n || this.unexpected(), this.parseClass(this.maybeTakeDecorators(r, s), !0);
      case 69:
        return this.parseIfStatement(s);
      case 70:
        return this.parseReturnStatement(s);
      case 71:
        return this.parseSwitchStatement(s);
      case 72:
        return this.parseThrowStatement(s);
      case 73:
        return this.parseTryStatement(s);
      case 96:
        if (!this.state.containsEsc && this.startsAwaitUsing())
          return this.isAwaitAllowed() ? n || this.raise(N.UnexpectedLexicalDeclaration, {
            at: s
          }) : this.raise(N.AwaitUsingNotInAsyncContext, {
            at: s
          }), this.next(), this.parseVarStatement(s, "await using");
        break;
      case 105:
        if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier())
          break;
        return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(N.UnexpectedUsingDeclaration, {
          at: this.state.startLoc
        }) : n || this.raise(N.UnexpectedLexicalDeclaration, {
          at: this.state.startLoc
        }), this.parseVarStatement(s, "using");
      case 99: {
        if (this.state.containsEsc)
          break;
        const c = this.nextTokenStart(), p = this.codePointAtPos(c);
        if (p !== 91 && (!n && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(p, c) && p !== 123))
          break;
      }
      case 75:
        n || this.raise(N.UnexpectedLexicalDeclaration, {
          at: this.state.startLoc
        });
      case 74: {
        const c = this.state.value;
        return this.parseVarStatement(s, c);
      }
      case 92:
        return this.parseWhileStatement(s);
      case 76:
        return this.parseWithStatement(s);
      case 5:
        return this.parseBlock();
      case 13:
        return this.parseEmptyStatement(s);
      case 83: {
        const c = this.lookaheadCharCode();
        if (c === 40 || c === 46)
          break;
      }
      case 82: {
        !this.options.allowImportExportEverywhere && !o && this.raise(N.UnexpectedImportExport, {
          at: this.state.startLoc
        }), this.next();
        let c;
        return i === 83 ? (c = this.parseImport(s), c.type === "ImportDeclaration" && (!c.importKind || c.importKind === "value") && (this.sawUnambiguousESM = !0)) : (c = this.parseExport(s, r), (c.type === "ExportNamedDeclaration" && (!c.exportKind || c.exportKind === "value") || c.type === "ExportAllDeclaration" && (!c.exportKind || c.exportKind === "value") || c.type === "ExportDefaultDeclaration") && (this.sawUnambiguousESM = !0)), this.assertModuleNodeAllowed(c), c;
      }
      default:
        if (this.isAsyncFunction())
          return n || this.raise(N.AsyncFunctionInSingleStatementContext, {
            at: this.state.startLoc
          }), this.next(), this.parseFunctionStatement(s, !0, !n && a);
    }
    const l = this.state.value, u = this.parseExpression();
    return ke(i) && u.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(s, l, u, t) : this.parseExpressionStatement(s, u, r);
  }
  assertModuleNodeAllowed(t) {
    !this.options.allowImportExportEverywhere && !this.inModule && this.raise(N.ImportOutsideModule, {
      at: t
    });
  }
  decoratorsEnabledBeforeExport() {
    return this.hasPlugin("decorators-legacy") ? !0 : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== !1;
  }
  maybeTakeDecorators(t, r, i) {
    return t && (r.decorators && r.decorators.length > 0 ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolean" && this.raise(N.DecoratorsBeforeAfterExport, {
      at: r.decorators[0]
    }), r.decorators.unshift(...t)) : r.decorators = t, this.resetStartLocationFromNode(r, t[0]), i && this.resetStartLocationFromNode(i, r)), r;
  }
  canHaveLeadingDecorator() {
    return this.match(80);
  }
  parseDecorators(t) {
    const r = [];
    do
      r.push(this.parseDecorator());
    while (this.match(26));
    if (this.match(82))
      t || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(N.DecoratorExportClass, {
        at: this.state.startLoc
      });
    else if (!this.canHaveLeadingDecorator())
      throw this.raise(N.UnexpectedLeadingDecorator, {
        at: this.state.startLoc
      });
    return r;
  }
  parseDecorator() {
    this.expectOnePlugin(["decorators", "decorators-legacy"]);
    const t = this.startNode();
    if (this.next(), this.hasPlugin("decorators")) {
      const r = this.state.startLoc;
      let i;
      if (this.match(10)) {
        const s = this.state.startLoc;
        this.next(), i = this.parseExpression(), this.expect(11), i = this.wrapParenthesis(s, i);
        const n = this.state.startLoc;
        t.expression = this.parseMaybeDecoratorArguments(i), this.getPluginOption("decorators", "allowCallParenthesized") === !1 && t.expression !== i && this.raise(N.DecoratorArgumentsOutsideParentheses, {
          at: n
        });
      } else {
        for (i = this.parseIdentifier(!1); this.eat(16); ) {
          const s = this.startNodeAt(r);
          s.object = i, this.match(136) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), s.property = this.parsePrivateName()) : s.property = this.parseIdentifier(!0), s.computed = !1, i = this.finishNode(s, "MemberExpression");
        }
        t.expression = this.parseMaybeDecoratorArguments(i);
      }
    } else
      t.expression = this.parseExprSubscripts();
    return this.finishNode(t, "Decorator");
  }
  parseMaybeDecoratorArguments(t) {
    if (this.eat(10)) {
      const r = this.startNodeAtNode(t);
      return r.callee = t, r.arguments = this.parseCallExpressionArguments(11, !1), this.toReferencedList(r.arguments), this.finishNode(r, "CallExpression");
    }
    return t;
  }
  parseBreakContinueStatement(t, r) {
    return this.next(), this.isLineTerminator() ? t.label = null : (t.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(t, r), this.finishNode(t, r ? "BreakStatement" : "ContinueStatement");
  }
  verifyBreakContinue(t, r) {
    let i;
    for (i = 0; i < this.state.labels.length; ++i) {
      const s = this.state.labels[i];
      if ((t.label == null || s.name === t.label.name) && (s.kind != null && (r || s.kind === "loop") || t.label && r))
        break;
    }
    if (i === this.state.labels.length) {
      const s = r ? "BreakStatement" : "ContinueStatement";
      this.raise(N.IllegalBreakContinue, {
        at: t,
        type: s
      });
    }
  }
  parseDebuggerStatement(t) {
    return this.next(), this.semicolon(), this.finishNode(t, "DebuggerStatement");
  }
  parseHeaderExpression() {
    this.expect(10);
    const t = this.parseExpression();
    return this.expect(11), t;
  }
  parseDoWhileStatement(t) {
    return this.next(), this.state.labels.push(cn), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.expect(92), t.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(t, "DoWhileStatement");
  }
  parseForStatement(t) {
    this.next(), this.state.labels.push(cn);
    let r = null;
    if (this.isAwaitAllowed() && this.eatContextual(96) && (r = this.state.lastTokStartLoc), this.scope.enter(Cr), this.expect(10), this.match(13))
      return r !== null && this.unexpected(r), this.parseFor(t, null);
    const i = this.isContextual(99);
    {
      const l = this.isContextual(96) && this.startsAwaitUsing(), u = l || this.isContextual(105) && this.startsUsingForOf(), c = i && this.hasFollowingBindingAtom() || u;
      if (this.match(74) || this.match(75) || c) {
        const p = this.startNode();
        let h;
        l ? (h = "await using", this.isAwaitAllowed() || this.raise(N.AwaitUsingNotInAsyncContext, {
          at: this.state.startLoc
        }), this.next()) : h = this.state.value, this.next(), this.parseVar(p, !0, h);
        const y = this.finishNode(p, "VariableDeclaration"), P = this.match(58);
        return P && u && this.raise(N.ForInUsing, {
          at: y
        }), (P || this.isContextual(101)) && y.declarations.length === 1 ? this.parseForIn(t, y, r) : (r !== null && this.unexpected(r), this.parseFor(t, y));
      }
    }
    const s = this.isContextual(95), n = new is(), a = this.parseExpression(!0, n), o = this.isContextual(101);
    if (o && (i && this.raise(N.ForOfLet, {
      at: a
    }), r === null && s && a.type === "Identifier" && this.raise(N.ForOfAsync, {
      at: a
    })), o || this.match(58)) {
      this.checkDestructuringPrivate(n), this.toAssignable(a, !0);
      const l = o ? "ForOfStatement" : "ForInStatement";
      return this.checkLVal(a, {
        in: {
          type: l
        }
      }), this.parseForIn(t, a, r);
    } else
      this.checkExpressionErrors(n, !0);
    return r !== null && this.unexpected(r), this.parseFor(t, a);
  }
  parseFunctionStatement(t, r, i) {
    return this.next(), this.parseFunction(t, 1 | (i ? 2 : 0) | (r ? 8 : 0));
  }
  parseIfStatement(t) {
    return this.next(), t.test = this.parseHeaderExpression(), t.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), t.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(t, "IfStatement");
  }
  parseReturnStatement(t) {
    return !this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction && this.raise(N.IllegalReturn, {
      at: this.state.startLoc
    }), this.next(), this.isLineTerminator() ? t.argument = null : (t.argument = this.parseExpression(), this.semicolon()), this.finishNode(t, "ReturnStatement");
  }
  parseSwitchStatement(t) {
    this.next(), t.discriminant = this.parseHeaderExpression();
    const r = t.cases = [];
    this.expect(5), this.state.labels.push(gT), this.scope.enter(Cr);
    let i;
    for (let s; !this.match(8); )
      if (this.match(61) || this.match(65)) {
        const n = this.match(61);
        i && this.finishNode(i, "SwitchCase"), r.push(i = this.startNode()), i.consequent = [], this.next(), n ? i.test = this.parseExpression() : (s && this.raise(N.MultipleDefaultsInSwitch, {
          at: this.state.lastTokStartLoc
        }), s = !0, i.test = null), this.expect(14);
      } else
        i ? i.consequent.push(this.parseStatementListItem()) : this.unexpected();
    return this.scope.exit(), i && this.finishNode(i, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(t, "SwitchStatement");
  }
  parseThrowStatement(t) {
    return this.next(), this.hasPrecedingLineBreak() && this.raise(N.NewlineAfterThrow, {
      at: this.state.lastTokEndLoc
    }), t.argument = this.parseExpression(), this.semicolon(), this.finishNode(t, "ThrowStatement");
  }
  parseCatchClauseParam() {
    const t = this.parseBindingAtom();
    return this.scope.enter(this.options.annexB && t.type === "Identifier" ? Wu : 0), this.checkLVal(t, {
      in: {
        type: "CatchClause"
      },
      binding: py
    }), t;
  }
  parseTryStatement(t) {
    if (this.next(), t.block = this.parseBlock(), t.handler = null, this.match(62)) {
      const r = this.startNode();
      this.next(), this.match(10) ? (this.expect(10), r.param = this.parseCatchClauseParam(), this.expect(11)) : (r.param = null, this.scope.enter(Cr)), r.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), t.handler = this.finishNode(r, "CatchClause");
    }
    return t.finalizer = this.eat(67) ? this.parseBlock() : null, !t.handler && !t.finalizer && this.raise(N.NoCatchOrFinally, {
      at: t
    }), this.finishNode(t, "TryStatement");
  }
  parseVarStatement(t, r, i = !1) {
    return this.next(), this.parseVar(t, !1, r, i), this.semicolon(), this.finishNode(t, "VariableDeclaration");
  }
  parseWhileStatement(t) {
    return this.next(), t.test = this.parseHeaderExpression(), this.state.labels.push(cn), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.finishNode(t, "WhileStatement");
  }
  parseWithStatement(t) {
    return this.state.strict && this.raise(N.StrictWith, {
      at: this.state.startLoc
    }), this.next(), t.object = this.parseHeaderExpression(), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(t, "WithStatement");
  }
  parseEmptyStatement(t) {
    return this.next(), this.finishNode(t, "EmptyStatement");
  }
  parseLabeledStatement(t, r, i, s) {
    for (const a of this.state.labels)
      a.name === r && this.raise(N.LabelRedeclaration, {
        at: i,
        labelName: r
      });
    const n = Hm(this.state.type) ? "loop" : this.match(71) ? "switch" : null;
    for (let a = this.state.labels.length - 1; a >= 0; a--) {
      const o = this.state.labels[a];
      if (o.statementStart === t.start)
        o.statementStart = this.state.start, o.kind = n;
      else
        break;
    }
    return this.state.labels.push({
      name: r,
      kind: n,
      statementStart: this.state.start
    }), t.body = s & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement(), this.state.labels.pop(), t.label = i, this.finishNode(t, "LabeledStatement");
  }
  parseExpressionStatement(t, r, i) {
    return t.expression = r, this.semicolon(), this.finishNode(t, "ExpressionStatement");
  }
  parseBlock(t = !1, r = !0, i) {
    const s = this.startNode();
    return t && this.state.strictErrors.clear(), this.expect(5), r && this.scope.enter(Cr), this.parseBlockBody(s, t, !1, 8, i), r && this.scope.exit(), this.finishNode(s, "BlockStatement");
  }
  isValidDirective(t) {
    return t.type === "ExpressionStatement" && t.expression.type === "StringLiteral" && !t.expression.extra.parenthesized;
  }
  parseBlockBody(t, r, i, s, n) {
    const a = t.body = [], o = t.directives = [];
    this.parseBlockOrModuleBlockBody(a, r ? o : void 0, i, s, n);
  }
  parseBlockOrModuleBlockBody(t, r, i, s, n) {
    const a = this.state.strict;
    let o = !1, l = !1;
    for (; !this.match(s); ) {
      const u = i ? this.parseModuleItem() : this.parseStatementListItem();
      if (r && !l) {
        if (this.isValidDirective(u)) {
          const c = this.stmtToDirective(u);
          r.push(c), !o && c.value.value === "use strict" && (o = !0, this.setStrict(!0));
          continue;
        }
        l = !0, this.state.strictErrors.clear();
      }
      t.push(u);
    }
    n == null || n.call(this, o), a || this.setStrict(!1), this.next();
  }
  parseFor(t, r) {
    return t.init = r, this.semicolon(!1), t.test = this.match(13) ? null : this.parseExpression(), this.semicolon(!1), t.update = this.match(11) ? null : this.parseExpression(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, "ForStatement");
  }
  parseForIn(t, r, i) {
    const s = this.match(58);
    return this.next(), s ? i !== null && this.unexpected(i) : t.await = i !== null, r.type === "VariableDeclaration" && r.declarations[0].init != null && (!s || !this.options.annexB || this.state.strict || r.kind !== "var" || r.declarations[0].id.type !== "Identifier") && this.raise(N.ForInOfLoopInitializer, {
      at: r,
      type: s ? "ForInStatement" : "ForOfStatement"
    }), r.type === "AssignmentPattern" && this.raise(N.InvalidLhs, {
      at: r,
      ancestor: {
        type: "ForStatement"
      }
    }), t.left = r, t.right = s ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, s ? "ForInStatement" : "ForOfStatement");
  }
  parseVar(t, r, i, s = !1) {
    const n = t.declarations = [];
    for (t.kind = i; ; ) {
      const a = this.startNode();
      if (this.parseVarId(a, i), a.init = this.eat(29) ? r ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, a.init === null && !s && (a.id.type !== "Identifier" && !(r && (this.match(58) || this.isContextual(101))) ? this.raise(N.DeclarationMissingInitializer, {
        at: this.state.lastTokEndLoc,
        kind: "destructuring"
      }) : i === "const" && !(this.match(58) || this.isContextual(101)) && this.raise(N.DeclarationMissingInitializer, {
        at: this.state.lastTokEndLoc,
        kind: "const"
      })), n.push(this.finishNode(a, "VariableDeclarator")), !this.eat(12))
        break;
    }
    return t;
  }
  parseVarId(t, r) {
    const i = this.parseBindingAtom();
    this.checkLVal(i, {
      in: {
        type: "VariableDeclarator"
      },
      binding: r === "var" ? ps : Dr
    }), t.id = i;
  }
  parseAsyncFunctionExpression(t) {
    return this.parseFunction(t, 8);
  }
  parseFunction(t, r = 0) {
    const i = r & 2, s = !!(r & 1), n = s && !(r & 4), a = !!(r & 8);
    this.initFunction(t, a), this.match(55) && (i && this.raise(N.GeneratorInSingleStatementContext, {
      at: this.state.startLoc
    }), this.next(), t.generator = !0), s && (t.id = this.parseFunctionId(n));
    const o = this.state.maybeInArrowParameters;
    return this.state.maybeInArrowParameters = !1, this.scope.enter(Mt), this.prodParam.enter(rs(a, t.generator)), s || (t.id = this.parseFunctionId()), this.parseFunctionParams(t, !1), this.withSmartMixTopicForbiddingContext(() => {
      this.parseFunctionBodyAndFinish(t, s ? "FunctionDeclaration" : "FunctionExpression");
    }), this.prodParam.exit(), this.scope.exit(), s && !i && this.registerFunctionStatementId(t), this.state.maybeInArrowParameters = o, t;
  }
  parseFunctionId(t) {
    return t || ke(this.state.type) ? this.parseIdentifier() : null;
  }
  parseFunctionParams(t, r) {
    this.expect(10), this.expressionScope.enter($y()), t.params = this.parseBindingList(11, 41, 2 | (r ? 4 : 0)), this.expressionScope.exit();
  }
  registerFunctionStatementId(t) {
    t.id && this.scope.declareName(t.id.name, !this.options.annexB || this.state.strict || t.generator || t.async ? this.scope.treatFunctionsAsVar ? ps : Dr : Gu, t.id.loc.start);
  }
  parseClass(t, r, i) {
    this.next();
    const s = this.state.strict;
    return this.state.strict = !0, this.parseClassId(t, r, i), this.parseClassSuper(t), t.body = this.parseClassBody(!!t.superClass, s), this.finishNode(t, r ? "ClassDeclaration" : "ClassExpression");
  }
  isClassProperty() {
    return this.match(29) || this.match(13) || this.match(8);
  }
  isClassMethod() {
    return this.match(10);
  }
  isNonstaticConstructor(t) {
    return !t.computed && !t.static && (t.key.name === "constructor" || t.key.value === "constructor");
  }
  parseClassBody(t, r) {
    this.classScope.enter();
    const i = {
      hadConstructor: !1,
      hadSuperClass: t
    };
    let s = [];
    const n = this.startNode();
    if (n.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
      for (; !this.match(8); ) {
        if (this.eat(13)) {
          if (s.length > 0)
            throw this.raise(N.DecoratorSemicolon, {
              at: this.state.lastTokEndLoc
            });
          continue;
        }
        if (this.match(26)) {
          s.push(this.parseDecorator());
          continue;
        }
        const a = this.startNode();
        s.length && (a.decorators = s, this.resetStartLocationFromNode(a, s[0]), s = []), this.parseClassMember(n, a, i), a.kind === "constructor" && a.decorators && a.decorators.length > 0 && this.raise(N.DecoratorConstructor, {
          at: a
        });
      }
    }), this.state.strict = r, this.next(), s.length)
      throw this.raise(N.TrailingDecorator, {
        at: this.state.startLoc
      });
    return this.classScope.exit(), this.finishNode(n, "ClassBody");
  }
  parseClassMemberFromModifier(t, r) {
    const i = this.parseIdentifier(!0);
    if (this.isClassMethod()) {
      const s = r;
      return s.kind = "method", s.computed = !1, s.key = i, s.static = !1, this.pushClassMethod(t, s, !1, !1, !1, !1), !0;
    } else if (this.isClassProperty()) {
      const s = r;
      return s.computed = !1, s.key = i, s.static = !1, t.body.push(this.parseClassProperty(s)), !0;
    }
    return this.resetPreviousNodeTrailingComments(i), !1;
  }
  parseClassMember(t, r, i) {
    const s = this.isContextual(104);
    if (s) {
      if (this.parseClassMemberFromModifier(t, r))
        return;
      if (this.eat(5)) {
        this.parseClassStaticBlock(t, r);
        return;
      }
    }
    this.parseClassMemberWithIsStatic(t, r, i, s);
  }
  parseClassMemberWithIsStatic(t, r, i, s) {
    const n = r, a = r, o = r, l = r, u = r, c = n, p = n;
    if (r.static = s, this.parsePropertyNamePrefixOperator(r), this.eat(55)) {
      c.kind = "method";
      const w = this.match(136);
      if (this.parseClassElementName(c), w) {
        this.pushClassPrivateMethod(t, a, !0, !1);
        return;
      }
      this.isNonstaticConstructor(n) && this.raise(N.ConstructorIsGenerator, {
        at: n.key
      }), this.pushClassMethod(t, n, !0, !1, !1, !1);
      return;
    }
    const h = ke(this.state.type) && !this.state.containsEsc, y = this.match(136), P = this.parseClassElementName(r), v = this.state.startLoc;
    if (this.parsePostMemberNameModifiers(p), this.isClassMethod()) {
      if (c.kind = "method", y) {
        this.pushClassPrivateMethod(t, a, !1, !1);
        return;
      }
      const w = this.isNonstaticConstructor(n);
      let x = !1;
      w && (n.kind = "constructor", i.hadConstructor && !this.hasPlugin("typescript") && this.raise(N.DuplicateConstructor, {
        at: P
      }), w && this.hasPlugin("typescript") && r.override && this.raise(N.OverrideOnConstructor, {
        at: P
      }), i.hadConstructor = !0, x = i.hadSuperClass), this.pushClassMethod(t, n, !1, !1, w, x);
    } else if (this.isClassProperty())
      y ? this.pushClassPrivateProperty(t, l) : this.pushClassProperty(t, o);
    else if (h && P.name === "async" && !this.isLineTerminator()) {
      this.resetPreviousNodeTrailingComments(P);
      const w = this.eat(55);
      p.optional && this.unexpected(v), c.kind = "method";
      const x = this.match(136);
      this.parseClassElementName(c), this.parsePostMemberNameModifiers(p), x ? this.pushClassPrivateMethod(t, a, w, !0) : (this.isNonstaticConstructor(n) && this.raise(N.ConstructorIsAsync, {
        at: n.key
      }), this.pushClassMethod(t, n, w, !0, !1, !1));
    } else if (h && (P.name === "get" || P.name === "set") && !(this.match(55) && this.isLineTerminator())) {
      this.resetPreviousNodeTrailingComments(P), c.kind = P.name;
      const w = this.match(136);
      this.parseClassElementName(n), w ? this.pushClassPrivateMethod(t, a, !1, !1) : (this.isNonstaticConstructor(n) && this.raise(N.ConstructorIsAccessor, {
        at: n.key
      }), this.pushClassMethod(t, n, !1, !1, !1, !1)), this.checkGetterSetterParams(n);
    } else if (h && P.name === "accessor" && !this.isLineTerminator()) {
      this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(P);
      const w = this.match(136);
      this.parseClassElementName(o), this.pushClassAccessorProperty(t, u, w);
    } else
      this.isLineTerminator() ? y ? this.pushClassPrivateProperty(t, l) : this.pushClassProperty(t, o) : this.unexpected();
  }
  parseClassElementName(t) {
    const {
      type: r,
      value: i
    } = this.state;
    if ((r === 130 || r === 131) && t.static && i === "prototype" && this.raise(N.StaticPrototype, {
      at: this.state.startLoc
    }), r === 136) {
      i === "constructor" && this.raise(N.ConstructorClassPrivateField, {
        at: this.state.startLoc
      });
      const s = this.parsePrivateName();
      return t.key = s, s;
    }
    return this.parsePropertyName(t);
  }
  parseClassStaticBlock(t, r) {
    var i;
    this.scope.enter(ar | cs | us);
    const s = this.state.labels;
    this.state.labels = [], this.prodParam.enter(kr);
    const n = r.body = [];
    this.parseBlockOrModuleBlockBody(n, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = s, t.body.push(this.finishNode(r, "StaticBlock")), (i = r.decorators) != null && i.length && this.raise(N.DecoratorStaticBlock, {
      at: r
    });
  }
  pushClassProperty(t, r) {
    !r.computed && (r.key.name === "constructor" || r.key.value === "constructor") && this.raise(N.ConstructorClassField, {
      at: r.key
    }), t.body.push(this.parseClassProperty(r));
  }
  pushClassPrivateProperty(t, r) {
    const i = this.parseClassPrivateProperty(r);
    t.body.push(i), this.classScope.declarePrivateName(this.getPrivateNameSV(i.key), ln, i.key.loc.start);
  }
  pushClassAccessorProperty(t, r, i) {
    if (!i && !r.computed) {
      const n = r.key;
      (n.name === "constructor" || n.value === "constructor") && this.raise(N.ConstructorClassField, {
        at: n
      });
    }
    const s = this.parseClassAccessorProperty(r);
    t.body.push(s), i && this.classScope.declarePrivateName(this.getPrivateNameSV(s.key), ln, s.key.loc.start);
  }
  pushClassMethod(t, r, i, s, n, a) {
    t.body.push(this.parseMethod(r, i, s, n, a, "ClassMethod", !0));
  }
  pushClassPrivateMethod(t, r, i, s) {
    const n = this.parseMethod(r, i, s, !1, !1, "ClassPrivateMethod", !0);
    t.body.push(n);
    const a = n.kind === "get" ? n.static ? by : Ey : n.kind === "set" ? n.static ? gy : Py : ln;
    this.declareClassPrivateMethodInScope(n, a);
  }
  declareClassPrivateMethodInScope(t, r) {
    this.classScope.declarePrivateName(this.getPrivateNameSV(t.key), r, t.key.loc.start);
  }
  parsePostMemberNameModifiers(t) {
  }
  parseClassPrivateProperty(t) {
    return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassPrivateProperty");
  }
  parseClassProperty(t) {
    return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassProperty");
  }
  parseClassAccessorProperty(t) {
    return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassAccessorProperty");
  }
  parseInitializer(t) {
    this.scope.enter(ar | us), this.expressionScope.enter(nc()), this.prodParam.enter(kr), t.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
  }
  parseClassId(t, r, i, s = Hu) {
    if (ke(this.state.type))
      t.id = this.parseIdentifier(), r && this.declareNameFromIdentifier(t.id, s);
    else if (i || !r)
      t.id = null;
    else
      throw this.raise(N.MissingClassName, {
        at: this.state.startLoc
      });
  }
  parseClassSuper(t) {
    t.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
  }
  parseExport(t, r) {
    const i = this.parseMaybeImportPhase(t, !0), s = this.maybeParseExportDefaultSpecifier(t, i), n = !s || this.eat(12), a = n && this.eatExportStar(t), o = a && this.maybeParseExportNamespaceSpecifier(t), l = n && (!o || this.eat(12)), u = s || a;
    if (a && !o) {
      if (s && this.unexpected(), r)
        throw this.raise(N.UnsupportedDecoratorExport, {
          at: t
        });
      return this.parseExportFrom(t, !0), this.finishNode(t, "ExportAllDeclaration");
    }
    const c = this.maybeParseExportNamedSpecifiers(t);
    s && n && !a && !c && this.unexpected(null, 5), o && l && this.unexpected(null, 97);
    let p;
    if (u || c) {
      if (p = !1, r)
        throw this.raise(N.UnsupportedDecoratorExport, {
          at: t
        });
      this.parseExportFrom(t, u);
    } else
      p = this.maybeParseExportDeclaration(t);
    if (u || c || p) {
      var h;
      const y = t;
      if (this.checkExport(y, !0, !1, !!y.source), ((h = y.declaration) == null ? void 0 : h.type) === "ClassDeclaration")
        this.maybeTakeDecorators(r, y.declaration, y);
      else if (r)
        throw this.raise(N.UnsupportedDecoratorExport, {
          at: t
        });
      return this.finishNode(y, "ExportNamedDeclaration");
    }
    if (this.eat(65)) {
      const y = t, P = this.parseExportDefaultExpression();
      if (y.declaration = P, P.type === "ClassDeclaration")
        this.maybeTakeDecorators(r, P, y);
      else if (r)
        throw this.raise(N.UnsupportedDecoratorExport, {
          at: t
        });
      return this.checkExport(y, !0, !0), this.finishNode(y, "ExportDefaultDeclaration");
    }
    this.unexpected(null, 5);
  }
  eatExportStar(t) {
    return this.eat(55);
  }
  maybeParseExportDefaultSpecifier(t, r) {
    if (r || this.isExportDefaultSpecifier()) {
      this.expectPlugin("exportDefaultFrom", r == null ? void 0 : r.loc.start);
      const i = r || this.parseIdentifier(!0), s = this.startNodeAtNode(i);
      return s.exported = i, t.specifiers = [this.finishNode(s, "ExportDefaultSpecifier")], !0;
    }
    return !1;
  }
  maybeParseExportNamespaceSpecifier(t) {
    if (this.isContextual(93)) {
      t.specifiers || (t.specifiers = []);
      const r = this.startNodeAt(this.state.lastTokStartLoc);
      return this.next(), r.exported = this.parseModuleExportName(), t.specifiers.push(this.finishNode(r, "ExportNamespaceSpecifier")), !0;
    }
    return !1;
  }
  maybeParseExportNamedSpecifiers(t) {
    if (this.match(5)) {
      t.specifiers || (t.specifiers = []);
      const r = t.exportKind === "type";
      return t.specifiers.push(...this.parseExportSpecifiers(r)), t.source = null, t.declaration = null, this.hasPlugin("importAssertions") && (t.assertions = []), !0;
    }
    return !1;
  }
  maybeParseExportDeclaration(t) {
    return this.shouldParseExportDeclaration() ? (t.specifiers = [], t.source = null, this.hasPlugin("importAssertions") && (t.assertions = []), t.declaration = this.parseExportDeclaration(t), !0) : !1;
  }
  isAsyncFunction() {
    if (!this.isContextual(95))
      return !1;
    const t = this.nextTokenInLineStart();
    return this.isUnparsedContextual(t, "function");
  }
  parseExportDefaultExpression() {
    const t = this.startNode();
    if (this.match(68))
      return this.next(), this.parseFunction(t, 5);
    if (this.isAsyncFunction())
      return this.next(), this.next(), this.parseFunction(t, 13);
    if (this.match(80))
      return this.parseClass(t, !0, !0);
    if (this.match(26))
      return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(N.DecoratorBeforeExport, {
        at: this.state.startLoc
      }), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
    if (this.match(75) || this.match(74) || this.isLet())
      throw this.raise(N.UnsupportedDefaultExport, {
        at: this.state.startLoc
      });
    const r = this.parseMaybeAssignAllowIn();
    return this.semicolon(), r;
  }
  parseExportDeclaration(t) {
    return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
  }
  isExportDefaultSpecifier() {
    const {
      type: t
    } = this.state;
    if (ke(t)) {
      if (t === 95 && !this.state.containsEsc || t === 99)
        return !1;
      if ((t === 128 || t === 127) && !this.state.containsEsc) {
        const {
          type: s
        } = this.lookahead();
        if (ke(s) && s !== 97 || s === 5)
          return this.expectOnePlugin(["flow", "typescript"]), !1;
      }
    } else if (!this.match(65))
      return !1;
    const r = this.nextTokenStart(), i = this.isUnparsedContextual(r, "from");
    if (this.input.charCodeAt(r) === 44 || ke(this.state.type) && i)
      return !0;
    if (this.match(65) && i) {
      const s = this.input.charCodeAt(this.nextTokenStartSince(r + 4));
      return s === 34 || s === 39;
    }
    return !1;
  }
  parseExportFrom(t, r) {
    this.eatContextual(97) ? (t.source = this.parseImportSource(), this.checkExport(t), this.maybeParseImportAttributes(t), this.checkJSONModuleImport(t)) : r && this.unexpected(), this.semicolon();
  }
  shouldParseExportDeclaration() {
    const {
      type: t
    } = this.state;
    return t === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(N.DecoratorBeforeExport, {
      at: this.state.startLoc
    }), !0) : t === 74 || t === 75 || t === 68 || t === 80 || this.isLet() || this.isAsyncFunction();
  }
  checkExport(t, r, i, s) {
    if (r) {
      if (i) {
        if (this.checkDuplicateExports(t, "default"), this.hasPlugin("exportDefaultFrom")) {
          var n;
          const a = t.declaration;
          a.type === "Identifier" && a.name === "from" && a.end - a.start === 4 && !((n = a.extra) != null && n.parenthesized) && this.raise(N.ExportDefaultFromAsIdentifier, {
            at: a
          });
        }
      } else if (t.specifiers && t.specifiers.length)
        for (const a of t.specifiers) {
          const {
            exported: o
          } = a, l = o.type === "Identifier" ? o.name : o.value;
          if (this.checkDuplicateExports(a, l), !s && a.local) {
            const {
              local: u
            } = a;
            u.type !== "Identifier" ? this.raise(N.ExportBindingIsString, {
              at: a,
              localName: u.value,
              exportName: l
            }) : (this.checkReservedWord(u.name, u.loc.start, !0, !1), this.scope.checkLocalExport(u));
          }
        }
      else if (t.declaration) {
        if (t.declaration.type === "FunctionDeclaration" || t.declaration.type === "ClassDeclaration") {
          const a = t.declaration.id;
          if (!a)
            throw new Error("Assertion failure");
          this.checkDuplicateExports(t, a.name);
        } else if (t.declaration.type === "VariableDeclaration")
          for (const a of t.declaration.declarations)
            this.checkDeclaration(a.id);
      }
    }
  }
  checkDeclaration(t) {
    if (t.type === "Identifier")
      this.checkDuplicateExports(t, t.name);
    else if (t.type === "ObjectPattern")
      for (const r of t.properties)
        this.checkDeclaration(r);
    else if (t.type === "ArrayPattern")
      for (const r of t.elements)
        r && this.checkDeclaration(r);
    else
      t.type === "ObjectProperty" ? this.checkDeclaration(t.value) : t.type === "RestElement" ? this.checkDeclaration(t.argument) : t.type === "AssignmentPattern" && this.checkDeclaration(t.left);
  }
  checkDuplicateExports(t, r) {
    this.exportedIdentifiers.has(r) && (r === "default" ? this.raise(N.DuplicateDefaultExport, {
      at: t
    }) : this.raise(N.DuplicateExport, {
      at: t,
      exportName: r
    })), this.exportedIdentifiers.add(r);
  }
  parseExportSpecifiers(t) {
    const r = [];
    let i = !0;
    for (this.expect(5); !this.eat(8); ) {
      if (i)
        i = !1;
      else if (this.expect(12), this.eat(8))
        break;
      const s = this.isContextual(128), n = this.match(131), a = this.startNode();
      a.local = this.parseModuleExportName(), r.push(this.parseExportSpecifier(a, n, t, s));
    }
    return r;
  }
  parseExportSpecifier(t, r, i, s) {
    return this.eatContextual(93) ? t.exported = this.parseModuleExportName() : r ? t.exported = Yy(t.local) : t.exported || (t.exported = Bt(t.local)), this.finishNode(t, "ExportSpecifier");
  }
  parseModuleExportName() {
    if (this.match(131)) {
      const t = this.parseStringLiteral(this.state.value), r = t.value.match(ET);
      return r && this.raise(N.ModuleExportNameHasLoneSurrogate, {
        at: t,
        surrogateCharCode: r[0].charCodeAt(0)
      }), t;
    }
    return this.parseIdentifier(!0);
  }
  isJSONModuleImport(t) {
    return t.assertions != null ? t.assertions.some(({
      key: r,
      value: i
    }) => i.value === "json" && (r.type === "Identifier" ? r.name === "type" : r.value === "type")) : !1;
  }
  checkImportReflection(t) {
    if (t.module) {
      var r;
      (t.specifiers.length !== 1 || t.specifiers[0].type !== "ImportDefaultSpecifier") && this.raise(N.ImportReflectionNotBinding, {
        at: t.specifiers[0].loc.start
      }), ((r = t.assertions) == null ? void 0 : r.length) > 0 && this.raise(N.ImportReflectionHasAssertion, {
        at: t.specifiers[0].loc.start
      });
    }
  }
  checkJSONModuleImport(t) {
    if (this.isJSONModuleImport(t) && t.type !== "ExportAllDeclaration") {
      const {
        specifiers: r
      } = t;
      if (r != null) {
        const i = r.find((s) => {
          let n;
          if (s.type === "ExportSpecifier" ? n = s.local : s.type === "ImportSpecifier" && (n = s.imported), n !== void 0)
            return n.type === "Identifier" ? n.name !== "default" : n.value !== "default";
        });
        i !== void 0 && this.raise(N.ImportJSONBindingNotDefault, {
          at: i.loc.start
        });
      }
    }
  }
  isPotentialImportPhase(t) {
    return !t && this.isContextual(125);
  }
  applyImportPhase(t, r, i, s) {
    r || (i === "module" ? (this.expectPlugin("importReflection", s), t.module = !0) : this.hasPlugin("importReflection") && (t.module = !1));
  }
  parseMaybeImportPhase(t, r) {
    if (!this.isPotentialImportPhase(r))
      return this.applyImportPhase(t, r, null), null;
    const i = this.parseIdentifier(!0), {
      type: s
    } = this.state;
    return (bt(s) ? s !== 97 || this.lookaheadCharCode() === 102 : s !== 12) ? (this.resetPreviousIdentifierLeadingComments(i), this.applyImportPhase(t, r, i.name, i.loc.start), null) : (this.applyImportPhase(t, r, null), i);
  }
  isPrecedingIdImportPhase(t) {
    const {
      type: r
    } = this.state;
    return ke(r) ? r !== 97 || this.lookaheadCharCode() === 102 : r !== 12;
  }
  parseImport(t) {
    return this.match(131) ? this.parseImportSourceAndAttributes(t) : this.parseImportSpecifiersAndAfter(t, this.parseMaybeImportPhase(t, !1));
  }
  parseImportSpecifiersAndAfter(t, r) {
    t.specifiers = [];
    const s = !this.maybeParseDefaultImportSpecifier(t, r) || this.eat(12), n = s && this.maybeParseStarImportSpecifier(t);
    return s && !n && this.parseNamedImportSpecifiers(t), this.expectContextual(97), this.parseImportSourceAndAttributes(t);
  }
  parseImportSourceAndAttributes(t) {
    var r;
    return (r = t.specifiers) != null || (t.specifiers = []), t.source = this.parseImportSource(), this.maybeParseImportAttributes(t), this.checkImportReflection(t), this.checkJSONModuleImport(t), this.semicolon(), this.finishNode(t, "ImportDeclaration");
  }
  parseImportSource() {
    return this.match(131) || this.unexpected(), this.parseExprAtom();
  }
  parseImportSpecifierLocal(t, r, i) {
    r.local = this.parseIdentifier(), t.specifiers.push(this.finishImportSpecifier(r, i));
  }
  finishImportSpecifier(t, r, i = Dr) {
    return this.checkLVal(t.local, {
      in: {
        type: r
      },
      binding: i
    }), this.finishNode(t, r);
  }
  parseImportAttributes() {
    this.expect(5);
    const t = [], r = /* @__PURE__ */ new Set();
    do {
      if (this.match(8))
        break;
      const i = this.startNode(), s = this.state.value;
      if (r.has(s) && this.raise(N.ModuleAttributesWithDuplicateKeys, {
        at: this.state.startLoc,
        key: s
      }), r.add(s), this.match(131) ? i.key = this.parseStringLiteral(s) : i.key = this.parseIdentifier(!0), this.expect(14), !this.match(131))
        throw this.raise(N.ModuleAttributeInvalidValue, {
          at: this.state.startLoc
        });
      i.value = this.parseStringLiteral(this.state.value), t.push(this.finishNode(i, "ImportAttribute"));
    } while (this.eat(12));
    return this.expect(8), t;
  }
  parseModuleAttributes() {
    const t = [], r = /* @__PURE__ */ new Set();
    do {
      const i = this.startNode();
      if (i.key = this.parseIdentifier(!0), i.key.name !== "type" && this.raise(N.ModuleAttributeDifferentFromType, {
        at: i.key
      }), r.has(i.key.name) && this.raise(N.ModuleAttributesWithDuplicateKeys, {
        at: i.key,
        key: i.key.name
      }), r.add(i.key.name), this.expect(14), !this.match(131))
        throw this.raise(N.ModuleAttributeInvalidValue, {
          at: this.state.startLoc
        });
      i.value = this.parseStringLiteral(this.state.value), t.push(this.finishNode(i, "ImportAttribute"));
    } while (this.eat(12));
    return t;
  }
  maybeParseImportAttributes(t) {
    let r, i = !1;
    if (this.match(76)) {
      if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40)
        return;
      this.next(), this.hasPlugin("moduleAttributes") ? r = this.parseModuleAttributes() : (this.expectImportAttributesPlugin(), r = this.parseImportAttributes()), i = !0;
    } else if (this.isContextual(94) && !this.hasPrecedingLineBreak())
      this.hasPlugin("importAttributes") ? (this.getPluginOption("importAttributes", "deprecatedAssertSyntax") !== !0 && this.raise(N.ImportAttributesUseAssert, {
        at: this.state.startLoc
      }), this.addExtra(t, "deprecatedAssertSyntax", !0)) : this.expectOnePlugin(["importAttributes", "importAssertions"]), this.next(), r = this.parseImportAttributes();
    else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions"))
      r = [];
    else if (this.hasPlugin("moduleAttributes"))
      r = [];
    else
      return;
    !i && this.hasPlugin("importAssertions") ? t.assertions = r : t.attributes = r;
  }
  maybeParseDefaultImportSpecifier(t, r) {
    if (r) {
      const i = this.startNodeAtNode(r);
      return i.local = r, t.specifiers.push(this.finishImportSpecifier(i, "ImportDefaultSpecifier")), !0;
    } else if (bt(this.state.type))
      return this.parseImportSpecifierLocal(t, this.startNode(), "ImportDefaultSpecifier"), !0;
    return !1;
  }
  maybeParseStarImportSpecifier(t) {
    if (this.match(55)) {
      const r = this.startNode();
      return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(t, r, "ImportNamespaceSpecifier"), !0;
    }
    return !1;
  }
  parseNamedImportSpecifiers(t) {
    let r = !0;
    for (this.expect(5); !this.eat(8); ) {
      if (r)
        r = !1;
      else {
        if (this.eat(14))
          throw this.raise(N.DestructureNamedImport, {
            at: this.state.startLoc
          });
        if (this.expect(12), this.eat(8))
          break;
      }
      const i = this.startNode(), s = this.match(131), n = this.isContextual(128);
      i.imported = this.parseModuleExportName();
      const a = this.parseImportSpecifier(i, s, t.importKind === "type" || t.importKind === "typeof", n, void 0);
      t.specifiers.push(a);
    }
  }
  parseImportSpecifier(t, r, i, s, n) {
    if (this.eatContextual(93))
      t.local = this.parseIdentifier();
    else {
      const {
        imported: a
      } = t;
      if (r)
        throw this.raise(N.ImportBindingIsString, {
          at: t,
          importName: a.value
        });
      this.checkReservedWord(a.name, t.loc.start, !0, !0), t.local || (t.local = Bt(a));
    }
    return this.finishImportSpecifier(t, "ImportSpecifier", n);
  }
  isThisParam(t) {
    return t.type === "Identifier" && t.name === "this";
  }
}
class pc extends xT {
  constructor(t, r) {
    t = ST(t), super(t, r), this.options = t, this.initializeScopes(), this.plugins = vT(this.options.plugins), this.filename = t.sourceFilename;
  }
  getScopeHandler() {
    return ha;
  }
  parse() {
    this.enterInitialScopes();
    const t = this.startNode(), r = this.startNode();
    return this.nextToken(), t.errors = null, this.parseTopLevel(t, r), t.errors = this.state.errors, t;
  }
}
function vT(e) {
  const t = /* @__PURE__ */ new Map();
  for (const r of e) {
    const [i, s] = Array.isArray(r) ? r : [r, {}];
    t.has(i) || t.set(i, s || {});
  }
  return t;
}
function AT(e, t) {
  var r;
  if (((r = t) == null ? void 0 : r.sourceType) === "unambiguous") {
    t = Object.assign({}, t);
    try {
      t.sourceType = "module";
      const i = zr(t, e), s = i.parse();
      if (i.sawUnambiguousESM)
        return s;
      if (i.ambiguousScriptDifferentAst)
        try {
          return t.sourceType = "script", zr(t, e).parse();
        } catch {
        }
      else
        s.program.sourceType = "script";
      return s;
    } catch (i) {
      try {
        return t.sourceType = "script", zr(t, e).parse();
      } catch {
      }
      throw i;
    }
  } else
    return zr(t, e).parse();
}
function CT(e, t) {
  const r = zr(t, e);
  return r.options.strictMode && (r.state.strict = !0), r.getExpression();
}
function IT(e) {
  const t = {};
  for (const r of Object.keys(e))
    t[r] = Ot(e[r]);
  return t;
}
const wT = IT(Wm);
function zr(e, t) {
  let r = pc;
  return e != null && e.plugins && (yT(e.plugins), r = OT(e.plugins)), new r(e, t);
}
const Mo = {};
function OT(e) {
  const t = TT.filter((s) => Xe(e, s)), r = t.join("/");
  let i = Mo[r];
  if (!i) {
    i = pc;
    for (const s of t)
      i = fc[s](i);
    Mo[r] = i;
  }
  return i;
}
pr.parse = AT;
pr.parseExpression = CT;
pr.tokTypes = wT;
var pn = {}, Ft = {}, we = {};
Object.defineProperty(we, "__esModule", {
  value: !0
});
we.Var = we.User = we.Statement = we.SpreadProperty = we.Scope = we.RestProperty = we.ReferencedMemberExpression = we.ReferencedIdentifier = we.Referenced = we.Pure = we.NumericLiteralTypeAnnotation = we.Generated = we.ForAwaitStatement = we.Flow = we.Expression = we.ExistentialTypeParam = we.BlockScoped = we.BindingIdentifier = void 0;
const NT = ["Identifier", "JSXIdentifier"];
we.ReferencedIdentifier = NT;
const _T = ["MemberExpression"];
we.ReferencedMemberExpression = _T;
const DT = ["Identifier"];
we.BindingIdentifier = DT;
const kT = ["Statement"];
we.Statement = kT;
const LT = ["Expression"];
we.Expression = LT;
const MT = ["Scopable", "Pattern"];
we.Scope = MT;
const BT = null;
we.Referenced = BT;
const FT = null;
we.BlockScoped = FT;
const jT = ["VariableDeclaration"];
we.Var = jT;
const RT = null;
we.User = RT;
const $T = null;
we.Generated = $T;
const UT = null;
we.Pure = UT;
const VT = ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"];
we.Flow = VT;
const KT = ["RestElement"];
we.RestProperty = KT;
const qT = ["RestElement"];
we.SpreadProperty = qT;
const WT = ["ExistsTypeAnnotation"];
we.ExistentialTypeParam = WT;
const YT = ["NumberLiteralTypeAnnotation"];
we.NumericLiteralTypeAnnotation = YT;
const XT = ["ForOfStatement"];
we.ForAwaitStatement = XT;
var hn = {}, Es = {}, Ps = {}, xs = {}, m = {}, ui = {};
Object.defineProperty(ui, "__esModule", {
  value: !0
});
ui.default = JT;
function JT(e, t) {
  const r = Object.keys(t);
  for (const i of r)
    if (e[i] !== t[i])
      return !1;
  return !0;
}
var Mr = {};
Object.defineProperty(Mr, "__esModule", {
  value: !0
});
Mr.default = HT;
const Bo = /* @__PURE__ */ new Set();
function HT(e, t, r = "") {
  if (Bo.has(e))
    return;
  Bo.add(e);
  const {
    internal: i,
    trace: s
  } = GT(1, 2);
  i || console.warn(`${r}\`${e}\` has been deprecated, please migrate to \`${t}\`
${s}`);
}
function GT(e, t) {
  const {
    stackTraceLimit: r,
    prepareStackTrace: i
  } = Error;
  let s;
  if (Error.stackTraceLimit = 1 + e + t, Error.prepareStackTrace = function(a, o) {
    s = o;
  }, new Error().stack, Error.stackTraceLimit = r, Error.prepareStackTrace = i, !s)
    return {
      internal: !1,
      trace: ""
    };
  const n = s.slice(1 + e, 1 + e + t);
  return {
    internal: /[\\/]@babel[\\/]/.test(n[1].getFileName()),
    trace: n.map((a) => `    at ${a}`).join(`
`)
  };
}
Object.defineProperty(m, "__esModule", {
  value: !0
});
m.isAccessor = uP;
m.isAnyTypeAnnotation = NS;
m.isArgumentPlaceholder = ng;
m.isArrayExpression = zT;
m.isArrayPattern = H0;
m.isArrayTypeAnnotation = _S;
m.isArrowFunctionExpression = G0;
m.isAssignmentExpression = QT;
m.isAssignmentPattern = J0;
m.isAwaitExpression = SS;
m.isBigIntLiteral = gS;
m.isBinary = DE;
m.isBinaryExpression = ZT;
m.isBindExpression = ag;
m.isBlock = ME;
m.isBlockParent = LE;
m.isBlockStatement = i0;
m.isBooleanLiteral = v0;
m.isBooleanLiteralTypeAnnotation = kS;
m.isBooleanTypeAnnotation = DS;
m.isBreakStatement = s0;
m.isCallExpression = n0;
m.isCatchClause = a0;
m.isClass = aP;
m.isClassAccessorProperty = AS;
m.isClassBody = z0;
m.isClassDeclaration = Z0;
m.isClassExpression = Q0;
m.isClassImplements = MS;
m.isClassMethod = cS;
m.isClassPrivateMethod = IS;
m.isClassPrivateProperty = CS;
m.isClassProperty = vS;
m.isCompletionStatement = jE;
m.isConditional = RE;
m.isConditionalExpression = o0;
m.isContinueStatement = l0;
m.isDebuggerStatement = u0;
m.isDecimalLiteral = hg;
m.isDeclaration = JE;
m.isDeclareClass = BS;
m.isDeclareExportAllDeclaration = WS;
m.isDeclareExportDeclaration = qS;
m.isDeclareFunction = FS;
m.isDeclareInterface = jS;
m.isDeclareModule = RS;
m.isDeclareModuleExports = $S;
m.isDeclareOpaqueType = VS;
m.isDeclareTypeAlias = US;
m.isDeclareVariable = KS;
m.isDeclaredPredicate = YS;
m.isDecorator = lg;
m.isDirective = t0;
m.isDirectiveLiteral = r0;
m.isDoExpression = ug;
m.isDoWhileStatement = c0;
m.isEmptyStatement = f0;
m.isEmptyTypeAnnotation = ib;
m.isEnumBody = yP;
m.isEnumBooleanBody = _b;
m.isEnumBooleanMember = Mb;
m.isEnumDeclaration = Nb;
m.isEnumDefaultedMember = jb;
m.isEnumMember = TP;
m.isEnumNumberBody = Db;
m.isEnumNumberMember = Bb;
m.isEnumStringBody = kb;
m.isEnumStringMember = Fb;
m.isEnumSymbolBody = Lb;
m.isExistsTypeAnnotation = XS;
m.isExportAllDeclaration = eS;
m.isExportDeclaration = oP;
m.isExportDefaultDeclaration = tS;
m.isExportDefaultSpecifier = cg;
m.isExportNamedDeclaration = rS;
m.isExportNamespaceSpecifier = ES;
m.isExportSpecifier = iS;
m.isExpression = _E;
m.isExpressionStatement = p0;
m.isExpressionWrapper = VE;
m.isFile = h0;
m.isFlow = fP;
m.isFlowBaseAnnotation = hP;
m.isFlowDeclaration = dP;
m.isFlowPredicate = mP;
m.isFlowType = pP;
m.isFor = KE;
m.isForInStatement = d0;
m.isForOfStatement = sS;
m.isForStatement = m0;
m.isForXStatement = qE;
m.isFunction = WE;
m.isFunctionDeclaration = y0;
m.isFunctionExpression = T0;
m.isFunctionParent = YE;
m.isFunctionTypeAnnotation = JS;
m.isFunctionTypeParam = HS;
m.isGenericTypeAnnotation = GS;
m.isIdentifier = S0;
m.isIfStatement = b0;
m.isImmutable = ZE;
m.isImport = bS;
m.isImportAttribute = og;
m.isImportDeclaration = nS;
m.isImportDefaultSpecifier = aS;
m.isImportNamespaceSpecifier = oS;
m.isImportOrExportDeclaration = hc;
m.isImportSpecifier = lS;
m.isIndexedAccessType = Rb;
m.isInferredPredicate = zS;
m.isInterfaceDeclaration = ZS;
m.isInterfaceExtends = QS;
m.isInterfaceTypeAnnotation = eb;
m.isInterpreterDirective = e0;
m.isIntersectionTypeAnnotation = tb;
m.isJSX = SP;
m.isJSXAttribute = Ub;
m.isJSXClosingElement = Vb;
m.isJSXClosingFragment = tg;
m.isJSXElement = Kb;
m.isJSXEmptyExpression = qb;
m.isJSXExpressionContainer = Wb;
m.isJSXFragment = Zb;
m.isJSXIdentifier = Xb;
m.isJSXMemberExpression = Jb;
m.isJSXNamespacedName = Hb;
m.isJSXOpeningElement = Gb;
m.isJSXOpeningFragment = eg;
m.isJSXSpreadAttribute = zb;
m.isJSXSpreadChild = Yb;
m.isJSXText = Qb;
m.isLVal = GE;
m.isLabeledStatement = g0;
m.isLiteral = QE;
m.isLogicalExpression = C0;
m.isLoop = $E;
m.isMemberExpression = I0;
m.isMetaProperty = uS;
m.isMethod = tP;
m.isMiscellaneous = bP;
m.isMixedTypeAnnotation = rb;
m.isModuleDeclaration = wP;
m.isModuleExpression = dg;
m.isModuleSpecifier = lP;
m.isNewExpression = w0;
m.isNoop = rg;
m.isNullLiteral = x0;
m.isNullLiteralTypeAnnotation = LS;
m.isNullableTypeAnnotation = sb;
m.isNumberLiteral = vP;
m.isNumberLiteralTypeAnnotation = nb;
m.isNumberTypeAnnotation = ab;
m.isNumericLiteral = P0;
m.isObjectExpression = N0;
m.isObjectMember = rP;
m.isObjectMethod = _0;
m.isObjectPattern = fS;
m.isObjectProperty = D0;
m.isObjectTypeAnnotation = ob;
m.isObjectTypeCallProperty = ub;
m.isObjectTypeIndexer = cb;
m.isObjectTypeInternalSlot = lb;
m.isObjectTypeProperty = fb;
m.isObjectTypeSpreadProperty = pb;
m.isOpaqueType = hb;
m.isOptionalCallExpression = xS;
m.isOptionalIndexedAccessType = $b;
m.isOptionalMemberExpression = PS;
m.isParenthesizedExpression = B0;
m.isPattern = nP;
m.isPatternLike = HE;
m.isPipelineBareFunction = Tg;
m.isPipelinePrimaryTopicReference = Sg;
m.isPipelineTopicExpression = yg;
m.isPlaceholder = ig;
m.isPrivate = cP;
m.isPrivateName = wS;
m.isProgram = O0;
m.isProperty = iP;
m.isPureish = XE;
m.isQualifiedTypeIdentifier = db;
m.isRecordExpression = fg;
m.isRegExpLiteral = A0;
m.isRegexLiteral = AP;
m.isRestElement = k0;
m.isRestProperty = CP;
m.isReturnStatement = L0;
m.isScopable = kE;
m.isSequenceExpression = M0;
m.isSpreadElement = pS;
m.isSpreadProperty = IP;
m.isStandardized = NE;
m.isStatement = BE;
m.isStaticBlock = OS;
m.isStringLiteral = E0;
m.isStringLiteralTypeAnnotation = mb;
m.isStringTypeAnnotation = yb;
m.isSuper = hS;
m.isSwitchCase = F0;
m.isSwitchStatement = j0;
m.isSymbolTypeAnnotation = Tb;
m.isTSAnyKeyword = wg;
m.isTSArrayType = Jg;
m.isTSAsExpression = hE;
m.isTSBaseType = xP;
m.isTSBigIntKeyword = Ng;
m.isTSBooleanKeyword = Og;
m.isTSCallSignatureDeclaration = xg;
m.isTSConditionalType = tE;
m.isTSConstructSignatureDeclaration = vg;
m.isTSConstructorType = Kg;
m.isTSDeclareFunction = gg;
m.isTSDeclareMethod = Eg;
m.isTSEntityName = zE;
m.isTSEnumDeclaration = yE;
m.isTSEnumMember = TE;
m.isTSExportAssignment = vE;
m.isTSExpressionWithTypeArguments = lE;
m.isTSExternalModuleReference = PE;
m.isTSFunctionType = Vg;
m.isTSImportEqualsDeclaration = EE;
m.isTSImportType = gE;
m.isTSIndexSignature = Ig;
m.isTSIndexedAccessType = nE;
m.isTSInferType = rE;
m.isTSInstantiationExpression = pE;
m.isTSInterfaceBody = cE;
m.isTSInterfaceDeclaration = uE;
m.isTSIntersectionType = eE;
m.isTSIntrinsicKeyword = _g;
m.isTSLiteralType = oE;
m.isTSMappedType = aE;
m.isTSMethodSignature = Cg;
m.isTSModuleBlock = bE;
m.isTSModuleDeclaration = SE;
m.isTSNamedTupleMember = Qg;
m.isTSNamespaceExportDeclaration = AE;
m.isTSNeverKeyword = Dg;
m.isTSNonNullExpression = xE;
m.isTSNullKeyword = kg;
m.isTSNumberKeyword = Lg;
m.isTSObjectKeyword = Mg;
m.isTSOptionalType = Gg;
m.isTSParameterProperty = bg;
m.isTSParenthesizedType = iE;
m.isTSPropertySignature = Ag;
m.isTSQualifiedName = Pg;
m.isTSRestType = zg;
m.isTSSatisfiesExpression = dE;
m.isTSStringKeyword = Bg;
m.isTSSymbolKeyword = Fg;
m.isTSThisType = Ug;
m.isTSTupleType = Hg;
m.isTSType = PP;
m.isTSTypeAliasDeclaration = fE;
m.isTSTypeAnnotation = CE;
m.isTSTypeAssertion = mE;
m.isTSTypeElement = EP;
m.isTSTypeLiteral = Xg;
m.isTSTypeOperator = sE;
m.isTSTypeParameter = OE;
m.isTSTypeParameterDeclaration = wE;
m.isTSTypeParameterInstantiation = IE;
m.isTSTypePredicate = Wg;
m.isTSTypeQuery = Yg;
m.isTSTypeReference = qg;
m.isTSUndefinedKeyword = jg;
m.isTSUnionType = Zg;
m.isTSUnknownKeyword = Rg;
m.isTSVoidKeyword = $g;
m.isTaggedTemplateExpression = dS;
m.isTemplateElement = mS;
m.isTemplateLiteral = yS;
m.isTerminatorless = FE;
m.isThisExpression = R0;
m.isThisTypeAnnotation = Sb;
m.isThrowStatement = $0;
m.isTopicReference = mg;
m.isTryStatement = U0;
m.isTupleExpression = pg;
m.isTupleTypeAnnotation = bb;
m.isTypeAlias = Eb;
m.isTypeAnnotation = Pb;
m.isTypeCastExpression = xb;
m.isTypeParameter = vb;
m.isTypeParameterDeclaration = Ab;
m.isTypeParameterInstantiation = Cb;
m.isTypeScript = gP;
m.isTypeofTypeAnnotation = gb;
m.isUnaryExpression = V0;
m.isUnaryLike = sP;
m.isUnionTypeAnnotation = Ib;
m.isUpdateExpression = K0;
m.isUserWhitespacable = eP;
m.isV8IntrinsicIdentifier = sg;
m.isVariableDeclaration = q0;
m.isVariableDeclarator = W0;
m.isVariance = wb;
m.isVoidTypeAnnotation = Ob;
m.isWhile = UE;
m.isWhileStatement = Y0;
m.isWithStatement = X0;
m.isYieldExpression = TS;
var g = ui, ci = Mr;
function zT(e, t) {
  return !e || e.type !== "ArrayExpression" ? !1 : t == null || (0, g.default)(e, t);
}
function QT(e, t) {
  return !e || e.type !== "AssignmentExpression" ? !1 : t == null || (0, g.default)(e, t);
}
function ZT(e, t) {
  return !e || e.type !== "BinaryExpression" ? !1 : t == null || (0, g.default)(e, t);
}
function e0(e, t) {
  return !e || e.type !== "InterpreterDirective" ? !1 : t == null || (0, g.default)(e, t);
}
function t0(e, t) {
  return !e || e.type !== "Directive" ? !1 : t == null || (0, g.default)(e, t);
}
function r0(e, t) {
  return !e || e.type !== "DirectiveLiteral" ? !1 : t == null || (0, g.default)(e, t);
}
function i0(e, t) {
  return !e || e.type !== "BlockStatement" ? !1 : t == null || (0, g.default)(e, t);
}
function s0(e, t) {
  return !e || e.type !== "BreakStatement" ? !1 : t == null || (0, g.default)(e, t);
}
function n0(e, t) {
  return !e || e.type !== "CallExpression" ? !1 : t == null || (0, g.default)(e, t);
}
function a0(e, t) {
  return !e || e.type !== "CatchClause" ? !1 : t == null || (0, g.default)(e, t);
}
function o0(e, t) {
  return !e || e.type !== "ConditionalExpression" ? !1 : t == null || (0, g.default)(e, t);
}
function l0(e, t) {
  return !e || e.type !== "ContinueStatement" ? !1 : t == null || (0, g.default)(e, t);
}
function u0(e, t) {
  return !e || e.type !== "DebuggerStatement" ? !1 : t == null || (0, g.default)(e, t);
}
function c0(e, t) {
  return !e || e.type !== "DoWhileStatement" ? !1 : t == null || (0, g.default)(e, t);
}
function f0(e, t) {
  return !e || e.type !== "EmptyStatement" ? !1 : t == null || (0, g.default)(e, t);
}
function p0(e, t) {
  return !e || e.type !== "ExpressionStatement" ? !1 : t == null || (0, g.default)(e, t);
}
function h0(e, t) {
  return !e || e.type !== "File" ? !1 : t == null || (0, g.default)(e, t);
}
function d0(e, t) {
  return !e || e.type !== "ForInStatement" ? !1 : t == null || (0, g.default)(e, t);
}
function m0(e, t) {
  return !e || e.type !== "ForStatement" ? !1 : t == null || (0, g.default)(e, t);
}
function y0(e, t) {
  return !e || e.type !== "FunctionDeclaration" ? !1 : t == null || (0, g.default)(e, t);
}
function T0(e, t) {
  return !e || e.type !== "FunctionExpression" ? !1 : t == null || (0, g.default)(e, t);
}
function S0(e, t) {
  return !e || e.type !== "Identifier" ? !1 : t == null || (0, g.default)(e, t);
}
function b0(e, t) {
  return !e || e.type !== "IfStatement" ? !1 : t == null || (0, g.default)(e, t);
}
function g0(e, t) {
  return !e || e.type !== "LabeledStatement" ? !1 : t == null || (0, g.default)(e, t);
}
function E0(e, t) {
  return !e || e.type !== "StringLiteral" ? !1 : t == null || (0, g.default)(e, t);
}
function P0(e, t) {
  return !e || e.type !== "NumericLiteral" ? !1 : t == null || (0, g.default)(e, t);
}
function x0(e, t) {
  return !e || e.type !== "NullLiteral" ? !1 : t == null || (0, g.default)(e, t);
}
function v0(e, t) {
  return !e || e.type !== "BooleanLiteral" ? !1 : t == null || (0, g.default)(e, t);
}
function A0(e, t) {
  return !e || e.type !== "RegExpLiteral" ? !1 : t == null || (0, g.default)(e, t);
}
function C0(e, t) {
  return !e || e.type !== "LogicalExpression" ? !1 : t == null || (0, g.default)(e, t);
}
function I0(e, t) {
  return !e || e.type !== "MemberExpression" ? !1 : t == null || (0, g.default)(e, t);
}
function w0(e, t) {
  return !e || e.type !== "NewExpression" ? !1 : t == null || (0, g.default)(e, t);
}
function O0(e, t) {
  return !e || e.type !== "Program" ? !1 : t == null || (0, g.default)(e, t);
}
function N0(e, t) {
  return !e || e.type !== "ObjectExpression" ? !1 : t == null || (0, g.default)(e, t);
}
function _0(e, t) {
  return !e || e.type !== "ObjectMethod" ? !1 : t == null || (0, g.default)(e, t);
}
function D0(e, t) {
  return !e || e.type !== "ObjectProperty" ? !1 : t == null || (0, g.default)(e, t);
}
function k0(e, t) {
  return !e || e.type !== "RestElement" ? !1 : t == null || (0, g.default)(e, t);
}
function L0(e, t) {
  return !e || e.type !== "ReturnStatement" ? !1 : t == null || (0, g.default)(e, t);
}
function M0(e, t) {
  return !e || e.type !== "SequenceExpression" ? !1 : t == null || (0, g.default)(e, t);
}
function B0(e, t) {
  return !e || e.type !== "ParenthesizedExpression" ? !1 : t == null || (0, g.default)(e, t);
}
function F0(e, t) {
  return !e || e.type !== "SwitchCase" ? !1 : t == null || (0, g.default)(e, t);
}
function j0(e, t) {
  return !e || e.type !== "SwitchStatement" ? !1 : t == null || (0, g.default)(e, t);
}
function R0(e, t) {
  return !e || e.type !== "ThisExpression" ? !1 : t == null || (0, g.default)(e, t);
}
function $0(e, t) {
  return !e || e.type !== "ThrowStatement" ? !1 : t == null || (0, g.default)(e, t);
}
function U0(e, t) {
  return !e || e.type !== "TryStatement" ? !1 : t == null || (0, g.default)(e, t);
}
function V0(e, t) {
  return !e || e.type !== "UnaryExpression" ? !1 : t == null || (0, g.default)(e, t);
}
function K0(e, t) {
  return !e || e.type !== "UpdateExpression" ? !1 : t == null || (0, g.default)(e, t);
}
function q0(e, t) {
  return !e || e.type !== "VariableDeclaration" ? !1 : t == null || (0, g.default)(e, t);
}
function W0(e, t) {
  return !e || e.type !== "VariableDeclarator" ? !1 : t == null || (0, g.default)(e, t);
}
function Y0(e, t) {
  return !e || e.type !== "WhileStatement" ? !1 : t == null || (0, g.default)(e, t);
}
function X0(e, t) {
  return !e || e.type !== "WithStatement" ? !1 : t == null || (0, g.default)(e, t);
}
function J0(e, t) {
  return !e || e.type !== "AssignmentPattern" ? !1 : t == null || (0, g.default)(e, t);
}
function H0(e, t) {
  return !e || e.type !== "ArrayPattern" ? !1 : t == null || (0, g.default)(e, t);
}
function G0(e, t) {
  return !e || e.type !== "ArrowFunctionExpression" ? !1 : t == null || (0, g.default)(e, t);
}
function z0(e, t) {
  return !e || e.type !== "ClassBody" ? !1 : t == null || (0, g.default)(e, t);
}
function Q0(e, t) {
  return !e || e.type !== "ClassExpression" ? !1 : t == null || (0, g.default)(e, t);
}
function Z0(e, t) {
  return !e || e.type !== "ClassDeclaration" ? !1 : t == null || (0, g.default)(e, t);
}
function eS(e, t) {
  return !e || e.type !== "ExportAllDeclaration" ? !1 : t == null || (0, g.default)(e, t);
}
function tS(e, t) {
  return !e || e.type !== "ExportDefaultDeclaration" ? !1 : t == null || (0, g.default)(e, t);
}
function rS(e, t) {
  return !e || e.type !== "ExportNamedDeclaration" ? !1 : t == null || (0, g.default)(e, t);
}
function iS(e, t) {
  return !e || e.type !== "ExportSpecifier" ? !1 : t == null || (0, g.default)(e, t);
}
function sS(e, t) {
  return !e || e.type !== "ForOfStatement" ? !1 : t == null || (0, g.default)(e, t);
}
function nS(e, t) {
  return !e || e.type !== "ImportDeclaration" ? !1 : t == null || (0, g.default)(e, t);
}
function aS(e, t) {
  return !e || e.type !== "ImportDefaultSpecifier" ? !1 : t == null || (0, g.default)(e, t);
}
function oS(e, t) {
  return !e || e.type !== "ImportNamespaceSpecifier" ? !1 : t == null || (0, g.default)(e, t);
}
function lS(e, t) {
  return !e || e.type !== "ImportSpecifier" ? !1 : t == null || (0, g.default)(e, t);
}
function uS(e, t) {
  return !e || e.type !== "MetaProperty" ? !1 : t == null || (0, g.default)(e, t);
}
function cS(e, t) {
  return !e || e.type !== "ClassMethod" ? !1 : t == null || (0, g.default)(e, t);
}
function fS(e, t) {
  return !e || e.type !== "ObjectPattern" ? !1 : t == null || (0, g.default)(e, t);
}
function pS(e, t) {
  return !e || e.type !== "SpreadElement" ? !1 : t == null || (0, g.default)(e, t);
}
function hS(e, t) {
  return !e || e.type !== "Super" ? !1 : t == null || (0, g.default)(e, t);
}
function dS(e, t) {
  return !e || e.type !== "TaggedTemplateExpression" ? !1 : t == null || (0, g.default)(e, t);
}
function mS(e, t) {
  return !e || e.type !== "TemplateElement" ? !1 : t == null || (0, g.default)(e, t);
}
function yS(e, t) {
  return !e || e.type !== "TemplateLiteral" ? !1 : t == null || (0, g.default)(e, t);
}
function TS(e, t) {
  return !e || e.type !== "YieldExpression" ? !1 : t == null || (0, g.default)(e, t);
}
function SS(e, t) {
  return !e || e.type !== "AwaitExpression" ? !1 : t == null || (0, g.default)(e, t);
}
function bS(e, t) {
  return !e || e.type !== "Import" ? !1 : t == null || (0, g.default)(e, t);
}
function gS(e, t) {
  return !e || e.type !== "BigIntLiteral" ? !1 : t == null || (0, g.default)(e, t);
}
function ES(e, t) {
  return !e || e.type !== "ExportNamespaceSpecifier" ? !1 : t == null || (0, g.default)(e, t);
}
function PS(e, t) {
  return !e || e.type !== "OptionalMemberExpression" ? !1 : t == null || (0, g.default)(e, t);
}
function xS(e, t) {
  return !e || e.type !== "OptionalCallExpression" ? !1 : t == null || (0, g.default)(e, t);
}
function vS(e, t) {
  return !e || e.type !== "ClassProperty" ? !1 : t == null || (0, g.default)(e, t);
}
function AS(e, t) {
  return !e || e.type !== "ClassAccessorProperty" ? !1 : t == null || (0, g.default)(e, t);
}
function CS(e, t) {
  return !e || e.type !== "ClassPrivateProperty" ? !1 : t == null || (0, g.default)(e, t);
}
function IS(e, t) {
  return !e || e.type !== "ClassPrivateMethod" ? !1 : t == null || (0, g.default)(e, t);
}
function wS(e, t) {
  return !e || e.type !== "PrivateName" ? !1 : t == null || (0, g.default)(e, t);
}
function OS(e, t) {
  return !e || e.type !== "StaticBlock" ? !1 : t == null || (0, g.default)(e, t);
}
function NS(e, t) {
  return !e || e.type !== "AnyTypeAnnotation" ? !1 : t == null || (0, g.default)(e, t);
}
function _S(e, t) {
  return !e || e.type !== "ArrayTypeAnnotation" ? !1 : t == null || (0, g.default)(e, t);
}
function DS(e, t) {
  return !e || e.type !== "BooleanTypeAnnotation" ? !1 : t == null || (0, g.default)(e, t);
}
function kS(e, t) {
  return !e || e.type !== "BooleanLiteralTypeAnnotation" ? !1 : t == null || (0, g.default)(e, t);
}
function LS(e, t) {
  return !e || e.type !== "NullLiteralTypeAnnotation" ? !1 : t == null || (0, g.default)(e, t);
}
function MS(e, t) {
  return !e || e.type !== "ClassImplements" ? !1 : t == null || (0, g.default)(e, t);
}
function BS(e, t) {
  return !e || e.type !== "DeclareClass" ? !1 : t == null || (0, g.default)(e, t);
}
function FS(e, t) {
  return !e || e.type !== "DeclareFunction" ? !1 : t == null || (0, g.default)(e, t);
}
function jS(e, t) {
  return !e || e.type !== "DeclareInterface" ? !1 : t == null || (0, g.default)(e, t);
}
function RS(e, t) {
  return !e || e.type !== "DeclareModule" ? !1 : t == null || (0, g.default)(e, t);
}
function $S(e, t) {
  return !e || e.type !== "DeclareModuleExports" ? !1 : t == null || (0, g.default)(e, t);
}
function US(e, t) {
  return !e || e.type !== "DeclareTypeAlias" ? !1 : t == null || (0, g.default)(e, t);
}
function VS(e, t) {
  return !e || e.type !== "DeclareOpaqueType" ? !1 : t == null || (0, g.default)(e, t);
}
function KS(e, t) {
  return !e || e.type !== "DeclareVariable" ? !1 : t == null || (0, g.default)(e, t);
}
function qS(e, t) {
  return !e || e.type !== "DeclareExportDeclaration" ? !1 : t == null || (0, g.default)(e, t);
}
function WS(e, t) {
  return !e || e.type !== "DeclareExportAllDeclaration" ? !1 : t == null || (0, g.default)(e, t);
}
function YS(e, t) {
  return !e || e.type !== "DeclaredPredicate" ? !1 : t == null || (0, g.default)(e, t);
}
function XS(e, t) {
  return !e || e.type !== "ExistsTypeAnnotation" ? !1 : t == null || (0, g.default)(e, t);
}
function JS(e, t) {
  return !e || e.type !== "FunctionTypeAnnotation" ? !1 : t == null || (0, g.default)(e, t);
}
function HS(e, t) {
  return !e || e.type !== "FunctionTypeParam" ? !1 : t == null || (0, g.default)(e, t);
}
function GS(e, t) {
  return !e || e.type !== "GenericTypeAnnotation" ? !1 : t == null || (0, g.default)(e, t);
}
function zS(e, t) {
  return !e || e.type !== "InferredPredicate" ? !1 : t == null || (0, g.default)(e, t);
}
function QS(e, t) {
  return !e || e.type !== "InterfaceExtends" ? !1 : t == null || (0, g.default)(e, t);
}
function ZS(e, t) {
  return !e || e.type !== "InterfaceDeclaration" ? !1 : t == null || (0, g.default)(e, t);
}
function eb(e, t) {
  return !e || e.type !== "InterfaceTypeAnnotation" ? !1 : t == null || (0, g.default)(e, t);
}
function tb(e, t) {
  return !e || e.type !== "IntersectionTypeAnnotation" ? !1 : t == null || (0, g.default)(e, t);
}
function rb(e, t) {
  return !e || e.type !== "MixedTypeAnnotation" ? !1 : t == null || (0, g.default)(e, t);
}
function ib(e, t) {
  return !e || e.type !== "EmptyTypeAnnotation" ? !1 : t == null || (0, g.default)(e, t);
}
function sb(e, t) {
  return !e || e.type !== "NullableTypeAnnotation" ? !1 : t == null || (0, g.default)(e, t);
}
function nb(e, t) {
  return !e || e.type !== "NumberLiteralTypeAnnotation" ? !1 : t == null || (0, g.default)(e, t);
}
function ab(e, t) {
  return !e || e.type !== "NumberTypeAnnotation" ? !1 : t == null || (0, g.default)(e, t);
}
function ob(e, t) {
  return !e || e.type !== "ObjectTypeAnnotation" ? !1 : t == null || (0, g.default)(e, t);
}
function lb(e, t) {
  return !e || e.type !== "ObjectTypeInternalSlot" ? !1 : t == null || (0, g.default)(e, t);
}
function ub(e, t) {
  return !e || e.type !== "ObjectTypeCallProperty" ? !1 : t == null || (0, g.default)(e, t);
}
function cb(e, t) {
  return !e || e.type !== "ObjectTypeIndexer" ? !1 : t == null || (0, g.default)(e, t);
}
function fb(e, t) {
  return !e || e.type !== "ObjectTypeProperty" ? !1 : t == null || (0, g.default)(e, t);
}
function pb(e, t) {
  return !e || e.type !== "ObjectTypeSpreadProperty" ? !1 : t == null || (0, g.default)(e, t);
}
function hb(e, t) {
  return !e || e.type !== "OpaqueType" ? !1 : t == null || (0, g.default)(e, t);
}
function db(e, t) {
  return !e || e.type !== "QualifiedTypeIdentifier" ? !1 : t == null || (0, g.default)(e, t);
}
function mb(e, t) {
  return !e || e.type !== "StringLiteralTypeAnnotation" ? !1 : t == null || (0, g.default)(e, t);
}
function yb(e, t) {
  return !e || e.type !== "StringTypeAnnotation" ? !1 : t == null || (0, g.default)(e, t);
}
function Tb(e, t) {
  return !e || e.type !== "SymbolTypeAnnotation" ? !1 : t == null || (0, g.default)(e, t);
}
function Sb(e, t) {
  return !e || e.type !== "ThisTypeAnnotation" ? !1 : t == null || (0, g.default)(e, t);
}
function bb(e, t) {
  return !e || e.type !== "TupleTypeAnnotation" ? !1 : t == null || (0, g.default)(e, t);
}
function gb(e, t) {
  return !e || e.type !== "TypeofTypeAnnotation" ? !1 : t == null || (0, g.default)(e, t);
}
function Eb(e, t) {
  return !e || e.type !== "TypeAlias" ? !1 : t == null || (0, g.default)(e, t);
}
function Pb(e, t) {
  return !e || e.type !== "TypeAnnotation" ? !1 : t == null || (0, g.default)(e, t);
}
function xb(e, t) {
  return !e || e.type !== "TypeCastExpression" ? !1 : t == null || (0, g.default)(e, t);
}
function vb(e, t) {
  return !e || e.type !== "TypeParameter" ? !1 : t == null || (0, g.default)(e, t);
}
function Ab(e, t) {
  return !e || e.type !== "TypeParameterDeclaration" ? !1 : t == null || (0, g.default)(e, t);
}
function Cb(e, t) {
  return !e || e.type !== "TypeParameterInstantiation" ? !1 : t == null || (0, g.default)(e, t);
}
function Ib(e, t) {
  return !e || e.type !== "UnionTypeAnnotation" ? !1 : t == null || (0, g.default)(e, t);
}
function wb(e, t) {
  return !e || e.type !== "Variance" ? !1 : t == null || (0, g.default)(e, t);
}
function Ob(e, t) {
  return !e || e.type !== "VoidTypeAnnotation" ? !1 : t == null || (0, g.default)(e, t);
}
function Nb(e, t) {
  return !e || e.type !== "EnumDeclaration" ? !1 : t == null || (0, g.default)(e, t);
}
function _b(e, t) {
  return !e || e.type !== "EnumBooleanBody" ? !1 : t == null || (0, g.default)(e, t);
}
function Db(e, t) {
  return !e || e.type !== "EnumNumberBody" ? !1 : t == null || (0, g.default)(e, t);
}
function kb(e, t) {
  return !e || e.type !== "EnumStringBody" ? !1 : t == null || (0, g.default)(e, t);
}
function Lb(e, t) {
  return !e || e.type !== "EnumSymbolBody" ? !1 : t == null || (0, g.default)(e, t);
}
function Mb(e, t) {
  return !e || e.type !== "EnumBooleanMember" ? !1 : t == null || (0, g.default)(e, t);
}
function Bb(e, t) {
  return !e || e.type !== "EnumNumberMember" ? !1 : t == null || (0, g.default)(e, t);
}
function Fb(e, t) {
  return !e || e.type !== "EnumStringMember" ? !1 : t == null || (0, g.default)(e, t);
}
function jb(e, t) {
  return !e || e.type !== "EnumDefaultedMember" ? !1 : t == null || (0, g.default)(e, t);
}
function Rb(e, t) {
  return !e || e.type !== "IndexedAccessType" ? !1 : t == null || (0, g.default)(e, t);
}
function $b(e, t) {
  return !e || e.type !== "OptionalIndexedAccessType" ? !1 : t == null || (0, g.default)(e, t);
}
function Ub(e, t) {
  return !e || e.type !== "JSXAttribute" ? !1 : t == null || (0, g.default)(e, t);
}
function Vb(e, t) {
  return !e || e.type !== "JSXClosingElement" ? !1 : t == null || (0, g.default)(e, t);
}
function Kb(e, t) {
  return !e || e.type !== "JSXElement" ? !1 : t == null || (0, g.default)(e, t);
}
function qb(e, t) {
  return !e || e.type !== "JSXEmptyExpression" ? !1 : t == null || (0, g.default)(e, t);
}
function Wb(e, t) {
  return !e || e.type !== "JSXExpressionContainer" ? !1 : t == null || (0, g.default)(e, t);
}
function Yb(e, t) {
  return !e || e.type !== "JSXSpreadChild" ? !1 : t == null || (0, g.default)(e, t);
}
function Xb(e, t) {
  return !e || e.type !== "JSXIdentifier" ? !1 : t == null || (0, g.default)(e, t);
}
function Jb(e, t) {
  return !e || e.type !== "JSXMemberExpression" ? !1 : t == null || (0, g.default)(e, t);
}
function Hb(e, t) {
  return !e || e.type !== "JSXNamespacedName" ? !1 : t == null || (0, g.default)(e, t);
}
function Gb(e, t) {
  return !e || e.type !== "JSXOpeningElement" ? !1 : t == null || (0, g.default)(e, t);
}
function zb(e, t) {
  return !e || e.type !== "JSXSpreadAttribute" ? !1 : t == null || (0, g.default)(e, t);
}
function Qb(e, t) {
  return !e || e.type !== "JSXText" ? !1 : t == null || (0, g.default)(e, t);
}
function Zb(e, t) {
  return !e || e.type !== "JSXFragment" ? !1 : t == null || (0, g.default)(e, t);
}
function eg(e, t) {
  return !e || e.type !== "JSXOpeningFragment" ? !1 : t == null || (0, g.default)(e, t);
}
function tg(e, t) {
  return !e || e.type !== "JSXClosingFragment" ? !1 : t == null || (0, g.default)(e, t);
}
function rg(e, t) {
  return !e || e.type !== "Noop" ? !1 : t == null || (0, g.default)(e, t);
}
function ig(e, t) {
  return !e || e.type !== "Placeholder" ? !1 : t == null || (0, g.default)(e, t);
}
function sg(e, t) {
  return !e || e.type !== "V8IntrinsicIdentifier" ? !1 : t == null || (0, g.default)(e, t);
}
function ng(e, t) {
  return !e || e.type !== "ArgumentPlaceholder" ? !1 : t == null || (0, g.default)(e, t);
}
function ag(e, t) {
  return !e || e.type !== "BindExpression" ? !1 : t == null || (0, g.default)(e, t);
}
function og(e, t) {
  return !e || e.type !== "ImportAttribute" ? !1 : t == null || (0, g.default)(e, t);
}
function lg(e, t) {
  return !e || e.type !== "Decorator" ? !1 : t == null || (0, g.default)(e, t);
}
function ug(e, t) {
  return !e || e.type !== "DoExpression" ? !1 : t == null || (0, g.default)(e, t);
}
function cg(e, t) {
  return !e || e.type !== "ExportDefaultSpecifier" ? !1 : t == null || (0, g.default)(e, t);
}
function fg(e, t) {
  return !e || e.type !== "RecordExpression" ? !1 : t == null || (0, g.default)(e, t);
}
function pg(e, t) {
  return !e || e.type !== "TupleExpression" ? !1 : t == null || (0, g.default)(e, t);
}
function hg(e, t) {
  return !e || e.type !== "DecimalLiteral" ? !1 : t == null || (0, g.default)(e, t);
}
function dg(e, t) {
  return !e || e.type !== "ModuleExpression" ? !1 : t == null || (0, g.default)(e, t);
}
function mg(e, t) {
  return !e || e.type !== "TopicReference" ? !1 : t == null || (0, g.default)(e, t);
}
function yg(e, t) {
  return !e || e.type !== "PipelineTopicExpression" ? !1 : t == null || (0, g.default)(e, t);
}
function Tg(e, t) {
  return !e || e.type !== "PipelineBareFunction" ? !1 : t == null || (0, g.default)(e, t);
}
function Sg(e, t) {
  return !e || e.type !== "PipelinePrimaryTopicReference" ? !1 : t == null || (0, g.default)(e, t);
}
function bg(e, t) {
  return !e || e.type !== "TSParameterProperty" ? !1 : t == null || (0, g.default)(e, t);
}
function gg(e, t) {
  return !e || e.type !== "TSDeclareFunction" ? !1 : t == null || (0, g.default)(e, t);
}
function Eg(e, t) {
  return !e || e.type !== "TSDeclareMethod" ? !1 : t == null || (0, g.default)(e, t);
}
function Pg(e, t) {
  return !e || e.type !== "TSQualifiedName" ? !1 : t == null || (0, g.default)(e, t);
}
function xg(e, t) {
  return !e || e.type !== "TSCallSignatureDeclaration" ? !1 : t == null || (0, g.default)(e, t);
}
function vg(e, t) {
  return !e || e.type !== "TSConstructSignatureDeclaration" ? !1 : t == null || (0, g.default)(e, t);
}
function Ag(e, t) {
  return !e || e.type !== "TSPropertySignature" ? !1 : t == null || (0, g.default)(e, t);
}
function Cg(e, t) {
  return !e || e.type !== "TSMethodSignature" ? !1 : t == null || (0, g.default)(e, t);
}
function Ig(e, t) {
  return !e || e.type !== "TSIndexSignature" ? !1 : t == null || (0, g.default)(e, t);
}
function wg(e, t) {
  return !e || e.type !== "TSAnyKeyword" ? !1 : t == null || (0, g.default)(e, t);
}
function Og(e, t) {
  return !e || e.type !== "TSBooleanKeyword" ? !1 : t == null || (0, g.default)(e, t);
}
function Ng(e, t) {
  return !e || e.type !== "TSBigIntKeyword" ? !1 : t == null || (0, g.default)(e, t);
}
function _g(e, t) {
  return !e || e.type !== "TSIntrinsicKeyword" ? !1 : t == null || (0, g.default)(e, t);
}
function Dg(e, t) {
  return !e || e.type !== "TSNeverKeyword" ? !1 : t == null || (0, g.default)(e, t);
}
function kg(e, t) {
  return !e || e.type !== "TSNullKeyword" ? !1 : t == null || (0, g.default)(e, t);
}
function Lg(e, t) {
  return !e || e.type !== "TSNumberKeyword" ? !1 : t == null || (0, g.default)(e, t);
}
function Mg(e, t) {
  return !e || e.type !== "TSObjectKeyword" ? !1 : t == null || (0, g.default)(e, t);
}
function Bg(e, t) {
  return !e || e.type !== "TSStringKeyword" ? !1 : t == null || (0, g.default)(e, t);
}
function Fg(e, t) {
  return !e || e.type !== "TSSymbolKeyword" ? !1 : t == null || (0, g.default)(e, t);
}
function jg(e, t) {
  return !e || e.type !== "TSUndefinedKeyword" ? !1 : t == null || (0, g.default)(e, t);
}
function Rg(e, t) {
  return !e || e.type !== "TSUnknownKeyword" ? !1 : t == null || (0, g.default)(e, t);
}
function $g(e, t) {
  return !e || e.type !== "TSVoidKeyword" ? !1 : t == null || (0, g.default)(e, t);
}
function Ug(e, t) {
  return !e || e.type !== "TSThisType" ? !1 : t == null || (0, g.default)(e, t);
}
function Vg(e, t) {
  return !e || e.type !== "TSFunctionType" ? !1 : t == null || (0, g.default)(e, t);
}
function Kg(e, t) {
  return !e || e.type !== "TSConstructorType" ? !1 : t == null || (0, g.default)(e, t);
}
function qg(e, t) {
  return !e || e.type !== "TSTypeReference" ? !1 : t == null || (0, g.default)(e, t);
}
function Wg(e, t) {
  return !e || e.type !== "TSTypePredicate" ? !1 : t == null || (0, g.default)(e, t);
}
function Yg(e, t) {
  return !e || e.type !== "TSTypeQuery" ? !1 : t == null || (0, g.default)(e, t);
}
function Xg(e, t) {
  return !e || e.type !== "TSTypeLiteral" ? !1 : t == null || (0, g.default)(e, t);
}
function Jg(e, t) {
  return !e || e.type !== "TSArrayType" ? !1 : t == null || (0, g.default)(e, t);
}
function Hg(e, t) {
  return !e || e.type !== "TSTupleType" ? !1 : t == null || (0, g.default)(e, t);
}
function Gg(e, t) {
  return !e || e.type !== "TSOptionalType" ? !1 : t == null || (0, g.default)(e, t);
}
function zg(e, t) {
  return !e || e.type !== "TSRestType" ? !1 : t == null || (0, g.default)(e, t);
}
function Qg(e, t) {
  return !e || e.type !== "TSNamedTupleMember" ? !1 : t == null || (0, g.default)(e, t);
}
function Zg(e, t) {
  return !e || e.type !== "TSUnionType" ? !1 : t == null || (0, g.default)(e, t);
}
function eE(e, t) {
  return !e || e.type !== "TSIntersectionType" ? !1 : t == null || (0, g.default)(e, t);
}
function tE(e, t) {
  return !e || e.type !== "TSConditionalType" ? !1 : t == null || (0, g.default)(e, t);
}
function rE(e, t) {
  return !e || e.type !== "TSInferType" ? !1 : t == null || (0, g.default)(e, t);
}
function iE(e, t) {
  return !e || e.type !== "TSParenthesizedType" ? !1 : t == null || (0, g.default)(e, t);
}
function sE(e, t) {
  return !e || e.type !== "TSTypeOperator" ? !1 : t == null || (0, g.default)(e, t);
}
function nE(e, t) {
  return !e || e.type !== "TSIndexedAccessType" ? !1 : t == null || (0, g.default)(e, t);
}
function aE(e, t) {
  return !e || e.type !== "TSMappedType" ? !1 : t == null || (0, g.default)(e, t);
}
function oE(e, t) {
  return !e || e.type !== "TSLiteralType" ? !1 : t == null || (0, g.default)(e, t);
}
function lE(e, t) {
  return !e || e.type !== "TSExpressionWithTypeArguments" ? !1 : t == null || (0, g.default)(e, t);
}
function uE(e, t) {
  return !e || e.type !== "TSInterfaceDeclaration" ? !1 : t == null || (0, g.default)(e, t);
}
function cE(e, t) {
  return !e || e.type !== "TSInterfaceBody" ? !1 : t == null || (0, g.default)(e, t);
}
function fE(e, t) {
  return !e || e.type !== "TSTypeAliasDeclaration" ? !1 : t == null || (0, g.default)(e, t);
}
function pE(e, t) {
  return !e || e.type !== "TSInstantiationExpression" ? !1 : t == null || (0, g.default)(e, t);
}
function hE(e, t) {
  return !e || e.type !== "TSAsExpression" ? !1 : t == null || (0, g.default)(e, t);
}
function dE(e, t) {
  return !e || e.type !== "TSSatisfiesExpression" ? !1 : t == null || (0, g.default)(e, t);
}
function mE(e, t) {
  return !e || e.type !== "TSTypeAssertion" ? !1 : t == null || (0, g.default)(e, t);
}
function yE(e, t) {
  return !e || e.type !== "TSEnumDeclaration" ? !1 : t == null || (0, g.default)(e, t);
}
function TE(e, t) {
  return !e || e.type !== "TSEnumMember" ? !1 : t == null || (0, g.default)(e, t);
}
function SE(e, t) {
  return !e || e.type !== "TSModuleDeclaration" ? !1 : t == null || (0, g.default)(e, t);
}
function bE(e, t) {
  return !e || e.type !== "TSModuleBlock" ? !1 : t == null || (0, g.default)(e, t);
}
function gE(e, t) {
  return !e || e.type !== "TSImportType" ? !1 : t == null || (0, g.default)(e, t);
}
function EE(e, t) {
  return !e || e.type !== "TSImportEqualsDeclaration" ? !1 : t == null || (0, g.default)(e, t);
}
function PE(e, t) {
  return !e || e.type !== "TSExternalModuleReference" ? !1 : t == null || (0, g.default)(e, t);
}
function xE(e, t) {
  return !e || e.type !== "TSNonNullExpression" ? !1 : t == null || (0, g.default)(e, t);
}
function vE(e, t) {
  return !e || e.type !== "TSExportAssignment" ? !1 : t == null || (0, g.default)(e, t);
}
function AE(e, t) {
  return !e || e.type !== "TSNamespaceExportDeclaration" ? !1 : t == null || (0, g.default)(e, t);
}
function CE(e, t) {
  return !e || e.type !== "TSTypeAnnotation" ? !1 : t == null || (0, g.default)(e, t);
}
function IE(e, t) {
  return !e || e.type !== "TSTypeParameterInstantiation" ? !1 : t == null || (0, g.default)(e, t);
}
function wE(e, t) {
  return !e || e.type !== "TSTypeParameterDeclaration" ? !1 : t == null || (0, g.default)(e, t);
}
function OE(e, t) {
  return !e || e.type !== "TSTypeParameter" ? !1 : t == null || (0, g.default)(e, t);
}
function NE(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "ArrayExpression":
    case "AssignmentExpression":
    case "BinaryExpression":
    case "InterpreterDirective":
    case "Directive":
    case "DirectiveLiteral":
    case "BlockStatement":
    case "BreakStatement":
    case "CallExpression":
    case "CatchClause":
    case "ConditionalExpression":
    case "ContinueStatement":
    case "DebuggerStatement":
    case "DoWhileStatement":
    case "EmptyStatement":
    case "ExpressionStatement":
    case "File":
    case "ForInStatement":
    case "ForStatement":
    case "FunctionDeclaration":
    case "FunctionExpression":
    case "Identifier":
    case "IfStatement":
    case "LabeledStatement":
    case "StringLiteral":
    case "NumericLiteral":
    case "NullLiteral":
    case "BooleanLiteral":
    case "RegExpLiteral":
    case "LogicalExpression":
    case "MemberExpression":
    case "NewExpression":
    case "Program":
    case "ObjectExpression":
    case "ObjectMethod":
    case "ObjectProperty":
    case "RestElement":
    case "ReturnStatement":
    case "SequenceExpression":
    case "ParenthesizedExpression":
    case "SwitchCase":
    case "SwitchStatement":
    case "ThisExpression":
    case "ThrowStatement":
    case "TryStatement":
    case "UnaryExpression":
    case "UpdateExpression":
    case "VariableDeclaration":
    case "VariableDeclarator":
    case "WhileStatement":
    case "WithStatement":
    case "AssignmentPattern":
    case "ArrayPattern":
    case "ArrowFunctionExpression":
    case "ClassBody":
    case "ClassExpression":
    case "ClassDeclaration":
    case "ExportAllDeclaration":
    case "ExportDefaultDeclaration":
    case "ExportNamedDeclaration":
    case "ExportSpecifier":
    case "ForOfStatement":
    case "ImportDeclaration":
    case "ImportDefaultSpecifier":
    case "ImportNamespaceSpecifier":
    case "ImportSpecifier":
    case "MetaProperty":
    case "ClassMethod":
    case "ObjectPattern":
    case "SpreadElement":
    case "Super":
    case "TaggedTemplateExpression":
    case "TemplateElement":
    case "TemplateLiteral":
    case "YieldExpression":
    case "AwaitExpression":
    case "Import":
    case "BigIntLiteral":
    case "ExportNamespaceSpecifier":
    case "OptionalMemberExpression":
    case "OptionalCallExpression":
    case "ClassProperty":
    case "ClassAccessorProperty":
    case "ClassPrivateProperty":
    case "ClassPrivateMethod":
    case "PrivateName":
    case "StaticBlock":
      break;
    case "Placeholder":
      switch (e.expectedNode) {
        case "Identifier":
        case "StringLiteral":
        case "BlockStatement":
        case "ClassBody":
          break;
        default:
          return !1;
      }
      break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function _E(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "ArrayExpression":
    case "AssignmentExpression":
    case "BinaryExpression":
    case "CallExpression":
    case "ConditionalExpression":
    case "FunctionExpression":
    case "Identifier":
    case "StringLiteral":
    case "NumericLiteral":
    case "NullLiteral":
    case "BooleanLiteral":
    case "RegExpLiteral":
    case "LogicalExpression":
    case "MemberExpression":
    case "NewExpression":
    case "ObjectExpression":
    case "SequenceExpression":
    case "ParenthesizedExpression":
    case "ThisExpression":
    case "UnaryExpression":
    case "UpdateExpression":
    case "ArrowFunctionExpression":
    case "ClassExpression":
    case "MetaProperty":
    case "Super":
    case "TaggedTemplateExpression":
    case "TemplateLiteral":
    case "YieldExpression":
    case "AwaitExpression":
    case "Import":
    case "BigIntLiteral":
    case "OptionalMemberExpression":
    case "OptionalCallExpression":
    case "TypeCastExpression":
    case "JSXElement":
    case "JSXFragment":
    case "BindExpression":
    case "DoExpression":
    case "RecordExpression":
    case "TupleExpression":
    case "DecimalLiteral":
    case "ModuleExpression":
    case "TopicReference":
    case "PipelineTopicExpression":
    case "PipelineBareFunction":
    case "PipelinePrimaryTopicReference":
    case "TSInstantiationExpression":
    case "TSAsExpression":
    case "TSSatisfiesExpression":
    case "TSTypeAssertion":
    case "TSNonNullExpression":
      break;
    case "Placeholder":
      switch (e.expectedNode) {
        case "Expression":
        case "Identifier":
        case "StringLiteral":
          break;
        default:
          return !1;
      }
      break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function DE(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "BinaryExpression":
    case "LogicalExpression":
      break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function kE(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "BlockStatement":
    case "CatchClause":
    case "DoWhileStatement":
    case "ForInStatement":
    case "ForStatement":
    case "FunctionDeclaration":
    case "FunctionExpression":
    case "Program":
    case "ObjectMethod":
    case "SwitchStatement":
    case "WhileStatement":
    case "ArrowFunctionExpression":
    case "ClassExpression":
    case "ClassDeclaration":
    case "ForOfStatement":
    case "ClassMethod":
    case "ClassPrivateMethod":
    case "StaticBlock":
    case "TSModuleBlock":
      break;
    case "Placeholder":
      if (e.expectedNode === "BlockStatement")
        break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function LE(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "BlockStatement":
    case "CatchClause":
    case "DoWhileStatement":
    case "ForInStatement":
    case "ForStatement":
    case "FunctionDeclaration":
    case "FunctionExpression":
    case "Program":
    case "ObjectMethod":
    case "SwitchStatement":
    case "WhileStatement":
    case "ArrowFunctionExpression":
    case "ForOfStatement":
    case "ClassMethod":
    case "ClassPrivateMethod":
    case "StaticBlock":
    case "TSModuleBlock":
      break;
    case "Placeholder":
      if (e.expectedNode === "BlockStatement")
        break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function ME(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "BlockStatement":
    case "Program":
    case "TSModuleBlock":
      break;
    case "Placeholder":
      if (e.expectedNode === "BlockStatement")
        break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function BE(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "BlockStatement":
    case "BreakStatement":
    case "ContinueStatement":
    case "DebuggerStatement":
    case "DoWhileStatement":
    case "EmptyStatement":
    case "ExpressionStatement":
    case "ForInStatement":
    case "ForStatement":
    case "FunctionDeclaration":
    case "IfStatement":
    case "LabeledStatement":
    case "ReturnStatement":
    case "SwitchStatement":
    case "ThrowStatement":
    case "TryStatement":
    case "VariableDeclaration":
    case "WhileStatement":
    case "WithStatement":
    case "ClassDeclaration":
    case "ExportAllDeclaration":
    case "ExportDefaultDeclaration":
    case "ExportNamedDeclaration":
    case "ForOfStatement":
    case "ImportDeclaration":
    case "DeclareClass":
    case "DeclareFunction":
    case "DeclareInterface":
    case "DeclareModule":
    case "DeclareModuleExports":
    case "DeclareTypeAlias":
    case "DeclareOpaqueType":
    case "DeclareVariable":
    case "DeclareExportDeclaration":
    case "DeclareExportAllDeclaration":
    case "InterfaceDeclaration":
    case "OpaqueType":
    case "TypeAlias":
    case "EnumDeclaration":
    case "TSDeclareFunction":
    case "TSInterfaceDeclaration":
    case "TSTypeAliasDeclaration":
    case "TSEnumDeclaration":
    case "TSModuleDeclaration":
    case "TSImportEqualsDeclaration":
    case "TSExportAssignment":
    case "TSNamespaceExportDeclaration":
      break;
    case "Placeholder":
      switch (e.expectedNode) {
        case "Statement":
        case "Declaration":
        case "BlockStatement":
          break;
        default:
          return !1;
      }
      break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function FE(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "BreakStatement":
    case "ContinueStatement":
    case "ReturnStatement":
    case "ThrowStatement":
    case "YieldExpression":
    case "AwaitExpression":
      break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function jE(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "BreakStatement":
    case "ContinueStatement":
    case "ReturnStatement":
    case "ThrowStatement":
      break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function RE(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "ConditionalExpression":
    case "IfStatement":
      break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function $E(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "DoWhileStatement":
    case "ForInStatement":
    case "ForStatement":
    case "WhileStatement":
    case "ForOfStatement":
      break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function UE(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "DoWhileStatement":
    case "WhileStatement":
      break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function VE(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "ExpressionStatement":
    case "ParenthesizedExpression":
    case "TypeCastExpression":
      break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function KE(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "ForInStatement":
    case "ForStatement":
    case "ForOfStatement":
      break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function qE(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "ForInStatement":
    case "ForOfStatement":
      break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function WE(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "FunctionDeclaration":
    case "FunctionExpression":
    case "ObjectMethod":
    case "ArrowFunctionExpression":
    case "ClassMethod":
    case "ClassPrivateMethod":
      break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function YE(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "FunctionDeclaration":
    case "FunctionExpression":
    case "ObjectMethod":
    case "ArrowFunctionExpression":
    case "ClassMethod":
    case "ClassPrivateMethod":
    case "StaticBlock":
    case "TSModuleBlock":
      break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function XE(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "FunctionDeclaration":
    case "FunctionExpression":
    case "StringLiteral":
    case "NumericLiteral":
    case "NullLiteral":
    case "BooleanLiteral":
    case "RegExpLiteral":
    case "ArrowFunctionExpression":
    case "BigIntLiteral":
    case "DecimalLiteral":
      break;
    case "Placeholder":
      if (e.expectedNode === "StringLiteral")
        break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function JE(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "FunctionDeclaration":
    case "VariableDeclaration":
    case "ClassDeclaration":
    case "ExportAllDeclaration":
    case "ExportDefaultDeclaration":
    case "ExportNamedDeclaration":
    case "ImportDeclaration":
    case "DeclareClass":
    case "DeclareFunction":
    case "DeclareInterface":
    case "DeclareModule":
    case "DeclareModuleExports":
    case "DeclareTypeAlias":
    case "DeclareOpaqueType":
    case "DeclareVariable":
    case "DeclareExportDeclaration":
    case "DeclareExportAllDeclaration":
    case "InterfaceDeclaration":
    case "OpaqueType":
    case "TypeAlias":
    case "EnumDeclaration":
    case "TSDeclareFunction":
    case "TSInterfaceDeclaration":
    case "TSTypeAliasDeclaration":
    case "TSEnumDeclaration":
    case "TSModuleDeclaration":
      break;
    case "Placeholder":
      if (e.expectedNode === "Declaration")
        break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function HE(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "Identifier":
    case "RestElement":
    case "AssignmentPattern":
    case "ArrayPattern":
    case "ObjectPattern":
    case "TSAsExpression":
    case "TSSatisfiesExpression":
    case "TSTypeAssertion":
    case "TSNonNullExpression":
      break;
    case "Placeholder":
      switch (e.expectedNode) {
        case "Pattern":
        case "Identifier":
          break;
        default:
          return !1;
      }
      break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function GE(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "Identifier":
    case "MemberExpression":
    case "RestElement":
    case "AssignmentPattern":
    case "ArrayPattern":
    case "ObjectPattern":
    case "TSParameterProperty":
    case "TSAsExpression":
    case "TSSatisfiesExpression":
    case "TSTypeAssertion":
    case "TSNonNullExpression":
      break;
    case "Placeholder":
      switch (e.expectedNode) {
        case "Pattern":
        case "Identifier":
          break;
        default:
          return !1;
      }
      break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function zE(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "Identifier":
    case "TSQualifiedName":
      break;
    case "Placeholder":
      if (e.expectedNode === "Identifier")
        break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function QE(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "StringLiteral":
    case "NumericLiteral":
    case "NullLiteral":
    case "BooleanLiteral":
    case "RegExpLiteral":
    case "TemplateLiteral":
    case "BigIntLiteral":
    case "DecimalLiteral":
      break;
    case "Placeholder":
      if (e.expectedNode === "StringLiteral")
        break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function ZE(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "StringLiteral":
    case "NumericLiteral":
    case "NullLiteral":
    case "BooleanLiteral":
    case "BigIntLiteral":
    case "JSXAttribute":
    case "JSXClosingElement":
    case "JSXElement":
    case "JSXExpressionContainer":
    case "JSXSpreadChild":
    case "JSXOpeningElement":
    case "JSXText":
    case "JSXFragment":
    case "JSXOpeningFragment":
    case "JSXClosingFragment":
    case "DecimalLiteral":
      break;
    case "Placeholder":
      if (e.expectedNode === "StringLiteral")
        break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function eP(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "ObjectMethod":
    case "ObjectProperty":
    case "ObjectTypeInternalSlot":
    case "ObjectTypeCallProperty":
    case "ObjectTypeIndexer":
    case "ObjectTypeProperty":
    case "ObjectTypeSpreadProperty":
      break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function tP(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "ObjectMethod":
    case "ClassMethod":
    case "ClassPrivateMethod":
      break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function rP(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "ObjectMethod":
    case "ObjectProperty":
      break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function iP(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "ObjectProperty":
    case "ClassProperty":
    case "ClassAccessorProperty":
    case "ClassPrivateProperty":
      break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function sP(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "UnaryExpression":
    case "SpreadElement":
      break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function nP(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "AssignmentPattern":
    case "ArrayPattern":
    case "ObjectPattern":
      break;
    case "Placeholder":
      if (e.expectedNode === "Pattern")
        break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function aP(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "ClassExpression":
    case "ClassDeclaration":
      break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function hc(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "ExportAllDeclaration":
    case "ExportDefaultDeclaration":
    case "ExportNamedDeclaration":
    case "ImportDeclaration":
      break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function oP(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "ExportAllDeclaration":
    case "ExportDefaultDeclaration":
    case "ExportNamedDeclaration":
      break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function lP(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "ExportSpecifier":
    case "ImportDefaultSpecifier":
    case "ImportNamespaceSpecifier":
    case "ImportSpecifier":
    case "ExportNamespaceSpecifier":
    case "ExportDefaultSpecifier":
      break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function uP(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "ClassAccessorProperty":
      break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function cP(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "ClassPrivateProperty":
    case "ClassPrivateMethod":
    case "PrivateName":
      break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function fP(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "AnyTypeAnnotation":
    case "ArrayTypeAnnotation":
    case "BooleanTypeAnnotation":
    case "BooleanLiteralTypeAnnotation":
    case "NullLiteralTypeAnnotation":
    case "ClassImplements":
    case "DeclareClass":
    case "DeclareFunction":
    case "DeclareInterface":
    case "DeclareModule":
    case "DeclareModuleExports":
    case "DeclareTypeAlias":
    case "DeclareOpaqueType":
    case "DeclareVariable":
    case "DeclareExportDeclaration":
    case "DeclareExportAllDeclaration":
    case "DeclaredPredicate":
    case "ExistsTypeAnnotation":
    case "FunctionTypeAnnotation":
    case "FunctionTypeParam":
    case "GenericTypeAnnotation":
    case "InferredPredicate":
    case "InterfaceExtends":
    case "InterfaceDeclaration":
    case "InterfaceTypeAnnotation":
    case "IntersectionTypeAnnotation":
    case "MixedTypeAnnotation":
    case "EmptyTypeAnnotation":
    case "NullableTypeAnnotation":
    case "NumberLiteralTypeAnnotation":
    case "NumberTypeAnnotation":
    case "ObjectTypeAnnotation":
    case "ObjectTypeInternalSlot":
    case "ObjectTypeCallProperty":
    case "ObjectTypeIndexer":
    case "ObjectTypeProperty":
    case "ObjectTypeSpreadProperty":
    case "OpaqueType":
    case "QualifiedTypeIdentifier":
    case "StringLiteralTypeAnnotation":
    case "StringTypeAnnotation":
    case "SymbolTypeAnnotation":
    case "ThisTypeAnnotation":
    case "TupleTypeAnnotation":
    case "TypeofTypeAnnotation":
    case "TypeAlias":
    case "TypeAnnotation":
    case "TypeCastExpression":
    case "TypeParameter":
    case "TypeParameterDeclaration":
    case "TypeParameterInstantiation":
    case "UnionTypeAnnotation":
    case "Variance":
    case "VoidTypeAnnotation":
    case "EnumDeclaration":
    case "EnumBooleanBody":
    case "EnumNumberBody":
    case "EnumStringBody":
    case "EnumSymbolBody":
    case "EnumBooleanMember":
    case "EnumNumberMember":
    case "EnumStringMember":
    case "EnumDefaultedMember":
    case "IndexedAccessType":
    case "OptionalIndexedAccessType":
      break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function pP(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "AnyTypeAnnotation":
    case "ArrayTypeAnnotation":
    case "BooleanTypeAnnotation":
    case "BooleanLiteralTypeAnnotation":
    case "NullLiteralTypeAnnotation":
    case "ExistsTypeAnnotation":
    case "FunctionTypeAnnotation":
    case "GenericTypeAnnotation":
    case "InterfaceTypeAnnotation":
    case "IntersectionTypeAnnotation":
    case "MixedTypeAnnotation":
    case "EmptyTypeAnnotation":
    case "NullableTypeAnnotation":
    case "NumberLiteralTypeAnnotation":
    case "NumberTypeAnnotation":
    case "ObjectTypeAnnotation":
    case "StringLiteralTypeAnnotation":
    case "StringTypeAnnotation":
    case "SymbolTypeAnnotation":
    case "ThisTypeAnnotation":
    case "TupleTypeAnnotation":
    case "TypeofTypeAnnotation":
    case "UnionTypeAnnotation":
    case "VoidTypeAnnotation":
    case "IndexedAccessType":
    case "OptionalIndexedAccessType":
      break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function hP(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "AnyTypeAnnotation":
    case "BooleanTypeAnnotation":
    case "NullLiteralTypeAnnotation":
    case "MixedTypeAnnotation":
    case "EmptyTypeAnnotation":
    case "NumberTypeAnnotation":
    case "StringTypeAnnotation":
    case "SymbolTypeAnnotation":
    case "ThisTypeAnnotation":
    case "VoidTypeAnnotation":
      break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function dP(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "DeclareClass":
    case "DeclareFunction":
    case "DeclareInterface":
    case "DeclareModule":
    case "DeclareModuleExports":
    case "DeclareTypeAlias":
    case "DeclareOpaqueType":
    case "DeclareVariable":
    case "DeclareExportDeclaration":
    case "DeclareExportAllDeclaration":
    case "InterfaceDeclaration":
    case "OpaqueType":
    case "TypeAlias":
      break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function mP(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "DeclaredPredicate":
    case "InferredPredicate":
      break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function yP(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "EnumBooleanBody":
    case "EnumNumberBody":
    case "EnumStringBody":
    case "EnumSymbolBody":
      break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function TP(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "EnumBooleanMember":
    case "EnumNumberMember":
    case "EnumStringMember":
    case "EnumDefaultedMember":
      break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function SP(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "JSXAttribute":
    case "JSXClosingElement":
    case "JSXElement":
    case "JSXEmptyExpression":
    case "JSXExpressionContainer":
    case "JSXSpreadChild":
    case "JSXIdentifier":
    case "JSXMemberExpression":
    case "JSXNamespacedName":
    case "JSXOpeningElement":
    case "JSXSpreadAttribute":
    case "JSXText":
    case "JSXFragment":
    case "JSXOpeningFragment":
    case "JSXClosingFragment":
      break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function bP(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "Noop":
    case "Placeholder":
    case "V8IntrinsicIdentifier":
      break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function gP(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "TSParameterProperty":
    case "TSDeclareFunction":
    case "TSDeclareMethod":
    case "TSQualifiedName":
    case "TSCallSignatureDeclaration":
    case "TSConstructSignatureDeclaration":
    case "TSPropertySignature":
    case "TSMethodSignature":
    case "TSIndexSignature":
    case "TSAnyKeyword":
    case "TSBooleanKeyword":
    case "TSBigIntKeyword":
    case "TSIntrinsicKeyword":
    case "TSNeverKeyword":
    case "TSNullKeyword":
    case "TSNumberKeyword":
    case "TSObjectKeyword":
    case "TSStringKeyword":
    case "TSSymbolKeyword":
    case "TSUndefinedKeyword":
    case "TSUnknownKeyword":
    case "TSVoidKeyword":
    case "TSThisType":
    case "TSFunctionType":
    case "TSConstructorType":
    case "TSTypeReference":
    case "TSTypePredicate":
    case "TSTypeQuery":
    case "TSTypeLiteral":
    case "TSArrayType":
    case "TSTupleType":
    case "TSOptionalType":
    case "TSRestType":
    case "TSNamedTupleMember":
    case "TSUnionType":
    case "TSIntersectionType":
    case "TSConditionalType":
    case "TSInferType":
    case "TSParenthesizedType":
    case "TSTypeOperator":
    case "TSIndexedAccessType":
    case "TSMappedType":
    case "TSLiteralType":
    case "TSExpressionWithTypeArguments":
    case "TSInterfaceDeclaration":
    case "TSInterfaceBody":
    case "TSTypeAliasDeclaration":
    case "TSInstantiationExpression":
    case "TSAsExpression":
    case "TSSatisfiesExpression":
    case "TSTypeAssertion":
    case "TSEnumDeclaration":
    case "TSEnumMember":
    case "TSModuleDeclaration":
    case "TSModuleBlock":
    case "TSImportType":
    case "TSImportEqualsDeclaration":
    case "TSExternalModuleReference":
    case "TSNonNullExpression":
    case "TSExportAssignment":
    case "TSNamespaceExportDeclaration":
    case "TSTypeAnnotation":
    case "TSTypeParameterInstantiation":
    case "TSTypeParameterDeclaration":
    case "TSTypeParameter":
      break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function EP(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "TSCallSignatureDeclaration":
    case "TSConstructSignatureDeclaration":
    case "TSPropertySignature":
    case "TSMethodSignature":
    case "TSIndexSignature":
      break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function PP(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "TSAnyKeyword":
    case "TSBooleanKeyword":
    case "TSBigIntKeyword":
    case "TSIntrinsicKeyword":
    case "TSNeverKeyword":
    case "TSNullKeyword":
    case "TSNumberKeyword":
    case "TSObjectKeyword":
    case "TSStringKeyword":
    case "TSSymbolKeyword":
    case "TSUndefinedKeyword":
    case "TSUnknownKeyword":
    case "TSVoidKeyword":
    case "TSThisType":
    case "TSFunctionType":
    case "TSConstructorType":
    case "TSTypeReference":
    case "TSTypePredicate":
    case "TSTypeQuery":
    case "TSTypeLiteral":
    case "TSArrayType":
    case "TSTupleType":
    case "TSOptionalType":
    case "TSRestType":
    case "TSUnionType":
    case "TSIntersectionType":
    case "TSConditionalType":
    case "TSInferType":
    case "TSParenthesizedType":
    case "TSTypeOperator":
    case "TSIndexedAccessType":
    case "TSMappedType":
    case "TSLiteralType":
    case "TSExpressionWithTypeArguments":
    case "TSImportType":
      break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function xP(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "TSAnyKeyword":
    case "TSBooleanKeyword":
    case "TSBigIntKeyword":
    case "TSIntrinsicKeyword":
    case "TSNeverKeyword":
    case "TSNullKeyword":
    case "TSNumberKeyword":
    case "TSObjectKeyword":
    case "TSStringKeyword":
    case "TSSymbolKeyword":
    case "TSUndefinedKeyword":
    case "TSUnknownKeyword":
    case "TSVoidKeyword":
    case "TSThisType":
    case "TSLiteralType":
      break;
    default:
      return !1;
  }
  return t == null || (0, g.default)(e, t);
}
function vP(e, t) {
  return (0, ci.default)("isNumberLiteral", "isNumericLiteral"), !e || e.type !== "NumberLiteral" ? !1 : t == null || (0, g.default)(e, t);
}
function AP(e, t) {
  return (0, ci.default)("isRegexLiteral", "isRegExpLiteral"), !e || e.type !== "RegexLiteral" ? !1 : t == null || (0, g.default)(e, t);
}
function CP(e, t) {
  return (0, ci.default)("isRestProperty", "isRestElement"), !e || e.type !== "RestProperty" ? !1 : t == null || (0, g.default)(e, t);
}
function IP(e, t) {
  return (0, ci.default)("isSpreadProperty", "isSpreadElement"), !e || e.type !== "SpreadProperty" ? !1 : t == null || (0, g.default)(e, t);
}
function wP(e, t) {
  return (0, ci.default)("isModuleDeclaration", "isImportOrExportDeclaration"), hc(e, t);
}
Object.defineProperty(xs, "__esModule", {
  value: !0
});
xs.default = OP;
var Ur = m;
function OP(e, t, r) {
  if (!(0, Ur.isMemberExpression)(e))
    return !1;
  const i = Array.isArray(t) ? t : t.split("."), s = [];
  let n;
  for (n = e; (0, Ur.isMemberExpression)(n); n = n.object)
    s.push(n.property);
  if (s.push(n), s.length < i.length || !r && s.length > i.length)
    return !1;
  for (let a = 0, o = s.length - 1; a < i.length; a++, o--) {
    const l = s[o];
    let u;
    if ((0, Ur.isIdentifier)(l))
      u = l.name;
    else if ((0, Ur.isStringLiteral)(l))
      u = l.value;
    else if ((0, Ur.isThisExpression)(l))
      u = "this";
    else
      return !1;
    if (i[a] !== u)
      return !1;
  }
  return !0;
}
Object.defineProperty(Ps, "__esModule", {
  value: !0
});
Ps.default = _P;
var NP = xs;
function _P(e, t) {
  const r = e.split(".");
  return (i) => (0, NP.default)(i, r, t);
}
Object.defineProperty(Es, "__esModule", {
  value: !0
});
Es.default = void 0;
var DP = Ps;
const kP = (0, DP.default)("React.Component");
var LP = kP;
Es.default = LP;
var Ta = {};
Object.defineProperty(Ta, "__esModule", {
  value: !0
});
Ta.default = MP;
function MP(e) {
  return !!e && /^[a-z]/.test(e);
}
var Ni = {}, _i = {}, d = {}, Di = {}, Er = {}, dn = {};
let Vr = null;
function si(e) {
  if (Vr !== null && typeof Vr.property) {
    const t = Vr;
    return Vr = si.prototype = null, t;
  }
  return Vr = si.prototype = e ?? /* @__PURE__ */ Object.create(null), new si();
}
si();
var BP = function(t) {
  return si(t);
}, it = {}, ki = {}, Li = {}, Fo;
function Sa() {
  if (Fo)
    return Li;
  Fo = 1, Object.defineProperty(Li, "__esModule", {
    value: !0
  }), Li.default = t;
  var e = Et();
  function t(r, i) {
    if (r === i)
      return !0;
    if (e.ALIAS_KEYS[i])
      return !1;
    const s = e.FLIPPED_ALIAS_KEYS[i];
    if (s) {
      if (s[0] === r)
        return !0;
      for (const n of s)
        if (r === n)
          return !0;
    }
    return !1;
  }
  return Li;
}
var Mi = {}, jo;
function dc() {
  if (jo)
    return Mi;
  jo = 1, Object.defineProperty(Mi, "__esModule", {
    value: !0
  }), Mi.default = t;
  var e = Et();
  function t(r, i) {
    if (r === i)
      return !0;
    const s = e.PLACEHOLDERS_ALIAS[r];
    if (s) {
      for (const n of s)
        if (i === n)
          return !0;
    }
    return !1;
  }
  return Mi;
}
var Ro;
function fi() {
  if (Ro)
    return ki;
  Ro = 1, Object.defineProperty(ki, "__esModule", {
    value: !0
  }), ki.default = s;
  var e = ui, t = Sa(), r = dc(), i = Et();
  function s(n, a, o) {
    return a ? (0, t.default)(a.type, n) ? typeof o > "u" ? !0 : (0, e.default)(a, o) : !o && a.type === "Placeholder" && n in i.FLIPPED_ALIAS_KEYS ? (0, r.default)(a.expectedNode, n) : !1 : !1;
  }
  return ki;
}
var hr = {}, pi = {}, hi = {};
Object.defineProperty(hi, "__esModule", {
  value: !0
});
hi.isIdentifierChar = Sc;
hi.isIdentifierName = $P;
hi.isIdentifierStart = Tc;
let ba = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", mc = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿";
const FP = new RegExp("[" + ba + "]"), jP = new RegExp("[" + ba + mc + "]");
ba = mc = null;
const yc = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191], RP = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
function Fn(e, t) {
  let r = 65536;
  for (let i = 0, s = t.length; i < s; i += 2) {
    if (r += t[i], r > e)
      return !1;
    if (r += t[i + 1], r >= e)
      return !0;
  }
  return !1;
}
function Tc(e) {
  return e < 65 ? e === 36 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && FP.test(String.fromCharCode(e)) : Fn(e, yc);
}
function Sc(e) {
  return e < 48 ? e === 36 : e < 58 ? !0 : e < 65 ? !1 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && jP.test(String.fromCharCode(e)) : Fn(e, yc) || Fn(e, RP);
}
function $P(e) {
  let t = !0;
  for (let r = 0; r < e.length; r++) {
    let i = e.charCodeAt(r);
    if ((i & 64512) === 55296 && r + 1 < e.length) {
      const s = e.charCodeAt(++r);
      (s & 64512) === 56320 && (i = 65536 + ((i & 1023) << 10) + (s & 1023));
    }
    if (t) {
      if (t = !1, !Tc(i))
        return !1;
    } else if (!Sc(i))
      return !1;
  }
  return !t;
}
var dr = {};
Object.defineProperty(dr, "__esModule", {
  value: !0
});
dr.isKeyword = WP;
dr.isReservedWord = bc;
dr.isStrictBindOnlyReservedWord = Ec;
dr.isStrictBindReservedWord = qP;
dr.isStrictReservedWord = gc;
const ga = {
  keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
  strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
  strictBind: ["eval", "arguments"]
}, UP = new Set(ga.keyword), VP = new Set(ga.strict), KP = new Set(ga.strictBind);
function bc(e, t) {
  return t && e === "await" || e === "enum";
}
function gc(e, t) {
  return bc(e, t) || VP.has(e);
}
function Ec(e) {
  return KP.has(e);
}
function qP(e, t) {
  return gc(e, t) || Ec(e);
}
function WP(e) {
  return UP.has(e);
}
(function(e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), Object.defineProperty(e, "isIdentifierChar", {
    enumerable: !0,
    get: function() {
      return t.isIdentifierChar;
    }
  }), Object.defineProperty(e, "isIdentifierName", {
    enumerable: !0,
    get: function() {
      return t.isIdentifierName;
    }
  }), Object.defineProperty(e, "isIdentifierStart", {
    enumerable: !0,
    get: function() {
      return t.isIdentifierStart;
    }
  }), Object.defineProperty(e, "isKeyword", {
    enumerable: !0,
    get: function() {
      return r.isKeyword;
    }
  }), Object.defineProperty(e, "isReservedWord", {
    enumerable: !0,
    get: function() {
      return r.isReservedWord;
    }
  }), Object.defineProperty(e, "isStrictBindOnlyReservedWord", {
    enumerable: !0,
    get: function() {
      return r.isStrictBindOnlyReservedWord;
    }
  }), Object.defineProperty(e, "isStrictBindReservedWord", {
    enumerable: !0,
    get: function() {
      return r.isStrictBindReservedWord;
    }
  }), Object.defineProperty(e, "isStrictReservedWord", {
    enumerable: !0,
    get: function() {
      return r.isStrictReservedWord;
    }
  });
  var t = hi, r = dr;
})(pi);
Object.defineProperty(hr, "__esModule", {
  value: !0
});
hr.default = YP;
var mn = pi;
function YP(e, t = !0) {
  return typeof e != "string" || t && ((0, mn.isKeyword)(e) || (0, mn.isStrictReservedWord)(e, !0)) ? !1 : (0, mn.isIdentifierName)(e);
}
var di = {};
Object.defineProperty(di, "__esModule", {
  value: !0
});
di.readCodePoint = xc;
di.readInt = Pc;
di.readStringContents = JP;
var XP = function(t) {
  return t >= 48 && t <= 57;
};
const $o = {
  decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
  hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
}, Bi = {
  bin: (e) => e === 48 || e === 49,
  oct: (e) => e >= 48 && e <= 55,
  dec: (e) => e >= 48 && e <= 57,
  hex: (e) => e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102
};
function JP(e, t, r, i, s, n) {
  const a = r, o = i, l = s;
  let u = "", c = null, p = r;
  const {
    length: h
  } = t;
  for (; ; ) {
    if (r >= h) {
      n.unterminated(a, o, l), u += t.slice(p, r);
      break;
    }
    const y = t.charCodeAt(r);
    if (HP(e, y, t, r)) {
      u += t.slice(p, r);
      break;
    }
    if (y === 92) {
      u += t.slice(p, r);
      const P = GP(t, r, i, s, e === "template", n);
      P.ch === null && !c ? c = {
        pos: r,
        lineStart: i,
        curLine: s
      } : u += P.ch, {
        pos: r,
        lineStart: i,
        curLine: s
      } = P, p = r;
    } else
      y === 8232 || y === 8233 ? (++r, ++s, i = r) : y === 10 || y === 13 ? e === "template" ? (u += t.slice(p, r) + `
`, ++r, y === 13 && t.charCodeAt(r) === 10 && ++r, ++s, p = i = r) : n.unterminated(a, o, l) : ++r;
  }
  return {
    pos: r,
    str: u,
    firstInvalidLoc: c,
    lineStart: i,
    curLine: s,
    containsInvalid: !!c
  };
}
function HP(e, t, r, i) {
  return e === "template" ? t === 96 || t === 36 && r.charCodeAt(i + 1) === 123 : t === (e === "double" ? 34 : 39);
}
function GP(e, t, r, i, s, n) {
  const a = !s;
  t++;
  const o = (u) => ({
    pos: t,
    ch: u,
    lineStart: r,
    curLine: i
  }), l = e.charCodeAt(t++);
  switch (l) {
    case 110:
      return o(`
`);
    case 114:
      return o("\r");
    case 120: {
      let u;
      return {
        code: u,
        pos: t
      } = jn(e, t, r, i, 2, !1, a, n), o(u === null ? null : String.fromCharCode(u));
    }
    case 117: {
      let u;
      return {
        code: u,
        pos: t
      } = xc(e, t, r, i, a, n), o(u === null ? null : String.fromCodePoint(u));
    }
    case 116:
      return o("	");
    case 98:
      return o("\b");
    case 118:
      return o("\v");
    case 102:
      return o("\f");
    case 13:
      e.charCodeAt(t) === 10 && ++t;
    case 10:
      r = t, ++i;
    case 8232:
    case 8233:
      return o("");
    case 56:
    case 57:
      if (s)
        return o(null);
      n.strictNumericEscape(t - 1, r, i);
    default:
      if (l >= 48 && l <= 55) {
        const u = t - 1;
        let p = e.slice(u, t + 2).match(/^[0-7]+/)[0], h = parseInt(p, 8);
        h > 255 && (p = p.slice(0, -1), h = parseInt(p, 8)), t += p.length - 1;
        const y = e.charCodeAt(t);
        if (p !== "0" || y === 56 || y === 57) {
          if (s)
            return o(null);
          n.strictNumericEscape(u, r, i);
        }
        return o(String.fromCharCode(h));
      }
      return o(String.fromCharCode(l));
  }
}
function jn(e, t, r, i, s, n, a, o) {
  const l = t;
  let u;
  return {
    n: u,
    pos: t
  } = Pc(e, t, r, i, 16, s, n, !1, o, !a), u === null && (a ? o.invalidEscapeSequence(l, r, i) : t = l - 1), {
    code: u,
    pos: t
  };
}
function Pc(e, t, r, i, s, n, a, o, l, u) {
  const c = t, p = s === 16 ? $o.hex : $o.decBinOct, h = s === 16 ? Bi.hex : s === 10 ? Bi.dec : s === 8 ? Bi.oct : Bi.bin;
  let y = !1, P = 0;
  for (let v = 0, w = n ?? 1 / 0; v < w; ++v) {
    const x = e.charCodeAt(t);
    let O;
    if (x === 95 && o !== "bail") {
      const _ = e.charCodeAt(t - 1), K = e.charCodeAt(t + 1);
      if (o) {
        if (Number.isNaN(K) || !h(K) || p.has(_) || p.has(K)) {
          if (u)
            return {
              n: null,
              pos: t
            };
          l.unexpectedNumericSeparator(t, r, i);
        }
      } else {
        if (u)
          return {
            n: null,
            pos: t
          };
        l.numericSeparatorInEscapeSequence(t, r, i);
      }
      ++t;
      continue;
    }
    if (x >= 97 ? O = x - 97 + 10 : x >= 65 ? O = x - 65 + 10 : XP(x) ? O = x - 48 : O = 1 / 0, O >= s) {
      if (O <= 9 && u)
        return {
          n: null,
          pos: t
        };
      if (O <= 9 && l.invalidDigit(t, r, i, s))
        O = 0;
      else if (a)
        O = 0, y = !0;
      else
        break;
    }
    ++t, P = P * s + O;
  }
  return t === c || n != null && t - c !== n || y ? {
    n: null,
    pos: t
  } : {
    n: P,
    pos: t
  };
}
function xc(e, t, r, i, s, n) {
  const a = e.charCodeAt(t);
  let o;
  if (a === 123) {
    if (++t, {
      code: o,
      pos: t
    } = jn(e, t, r, i, e.indexOf("}", t) - t, !0, s, n), ++t, o !== null && o > 1114111)
      if (s)
        n.invalidCodePoint(t, r, i);
      else
        return {
          code: null,
          pos: t
        };
  } else
    ({
      code: o,
      pos: t
    } = jn(e, t, r, i, 4, !1, s, n));
  return {
    code: o,
    pos: t
  };
}
var Pe = {};
Object.defineProperty(Pe, "__esModule", {
  value: !0
});
Pe.UPDATE_OPERATORS = Pe.UNARY_OPERATORS = Pe.STRING_UNARY_OPERATORS = Pe.STATEMENT_OR_BLOCK_KEYS = Pe.NUMBER_UNARY_OPERATORS = Pe.NUMBER_BINARY_OPERATORS = Pe.NOT_LOCAL_BINDING = Pe.LOGICAL_OPERATORS = Pe.INHERIT_KEYS = Pe.FOR_INIT_KEYS = Pe.FLATTENABLE_KEYS = Pe.EQUALITY_BINARY_OPERATORS = Pe.COMPARISON_BINARY_OPERATORS = Pe.COMMENT_KEYS = Pe.BOOLEAN_UNARY_OPERATORS = Pe.BOOLEAN_NUMBER_BINARY_OPERATORS = Pe.BOOLEAN_BINARY_OPERATORS = Pe.BLOCK_SCOPED_SYMBOL = Pe.BINARY_OPERATORS = Pe.ASSIGNMENT_OPERATORS = void 0;
const zP = ["consequent", "body", "alternate"];
Pe.STATEMENT_OR_BLOCK_KEYS = zP;
const QP = ["body", "expressions"];
Pe.FLATTENABLE_KEYS = QP;
const ZP = ["left", "init"];
Pe.FOR_INIT_KEYS = ZP;
const ex = ["leadingComments", "trailingComments", "innerComments"];
Pe.COMMENT_KEYS = ex;
const vc = ["||", "&&", "??"];
Pe.LOGICAL_OPERATORS = vc;
const tx = ["++", "--"];
Pe.UPDATE_OPERATORS = tx;
const Ac = [">", "<", ">=", "<="];
Pe.BOOLEAN_NUMBER_BINARY_OPERATORS = Ac;
const Cc = ["==", "===", "!=", "!=="];
Pe.EQUALITY_BINARY_OPERATORS = Cc;
const Ic = [...Cc, "in", "instanceof"];
Pe.COMPARISON_BINARY_OPERATORS = Ic;
const wc = [...Ic, ...Ac];
Pe.BOOLEAN_BINARY_OPERATORS = wc;
const Ea = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
Pe.NUMBER_BINARY_OPERATORS = Ea;
const rx = ["+", ...Ea, ...wc, "|>"];
Pe.BINARY_OPERATORS = rx;
const ix = ["=", "+=", ...Ea.map((e) => e + "="), ...vc.map((e) => e + "=")];
Pe.ASSIGNMENT_OPERATORS = ix;
const Oc = ["delete", "!"];
Pe.BOOLEAN_UNARY_OPERATORS = Oc;
const Nc = ["+", "-", "~"];
Pe.NUMBER_UNARY_OPERATORS = Nc;
const _c = ["typeof"];
Pe.STRING_UNARY_OPERATORS = _c;
const sx = ["void", "throw", ...Oc, ...Nc, ..._c];
Pe.UNARY_OPERATORS = sx;
const nx = {
  optional: ["typeAnnotation", "typeParameters", "returnType"],
  force: ["start", "loc", "end"]
};
Pe.INHERIT_KEYS = nx;
const ax = Symbol.for("var used to be block scoped");
Pe.BLOCK_SCOPED_SYMBOL = ax;
const ox = Symbol.for("should not be considered a local binding");
Pe.NOT_LOCAL_BINDING = ox;
var _e = {}, Uo;
function Qt() {
  if (Uo)
    return _e;
  Uo = 1, Object.defineProperty(_e, "__esModule", {
    value: !0
  }), _e.VISITOR_KEYS = _e.NODE_PARENT_VALIDATIONS = _e.NODE_FIELDS = _e.FLIPPED_ALIAS_KEYS = _e.DEPRECATED_KEYS = _e.BUILDER_KEYS = _e.ALIAS_KEYS = void 0, _e.arrayOf = v, _e.arrayOfType = w, _e.assertEach = O, _e.assertNodeOrValueType = R, _e.assertNodeType = K, _e.assertOneOf = _, _e.assertOptionalChainStart = L, _e.assertShape = C, _e.assertValueType = B, _e.chain = F, _e.default = me, _e.defineAliasedType = ce, _e.typeIs = p, _e.validate = c, _e.validateArrayOfType = x, _e.validateOptional = y, _e.validateOptionalType = P, _e.validateType = h;
  var e = fi(), t = Pa();
  const r = {};
  _e.VISITOR_KEYS = r;
  const i = {};
  _e.ALIAS_KEYS = i;
  const s = {};
  _e.FLIPPED_ALIAS_KEYS = s;
  const n = {};
  _e.NODE_FIELDS = n;
  const a = {};
  _e.BUILDER_KEYS = a;
  const o = {};
  _e.DEPRECATED_KEYS = o;
  const l = {};
  _e.NODE_PARENT_VALIDATIONS = l;
  function u(k) {
    return Array.isArray(k) ? "array" : k === null ? "null" : typeof k;
  }
  function c(k) {
    return {
      validate: k
    };
  }
  function p(k) {
    return typeof k == "string" ? K(k) : K(...k);
  }
  function h(k) {
    return c(p(k));
  }
  function y(k) {
    return {
      validate: k,
      optional: !0
    };
  }
  function P(k) {
    return {
      validate: p(k),
      optional: !0
    };
  }
  function v(k) {
    return F(B("array"), O(k));
  }
  function w(k) {
    return v(p(k));
  }
  function x(k) {
    return c(w(k));
  }
  function O(k) {
    function M(D, j, X) {
      if (Array.isArray(X))
        for (let W = 0; W < X.length; W++) {
          const ae = `${j}[${W}]`, ie = X[W];
          k(D, ae, ie), process.env.BABEL_TYPES_8_BREAKING && (0, t.validateChild)(D, ae, ie);
        }
    }
    return M.each = k, M;
  }
  function _(...k) {
    function M(D, j, X) {
      if (k.indexOf(X) < 0)
        throw new TypeError(`Property ${j} expected value to be one of ${JSON.stringify(k)} but got ${JSON.stringify(X)}`);
    }
    return M.oneOf = k, M;
  }
  function K(...k) {
    function M(D, j, X) {
      for (const W of k)
        if ((0, e.default)(W, X)) {
          (0, t.validateChild)(D, j, X);
          return;
        }
      throw new TypeError(`Property ${j} of ${D.type} expected node to be of a type ${JSON.stringify(k)} but instead got ${JSON.stringify(X == null ? void 0 : X.type)}`);
    }
    return M.oneOfNodeTypes = k, M;
  }
  function R(...k) {
    function M(D, j, X) {
      for (const W of k)
        if (u(X) === W || (0, e.default)(W, X)) {
          (0, t.validateChild)(D, j, X);
          return;
        }
      throw new TypeError(`Property ${j} of ${D.type} expected node to be of a type ${JSON.stringify(k)} but instead got ${JSON.stringify(X == null ? void 0 : X.type)}`);
    }
    return M.oneOfNodeOrValueTypes = k, M;
  }
  function B(k) {
    function M(D, j, X) {
      if (!(u(X) === k))
        throw new TypeError(`Property ${j} expected type of ${k} but got ${u(X)}`);
    }
    return M.type = k, M;
  }
  function C(k) {
    function M(D, j, X) {
      const W = [];
      for (const ae of Object.keys(k))
        try {
          (0, t.validateField)(D, ae, X[ae], k[ae]);
        } catch (ie) {
          if (ie instanceof TypeError) {
            W.push(ie.message);
            continue;
          }
          throw ie;
        }
      if (W.length)
        throw new TypeError(`Property ${j} of ${D.type} expected to have the following:
${W.join(`
`)}`);
    }
    return M.shapeOf = k, M;
  }
  function L() {
    function k(M) {
      var D;
      let j = M;
      for (; M; ) {
        const {
          type: X
        } = j;
        if (X === "OptionalCallExpression") {
          if (j.optional)
            return;
          j = j.callee;
          continue;
        }
        if (X === "OptionalMemberExpression") {
          if (j.optional)
            return;
          j = j.object;
          continue;
        }
        break;
      }
      throw new TypeError(`Non-optional ${M.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(D = j) == null ? void 0 : D.type}`);
    }
    return k;
  }
  function F(...k) {
    function M(...D) {
      for (const j of k)
        j(...D);
    }
    if (M.chainOf = k, k.length >= 2 && "type" in k[0] && k[0].type === "array" && !("each" in k[1]))
      throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');
    return M;
  }
  const te = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"], Z = ["default", "optional", "deprecated", "validate"], J = {};
  function ce(...k) {
    return (M, D = {}) => {
      let j = D.aliases;
      if (!j) {
        var X, W;
        D.inherits && (j = (X = J[D.inherits].aliases) == null ? void 0 : X.slice()), (W = j) != null || (j = []), D.aliases = j;
      }
      const ae = k.filter((ie) => !j.includes(ie));
      j.unshift(...ae), me(M, D);
    };
  }
  function me(k, M = {}) {
    const D = M.inherits && J[M.inherits] || {};
    let j = M.fields;
    if (!j && (j = {}, D.fields)) {
      const ie = Object.getOwnPropertyNames(D.fields);
      for (const ge of ie) {
        const Ce = D.fields[ge], je = Ce.default;
        if (Array.isArray(je) ? je.length > 0 : je && typeof je == "object")
          throw new Error("field defaults can only be primitives or empty arrays currently");
        j[ge] = {
          default: Array.isArray(je) ? [] : je,
          optional: Ce.optional,
          deprecated: Ce.deprecated,
          validate: Ce.validate
        };
      }
    }
    const X = M.visitor || D.visitor || [], W = M.aliases || D.aliases || [], ae = M.builder || D.builder || M.visitor || [];
    for (const ie of Object.keys(M))
      if (te.indexOf(ie) === -1)
        throw new Error(`Unknown type option "${ie}" on ${k}`);
    M.deprecatedAlias && (o[M.deprecatedAlias] = k);
    for (const ie of X.concat(ae))
      j[ie] = j[ie] || {};
    for (const ie of Object.keys(j)) {
      const ge = j[ie];
      ge.default !== void 0 && ae.indexOf(ie) === -1 && (ge.optional = !0), ge.default === void 0 ? ge.default = null : !ge.validate && ge.default != null && (ge.validate = B(u(ge.default)));
      for (const Ce of Object.keys(ge))
        if (Z.indexOf(Ce) === -1)
          throw new Error(`Unknown field key "${Ce}" on ${k}.${ie}`);
    }
    r[k] = M.visitor = X, a[k] = M.builder = ae, n[k] = M.fields = j, i[k] = M.aliases = W, W.forEach((ie) => {
      s[ie] = s[ie] || [], s[ie].push(k);
    }), M.validate && (l[k] = M.validate), J[k] = M;
  }
  return _e;
}
var Vo;
function Dc() {
  if (Vo)
    return it;
  Vo = 1, Object.defineProperty(it, "__esModule", {
    value: !0
  }), it.patternLikeCommon = it.functionTypeAnnotationCommon = it.functionDeclarationCommon = it.functionCommon = it.classMethodOrPropertyCommon = it.classMethodOrDeclareMethodCommon = void 0;
  var e = fi(), t = hr, r = pi, i = di, s = Pe, n = Qt();
  const a = (0, n.defineAliasedType)("Standardized");
  a("ArrayExpression", {
    fields: {
      elements: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeOrValueType)("null", "Expression", "SpreadElement"))),
        default: process.env.BABEL_TYPES_8_BREAKING ? void 0 : []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  }), a("AssignmentExpression", {
    fields: {
      operator: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, n.assertValueType)("string");
          const y = (0, n.assertOneOf)(...s.ASSIGNMENT_OPERATORS), P = (0, n.assertOneOf)("=");
          return function(v, w, x) {
            ((0, e.default)("Pattern", v.left) ? P : y)(v, w, x);
          };
        }()
      },
      left: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, n.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, n.assertNodeType)("LVal")
      },
      right: {
        validate: (0, n.assertNodeType)("Expression")
      }
    },
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Expression"]
  }), a("BinaryExpression", {
    builder: ["operator", "left", "right"],
    fields: {
      operator: {
        validate: (0, n.assertOneOf)(...s.BINARY_OPERATORS)
      },
      left: {
        validate: function() {
          const y = (0, n.assertNodeType)("Expression"), P = (0, n.assertNodeType)("Expression", "PrivateName");
          return Object.assign(function(w, x, O) {
            (w.operator === "in" ? P : y)(w, x, O);
          }, {
            oneOfNodeTypes: ["Expression", "PrivateName"]
          });
        }()
      },
      right: {
        validate: (0, n.assertNodeType)("Expression")
      }
    },
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"]
  }), a("InterpreterDirective", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, n.assertValueType)("string")
      }
    }
  }), a("Directive", {
    visitor: ["value"],
    fields: {
      value: {
        validate: (0, n.assertNodeType)("DirectiveLiteral")
      }
    }
  }), a("DirectiveLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, n.assertValueType)("string")
      }
    }
  }), a("BlockStatement", {
    builder: ["body", "directives"],
    visitor: ["directives", "body"],
    fields: {
      directives: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Directive"))),
        default: []
      },
      body: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "Block", "Statement"]
  }), a("BreakStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, n.assertNodeType)("Identifier"),
        optional: !0
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  }), a("CallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: (0, n.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
      },
      arguments: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, n.assertOneOf)(!0, !1),
        optional: !0
      }
    }, {
      typeArguments: {
        validate: (0, n.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      },
      typeParameters: {
        validate: (0, n.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    })
  }), a("CatchClause", {
    visitor: ["param", "body"],
    fields: {
      param: {
        validate: (0, n.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
        optional: !0
      },
      body: {
        validate: (0, n.assertNodeType)("BlockStatement")
      }
    },
    aliases: ["Scopable", "BlockParent"]
  }), a("ConditionalExpression", {
    visitor: ["test", "consequent", "alternate"],
    fields: {
      test: {
        validate: (0, n.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, n.assertNodeType)("Expression")
      },
      alternate: {
        validate: (0, n.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression", "Conditional"]
  }), a("ContinueStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, n.assertNodeType)("Identifier"),
        optional: !0
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  }), a("DebuggerStatement", {
    aliases: ["Statement"]
  }), a("DoWhileStatement", {
    visitor: ["test", "body"],
    fields: {
      test: {
        validate: (0, n.assertNodeType)("Expression")
      },
      body: {
        validate: (0, n.assertNodeType)("Statement")
      }
    },
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
  }), a("EmptyStatement", {
    aliases: ["Statement"]
  }), a("ExpressionStatement", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, n.assertNodeType)("Expression")
      }
    },
    aliases: ["Statement", "ExpressionWrapper"]
  }), a("File", {
    builder: ["program", "comments", "tokens"],
    visitor: ["program"],
    fields: {
      program: {
        validate: (0, n.assertNodeType)("Program")
      },
      comments: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, n.assertEach)((0, n.assertNodeType)("CommentBlock", "CommentLine")) : Object.assign(() => {
        }, {
          each: {
            oneOfNodeTypes: ["CommentBlock", "CommentLine"]
          }
        }),
        optional: !0
      },
      tokens: {
        validate: (0, n.assertEach)(Object.assign(() => {
        }, {
          type: "any"
        })),
        optional: !0
      }
    }
  }), a("ForInStatement", {
    visitor: ["left", "right", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, n.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, n.assertNodeType)("VariableDeclaration", "LVal")
      },
      right: {
        validate: (0, n.assertNodeType)("Expression")
      },
      body: {
        validate: (0, n.assertNodeType)("Statement")
      }
    }
  }), a("ForStatement", {
    visitor: ["init", "test", "update", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
    fields: {
      init: {
        validate: (0, n.assertNodeType)("VariableDeclaration", "Expression"),
        optional: !0
      },
      test: {
        validate: (0, n.assertNodeType)("Expression"),
        optional: !0
      },
      update: {
        validate: (0, n.assertNodeType)("Expression"),
        optional: !0
      },
      body: {
        validate: (0, n.assertNodeType)("Statement")
      }
    }
  });
  const o = () => ({
    params: {
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Identifier", "Pattern", "RestElement")))
    },
    generator: {
      default: !1
    },
    async: {
      default: !1
    }
  });
  it.functionCommon = o;
  const l = () => ({
    returnType: {
      validate: (0, n.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    typeParameters: {
      validate: (0, n.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
      optional: !0
    }
  });
  it.functionTypeAnnotationCommon = l;
  const u = () => Object.assign({}, o(), {
    declare: {
      validate: (0, n.assertValueType)("boolean"),
      optional: !0
    },
    id: {
      validate: (0, n.assertNodeType)("Identifier"),
      optional: !0
    }
  });
  it.functionDeclarationCommon = u, a("FunctionDeclaration", {
    builder: ["id", "params", "body", "generator", "async"],
    visitor: ["id", "params", "body", "returnType", "typeParameters"],
    fields: Object.assign({}, u(), l(), {
      body: {
        validate: (0, n.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, n.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    }),
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
    validate: function() {
      if (!process.env.BABEL_TYPES_8_BREAKING)
        return () => {
        };
      const y = (0, n.assertNodeType)("Identifier");
      return function(P, v, w) {
        (0, e.default)("ExportDefaultDeclaration", P) || y(w, "id", w.id);
      };
    }()
  }), a("FunctionExpression", {
    inherits: "FunctionDeclaration",
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, o(), l(), {
      id: {
        validate: (0, n.assertNodeType)("Identifier"),
        optional: !0
      },
      body: {
        validate: (0, n.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, n.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    })
  });
  const c = () => ({
    typeAnnotation: {
      validate: (0, n.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    optional: {
      validate: (0, n.assertValueType)("boolean"),
      optional: !0
    },
    decorators: {
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Decorator"))),
      optional: !0
    }
  });
  it.patternLikeCommon = c, a("Identifier", {
    builder: ["name"],
    visitor: ["typeAnnotation", "decorators"],
    aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
    fields: Object.assign({}, c(), {
      name: {
        validate: (0, n.chain)((0, n.assertValueType)("string"), Object.assign(function(y, P, v) {
          if (process.env.BABEL_TYPES_8_BREAKING && !(0, t.default)(v, !1))
            throw new TypeError(`"${v}" is not a valid identifier name`);
        }, {
          type: "string"
        }))
      }
    }),
    validate(y, P, v) {
      if (!process.env.BABEL_TYPES_8_BREAKING)
        return;
      const w = /\.(\w+)$/.exec(P);
      if (!w)
        return;
      const [, x] = w, O = {
        computed: !1
      };
      if (x === "property") {
        if ((0, e.default)("MemberExpression", y, O) || (0, e.default)("OptionalMemberExpression", y, O))
          return;
      } else if (x === "key") {
        if ((0, e.default)("Property", y, O) || (0, e.default)("Method", y, O))
          return;
      } else if (x === "exported") {
        if ((0, e.default)("ExportSpecifier", y))
          return;
      } else if (x === "imported") {
        if ((0, e.default)("ImportSpecifier", y, {
          imported: v
        }))
          return;
      } else if (x === "meta" && (0, e.default)("MetaProperty", y, {
        meta: v
      }))
        return;
      if (((0, r.isKeyword)(v.name) || (0, r.isReservedWord)(v.name, !1)) && v.name !== "this")
        throw new TypeError(`"${v.name}" is not a valid identifier`);
    }
  }), a("IfStatement", {
    visitor: ["test", "consequent", "alternate"],
    aliases: ["Statement", "Conditional"],
    fields: {
      test: {
        validate: (0, n.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, n.assertNodeType)("Statement")
      },
      alternate: {
        optional: !0,
        validate: (0, n.assertNodeType)("Statement")
      }
    }
  }), a("LabeledStatement", {
    visitor: ["label", "body"],
    aliases: ["Statement"],
    fields: {
      label: {
        validate: (0, n.assertNodeType)("Identifier")
      },
      body: {
        validate: (0, n.assertNodeType)("Statement")
      }
    }
  }), a("StringLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, n.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  }), a("NumericLiteral", {
    builder: ["value"],
    deprecatedAlias: "NumberLiteral",
    fields: {
      value: {
        validate: (0, n.assertValueType)("number")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  }), a("NullLiteral", {
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  }), a("BooleanLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, n.assertValueType)("boolean")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  }), a("RegExpLiteral", {
    builder: ["pattern", "flags"],
    deprecatedAlias: "RegexLiteral",
    aliases: ["Expression", "Pureish", "Literal"],
    fields: {
      pattern: {
        validate: (0, n.assertValueType)("string")
      },
      flags: {
        validate: (0, n.chain)((0, n.assertValueType)("string"), Object.assign(function(y, P, v) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          const w = /[^gimsuy]/.exec(v);
          if (w)
            throw new TypeError(`"${w[0]}" is not a valid RegExp flag`);
        }, {
          type: "string"
        })),
        default: ""
      }
    }
  }), a("LogicalExpression", {
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"],
    fields: {
      operator: {
        validate: (0, n.assertOneOf)(...s.LOGICAL_OPERATORS)
      },
      left: {
        validate: (0, n.assertNodeType)("Expression")
      },
      right: {
        validate: (0, n.assertNodeType)("Expression")
      }
    }
  }), a("MemberExpression", {
    builder: ["object", "property", "computed", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["optional"]],
    visitor: ["object", "property"],
    aliases: ["Expression", "LVal"],
    fields: Object.assign({
      object: {
        validate: (0, n.assertNodeType)("Expression", "Super")
      },
      property: {
        validate: function() {
          const y = (0, n.assertNodeType)("Identifier", "PrivateName"), P = (0, n.assertNodeType)("Expression"), v = function(w, x, O) {
            (w.computed ? P : y)(w, x, O);
          };
          return v.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"], v;
        }()
      },
      computed: {
        default: !1
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, n.assertOneOf)(!0, !1),
        optional: !0
      }
    })
  }), a("NewExpression", {
    inherits: "CallExpression"
  }), a("Program", {
    visitor: ["directives", "body"],
    builder: ["body", "directives", "sourceType", "interpreter"],
    fields: {
      sourceFile: {
        validate: (0, n.assertValueType)("string")
      },
      sourceType: {
        validate: (0, n.assertOneOf)("script", "module"),
        default: "script"
      },
      interpreter: {
        validate: (0, n.assertNodeType)("InterpreterDirective"),
        default: null,
        optional: !0
      },
      directives: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Directive"))),
        default: []
      },
      body: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "Block"]
  }), a("ObjectExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement")))
      }
    }
  }), a("ObjectMethod", {
    builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
    fields: Object.assign({}, o(), l(), {
      kind: Object.assign({
        validate: (0, n.assertOneOf)("method", "get", "set")
      }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
        default: "method"
      }),
      computed: {
        default: !1
      },
      key: {
        validate: function() {
          const y = (0, n.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), P = (0, n.assertNodeType)("Expression"), v = function(w, x, O) {
            (w.computed ? P : y)(w, x, O);
          };
          return v.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"], v;
        }()
      },
      decorators: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Decorator"))),
        optional: !0
      },
      body: {
        validate: (0, n.assertNodeType)("BlockStatement")
      }
    }),
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
  }), a("ObjectProperty", {
    builder: ["key", "value", "computed", "shorthand", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["decorators"]],
    fields: {
      computed: {
        default: !1
      },
      key: {
        validate: function() {
          const y = (0, n.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"), P = (0, n.assertNodeType)("Expression");
          return Object.assign(function(w, x, O) {
            (w.computed ? P : y)(w, x, O);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
          });
        }()
      },
      value: {
        validate: (0, n.assertNodeType)("Expression", "PatternLike")
      },
      shorthand: {
        validate: (0, n.chain)((0, n.assertValueType)("boolean"), Object.assign(function(y, P, v) {
          if (process.env.BABEL_TYPES_8_BREAKING && v && y.computed)
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
        }, {
          type: "boolean"
        }), function(y, P, v) {
          if (process.env.BABEL_TYPES_8_BREAKING && v && !(0, e.default)("Identifier", y.key))
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
        }),
        default: !1
      },
      decorators: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Decorator"))),
        optional: !0
      }
    },
    visitor: ["key", "value", "decorators"],
    aliases: ["UserWhitespacable", "Property", "ObjectMember"],
    validate: function() {
      const y = (0, n.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion"), P = (0, n.assertNodeType)("Expression");
      return function(v, w, x) {
        if (!process.env.BABEL_TYPES_8_BREAKING)
          return;
        ((0, e.default)("ObjectPattern", v) ? y : P)(x, "value", x.value);
      };
    }()
  }), a("RestElement", {
    visitor: ["argument", "typeAnnotation"],
    builder: ["argument"],
    aliases: ["LVal", "PatternLike"],
    deprecatedAlias: "RestProperty",
    fields: Object.assign({}, c(), {
      argument: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, n.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, n.assertNodeType)("LVal")
      }
    }),
    validate(y, P) {
      if (!process.env.BABEL_TYPES_8_BREAKING)
        return;
      const v = /(\w+)\[(\d+)\]/.exec(P);
      if (!v)
        throw new Error("Internal Babel error: malformed key.");
      const [, w, x] = v;
      if (y[w].length > +x + 1)
        throw new TypeError(`RestElement must be last element of ${w}`);
    }
  }), a("ReturnStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, n.assertNodeType)("Expression"),
        optional: !0
      }
    }
  }), a("SequenceExpression", {
    visitor: ["expressions"],
    fields: {
      expressions: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Expression")))
      }
    },
    aliases: ["Expression"]
  }), a("ParenthesizedExpression", {
    visitor: ["expression"],
    aliases: ["Expression", "ExpressionWrapper"],
    fields: {
      expression: {
        validate: (0, n.assertNodeType)("Expression")
      }
    }
  }), a("SwitchCase", {
    visitor: ["test", "consequent"],
    fields: {
      test: {
        validate: (0, n.assertNodeType)("Expression"),
        optional: !0
      },
      consequent: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Statement")))
      }
    }
  }), a("SwitchStatement", {
    visitor: ["discriminant", "cases"],
    aliases: ["Statement", "BlockParent", "Scopable"],
    fields: {
      discriminant: {
        validate: (0, n.assertNodeType)("Expression")
      },
      cases: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("SwitchCase")))
      }
    }
  }), a("ThisExpression", {
    aliases: ["Expression"]
  }), a("ThrowStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, n.assertNodeType)("Expression")
      }
    }
  }), a("TryStatement", {
    visitor: ["block", "handler", "finalizer"],
    aliases: ["Statement"],
    fields: {
      block: {
        validate: (0, n.chain)((0, n.assertNodeType)("BlockStatement"), Object.assign(function(y) {
          if (process.env.BABEL_TYPES_8_BREAKING && !y.handler && !y.finalizer)
            throw new TypeError("TryStatement expects either a handler or finalizer, or both");
        }, {
          oneOfNodeTypes: ["BlockStatement"]
        }))
      },
      handler: {
        optional: !0,
        validate: (0, n.assertNodeType)("CatchClause")
      },
      finalizer: {
        optional: !0,
        validate: (0, n.assertNodeType)("BlockStatement")
      }
    }
  }), a("UnaryExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: !0
      },
      argument: {
        validate: (0, n.assertNodeType)("Expression")
      },
      operator: {
        validate: (0, n.assertOneOf)(...s.UNARY_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["UnaryLike", "Expression"]
  }), a("UpdateExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: !1
      },
      argument: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, n.assertNodeType)("Identifier", "MemberExpression") : (0, n.assertNodeType)("Expression")
      },
      operator: {
        validate: (0, n.assertOneOf)(...s.UPDATE_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["Expression"]
  }), a("VariableDeclaration", {
    builder: ["kind", "declarations"],
    visitor: ["declarations"],
    aliases: ["Statement", "Declaration"],
    fields: {
      declare: {
        validate: (0, n.assertValueType)("boolean"),
        optional: !0
      },
      kind: {
        validate: (0, n.assertOneOf)("var", "let", "const", "using", "await using")
      },
      declarations: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("VariableDeclarator")))
      }
    },
    validate(y, P, v) {
      if (process.env.BABEL_TYPES_8_BREAKING && (0, e.default)("ForXStatement", y, {
        left: v
      }) && v.declarations.length !== 1)
        throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${y.type}`);
    }
  }), a("VariableDeclarator", {
    visitor: ["id", "init"],
    fields: {
      id: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, n.assertNodeType)("LVal");
          const y = (0, n.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"), P = (0, n.assertNodeType)("Identifier");
          return function(v, w, x) {
            (v.init ? y : P)(v, w, x);
          };
        }()
      },
      definite: {
        optional: !0,
        validate: (0, n.assertValueType)("boolean")
      },
      init: {
        optional: !0,
        validate: (0, n.assertNodeType)("Expression")
      }
    }
  }), a("WhileStatement", {
    visitor: ["test", "body"],
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
    fields: {
      test: {
        validate: (0, n.assertNodeType)("Expression")
      },
      body: {
        validate: (0, n.assertNodeType)("Statement")
      }
    }
  }), a("WithStatement", {
    visitor: ["object", "body"],
    aliases: ["Statement"],
    fields: {
      object: {
        validate: (0, n.assertNodeType)("Expression")
      },
      body: {
        validate: (0, n.assertNodeType)("Statement")
      }
    }
  }), a("AssignmentPattern", {
    visitor: ["left", "right", "decorators"],
    builder: ["left", "right"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, c(), {
      left: {
        validate: (0, n.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: (0, n.assertNodeType)("Expression")
      },
      decorators: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Decorator"))),
        optional: !0
      }
    })
  }), a("ArrayPattern", {
    visitor: ["elements", "typeAnnotation"],
    builder: ["elements"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, c(), {
      elements: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeOrValueType)("null", "PatternLike", "LVal")))
      }
    })
  }), a("ArrowFunctionExpression", {
    builder: ["params", "body", "async"],
    visitor: ["params", "body", "returnType", "typeParameters"],
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, o(), l(), {
      expression: {
        validate: (0, n.assertValueType)("boolean")
      },
      body: {
        validate: (0, n.assertNodeType)("BlockStatement", "Expression")
      },
      predicate: {
        validate: (0, n.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    })
  }), a("ClassBody", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")))
      }
    }
  }), a("ClassExpression", {
    builder: ["id", "superClass", "body", "decorators"],
    visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
    aliases: ["Scopable", "Class", "Expression"],
    fields: {
      id: {
        validate: (0, n.assertNodeType)("Identifier"),
        optional: !0
      },
      typeParameters: {
        validate: (0, n.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: !0
      },
      body: {
        validate: (0, n.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: !0,
        validate: (0, n.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, n.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      },
      implements: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
        optional: !0
      },
      decorators: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Decorator"))),
        optional: !0
      },
      mixins: {
        validate: (0, n.assertNodeType)("InterfaceExtends"),
        optional: !0
      }
    }
  }), a("ClassDeclaration", {
    inherits: "ClassExpression",
    aliases: ["Scopable", "Class", "Statement", "Declaration"],
    fields: {
      id: {
        validate: (0, n.assertNodeType)("Identifier")
      },
      typeParameters: {
        validate: (0, n.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: !0
      },
      body: {
        validate: (0, n.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: !0,
        validate: (0, n.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, n.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      },
      implements: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
        optional: !0
      },
      decorators: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Decorator"))),
        optional: !0
      },
      mixins: {
        validate: (0, n.assertNodeType)("InterfaceExtends"),
        optional: !0
      },
      declare: {
        validate: (0, n.assertValueType)("boolean"),
        optional: !0
      },
      abstract: {
        validate: (0, n.assertValueType)("boolean"),
        optional: !0
      }
    },
    validate: function() {
      const y = (0, n.assertNodeType)("Identifier");
      return function(P, v, w) {
        process.env.BABEL_TYPES_8_BREAKING && ((0, e.default)("ExportDefaultDeclaration", P) || y(w, "id", w.id));
      };
    }()
  }), a("ExportAllDeclaration", {
    builder: ["source"],
    visitor: ["source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      source: {
        validate: (0, n.assertNodeType)("StringLiteral")
      },
      exportKind: (0, n.validateOptional)((0, n.assertOneOf)("type", "value")),
      attributes: {
        optional: !0,
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("ImportAttribute")))
      },
      assertions: {
        optional: !0,
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("ImportAttribute")))
      }
    }
  }), a("ExportDefaultDeclaration", {
    visitor: ["declaration"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      declaration: {
        validate: (0, n.assertNodeType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression")
      },
      exportKind: (0, n.validateOptional)((0, n.assertOneOf)("value"))
    }
  }), a("ExportNamedDeclaration", {
    builder: ["declaration", "specifiers", "source"],
    visitor: ["declaration", "specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      declaration: {
        optional: !0,
        validate: (0, n.chain)((0, n.assertNodeType)("Declaration"), Object.assign(function(y, P, v) {
          if (process.env.BABEL_TYPES_8_BREAKING && v && y.specifiers.length)
            throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
        }, {
          oneOfNodeTypes: ["Declaration"]
        }), function(y, P, v) {
          if (process.env.BABEL_TYPES_8_BREAKING && v && y.source)
            throw new TypeError("Cannot export a declaration from a source");
        })
      },
      attributes: {
        optional: !0,
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("ImportAttribute")))
      },
      assertions: {
        optional: !0,
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("ImportAttribute")))
      },
      specifiers: {
        default: [],
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)(function() {
          const y = (0, n.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"), P = (0, n.assertNodeType)("ExportSpecifier");
          return process.env.BABEL_TYPES_8_BREAKING ? function(v, w, x) {
            (v.source ? y : P)(v, w, x);
          } : y;
        }()))
      },
      source: {
        validate: (0, n.assertNodeType)("StringLiteral"),
        optional: !0
      },
      exportKind: (0, n.validateOptional)((0, n.assertOneOf)("type", "value"))
    }
  }), a("ExportSpecifier", {
    visitor: ["local", "exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, n.assertNodeType)("Identifier")
      },
      exported: {
        validate: (0, n.assertNodeType)("Identifier", "StringLiteral")
      },
      exportKind: {
        validate: (0, n.assertOneOf)("type", "value"),
        optional: !0
      }
    }
  }), a("ForOfStatement", {
    visitor: ["left", "right", "body"],
    builder: ["left", "right", "body", "await"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, n.assertNodeType)("VariableDeclaration", "LVal");
          const y = (0, n.assertNodeType)("VariableDeclaration"), P = (0, n.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
          return function(v, w, x) {
            (0, e.default)("VariableDeclaration", x) ? y(v, w, x) : P(v, w, x);
          };
        }()
      },
      right: {
        validate: (0, n.assertNodeType)("Expression")
      },
      body: {
        validate: (0, n.assertNodeType)("Statement")
      },
      await: {
        default: !1
      }
    }
  }), a("ImportDeclaration", {
    builder: ["specifiers", "source"],
    visitor: ["specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"],
    fields: {
      attributes: {
        optional: !0,
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("ImportAttribute")))
      },
      assertions: {
        optional: !0,
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("ImportAttribute")))
      },
      module: {
        optional: !0,
        validate: (0, n.assertValueType)("boolean")
      },
      specifiers: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
      },
      source: {
        validate: (0, n.assertNodeType)("StringLiteral")
      },
      importKind: {
        validate: (0, n.assertOneOf)("type", "typeof", "value"),
        optional: !0
      }
    }
  }), a("ImportDefaultSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, n.assertNodeType)("Identifier")
      }
    }
  }), a("ImportNamespaceSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, n.assertNodeType)("Identifier")
      }
    }
  }), a("ImportSpecifier", {
    visitor: ["local", "imported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, n.assertNodeType)("Identifier")
      },
      imported: {
        validate: (0, n.assertNodeType)("Identifier", "StringLiteral")
      },
      importKind: {
        validate: (0, n.assertOneOf)("type", "typeof", "value"),
        optional: !0
      }
    }
  }), a("MetaProperty", {
    visitor: ["meta", "property"],
    aliases: ["Expression"],
    fields: {
      meta: {
        validate: (0, n.chain)((0, n.assertNodeType)("Identifier"), Object.assign(function(y, P, v) {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return;
          let w;
          switch (v.name) {
            case "function":
              w = "sent";
              break;
            case "new":
              w = "target";
              break;
            case "import":
              w = "meta";
              break;
          }
          if (!(0, e.default)("Identifier", y.property, {
            name: w
          }))
            throw new TypeError("Unrecognised MetaProperty");
        }, {
          oneOfNodeTypes: ["Identifier"]
        }))
      },
      property: {
        validate: (0, n.assertNodeType)("Identifier")
      }
    }
  });
  const p = () => ({
    abstract: {
      validate: (0, n.assertValueType)("boolean"),
      optional: !0
    },
    accessibility: {
      validate: (0, n.assertOneOf)("public", "private", "protected"),
      optional: !0
    },
    static: {
      default: !1
    },
    override: {
      default: !1
    },
    computed: {
      default: !1
    },
    optional: {
      validate: (0, n.assertValueType)("boolean"),
      optional: !0
    },
    key: {
      validate: (0, n.chain)(function() {
        const y = (0, n.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral"), P = (0, n.assertNodeType)("Expression");
        return function(v, w, x) {
          (v.computed ? P : y)(v, w, x);
        };
      }(), (0, n.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
    }
  });
  it.classMethodOrPropertyCommon = p;
  const h = () => Object.assign({}, o(), p(), {
    params: {
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty")))
    },
    kind: {
      validate: (0, n.assertOneOf)("get", "set", "method", "constructor"),
      default: "method"
    },
    access: {
      validate: (0, n.chain)((0, n.assertValueType)("string"), (0, n.assertOneOf)("public", "private", "protected")),
      optional: !0
    },
    decorators: {
      validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Decorator"))),
      optional: !0
    }
  });
  return it.classMethodOrDeclareMethodCommon = h, a("ClassMethod", {
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
    builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    fields: Object.assign({}, h(), l(), {
      body: {
        validate: (0, n.assertNodeType)("BlockStatement")
      }
    })
  }), a("ObjectPattern", {
    visitor: ["properties", "typeAnnotation", "decorators"],
    builder: ["properties"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, c(), {
      properties: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("RestElement", "ObjectProperty")))
      }
    })
  }), a("SpreadElement", {
    visitor: ["argument"],
    aliases: ["UnaryLike"],
    deprecatedAlias: "SpreadProperty",
    fields: {
      argument: {
        validate: (0, n.assertNodeType)("Expression")
      }
    }
  }), a("Super", {
    aliases: ["Expression"]
  }), a("TaggedTemplateExpression", {
    visitor: ["tag", "quasi", "typeParameters"],
    builder: ["tag", "quasi"],
    aliases: ["Expression"],
    fields: {
      tag: {
        validate: (0, n.assertNodeType)("Expression")
      },
      quasi: {
        validate: (0, n.assertNodeType)("TemplateLiteral")
      },
      typeParameters: {
        validate: (0, n.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  }), a("TemplateElement", {
    builder: ["value", "tail"],
    fields: {
      value: {
        validate: (0, n.chain)((0, n.assertShape)({
          raw: {
            validate: (0, n.assertValueType)("string")
          },
          cooked: {
            validate: (0, n.assertValueType)("string"),
            optional: !0
          }
        }), function(P) {
          const v = P.value.raw;
          let w = !1;
          const x = () => {
            throw new Error("Internal @babel/types error.");
          }, {
            str: O,
            firstInvalidLoc: _
          } = (0, i.readStringContents)("template", v, 0, 0, 0, {
            unterminated() {
              w = !0;
            },
            strictNumericEscape: x,
            invalidEscapeSequence: x,
            numericSeparatorInEscapeSequence: x,
            unexpectedNumericSeparator: x,
            invalidDigit: x,
            invalidCodePoint: x
          });
          if (!w)
            throw new Error("Invalid raw");
          P.value.cooked = _ ? null : O;
        })
      },
      tail: {
        default: !1
      }
    }
  }), a("TemplateLiteral", {
    visitor: ["quasis", "expressions"],
    aliases: ["Expression", "Literal"],
    fields: {
      quasis: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("TemplateElement")))
      },
      expressions: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Expression", "TSType")), function(y, P, v) {
          if (y.quasis.length !== v.length + 1)
            throw new TypeError(`Number of ${y.type} quasis should be exactly one more than the number of expressions.
Expected ${v.length + 1} quasis but got ${y.quasis.length}`);
        })
      }
    }
  }), a("YieldExpression", {
    builder: ["argument", "delegate"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      delegate: {
        validate: (0, n.chain)((0, n.assertValueType)("boolean"), Object.assign(function(y, P, v) {
          if (process.env.BABEL_TYPES_8_BREAKING && v && !y.argument)
            throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
        }, {
          type: "boolean"
        })),
        default: !1
      },
      argument: {
        optional: !0,
        validate: (0, n.assertNodeType)("Expression")
      }
    }
  }), a("AwaitExpression", {
    builder: ["argument"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      argument: {
        validate: (0, n.assertNodeType)("Expression")
      }
    }
  }), a("Import", {
    aliases: ["Expression"]
  }), a("BigIntLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, n.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  }), a("ExportNamespaceSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, n.assertNodeType)("Identifier")
      }
    }
  }), a("OptionalMemberExpression", {
    builder: ["object", "property", "computed", "optional"],
    visitor: ["object", "property"],
    aliases: ["Expression"],
    fields: {
      object: {
        validate: (0, n.assertNodeType)("Expression")
      },
      property: {
        validate: function() {
          const y = (0, n.assertNodeType)("Identifier"), P = (0, n.assertNodeType)("Expression");
          return Object.assign(function(w, x, O) {
            (w.computed ? P : y)(w, x, O);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier"]
          });
        }()
      },
      computed: {
        default: !1
      },
      optional: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, n.chain)((0, n.assertValueType)("boolean"), (0, n.assertOptionalChainStart)()) : (0, n.assertValueType)("boolean")
      }
    }
  }), a("OptionalCallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments", "optional"],
    aliases: ["Expression"],
    fields: {
      callee: {
        validate: (0, n.assertNodeType)("Expression")
      },
      arguments: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
      },
      optional: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, n.chain)((0, n.assertValueType)("boolean"), (0, n.assertOptionalChainStart)()) : (0, n.assertValueType)("boolean")
      },
      typeArguments: {
        validate: (0, n.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      },
      typeParameters: {
        validate: (0, n.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  }), a("ClassProperty", {
    visitor: ["key", "value", "typeAnnotation", "decorators"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property"],
    fields: Object.assign({}, p(), {
      value: {
        validate: (0, n.assertNodeType)("Expression"),
        optional: !0
      },
      definite: {
        validate: (0, n.assertValueType)("boolean"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, n.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Decorator"))),
        optional: !0
      },
      readonly: {
        validate: (0, n.assertValueType)("boolean"),
        optional: !0
      },
      declare: {
        validate: (0, n.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, n.assertNodeType)("Variance"),
        optional: !0
      }
    })
  }), a("ClassAccessorProperty", {
    visitor: ["key", "value", "typeAnnotation", "decorators"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property", "Accessor"],
    fields: Object.assign({}, p(), {
      key: {
        validate: (0, n.chain)(function() {
          const y = (0, n.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName"), P = (0, n.assertNodeType)("Expression");
          return function(v, w, x) {
            (v.computed ? P : y)(v, w, x);
          };
        }(), (0, n.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
      },
      value: {
        validate: (0, n.assertNodeType)("Expression"),
        optional: !0
      },
      definite: {
        validate: (0, n.assertValueType)("boolean"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, n.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Decorator"))),
        optional: !0
      },
      readonly: {
        validate: (0, n.assertValueType)("boolean"),
        optional: !0
      },
      declare: {
        validate: (0, n.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, n.assertNodeType)("Variance"),
        optional: !0
      }
    })
  }), a("ClassPrivateProperty", {
    visitor: ["key", "value", "decorators", "typeAnnotation"],
    builder: ["key", "value", "decorators", "static"],
    aliases: ["Property", "Private"],
    fields: {
      key: {
        validate: (0, n.assertNodeType)("PrivateName")
      },
      value: {
        validate: (0, n.assertNodeType)("Expression"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, n.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Decorator"))),
        optional: !0
      },
      static: {
        validate: (0, n.assertValueType)("boolean"),
        default: !1
      },
      readonly: {
        validate: (0, n.assertValueType)("boolean"),
        optional: !0
      },
      definite: {
        validate: (0, n.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, n.assertNodeType)("Variance"),
        optional: !0
      }
    }
  }), a("ClassPrivateMethod", {
    builder: ["kind", "key", "params", "body", "static"],
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
    fields: Object.assign({}, h(), l(), {
      kind: {
        validate: (0, n.assertOneOf)("get", "set", "method"),
        default: "method"
      },
      key: {
        validate: (0, n.assertNodeType)("PrivateName")
      },
      body: {
        validate: (0, n.assertNodeType)("BlockStatement")
      }
    })
  }), a("PrivateName", {
    visitor: ["id"],
    aliases: ["Private"],
    fields: {
      id: {
        validate: (0, n.assertNodeType)("Identifier")
      }
    }
  }), a("StaticBlock", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "FunctionParent"]
  }), it;
}
var Ko = {}, qo;
function lx() {
  if (qo)
    return Ko;
  qo = 1;
  var e = Qt();
  const t = (0, e.defineAliasedType)("Flow"), r = (i) => {
    const s = i === "DeclareClass";
    t(i, {
      builder: ["id", "typeParameters", "extends", "body"],
      visitor: ["id", "typeParameters", "extends", ...s ? ["mixins", "implements"] : [], "body"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: Object.assign({
        id: (0, e.validateType)("Identifier"),
        typeParameters: (0, e.validateOptionalType)("TypeParameterDeclaration"),
        extends: (0, e.validateOptional)((0, e.arrayOfType)("InterfaceExtends"))
      }, s ? {
        mixins: (0, e.validateOptional)((0, e.arrayOfType)("InterfaceExtends")),
        implements: (0, e.validateOptional)((0, e.arrayOfType)("ClassImplements"))
      } : {}, {
        body: (0, e.validateType)("ObjectTypeAnnotation")
      })
    });
  };
  return t("AnyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), t("ArrayTypeAnnotation", {
    visitor: ["elementType"],
    aliases: ["FlowType"],
    fields: {
      elementType: (0, e.validateType)("FlowType")
    }
  }), t("BooleanTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), t("BooleanLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, e.validate)((0, e.assertValueType)("boolean"))
    }
  }), t("NullLiteralTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), t("ClassImplements", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, e.validateType)("Identifier"),
      typeParameters: (0, e.validateOptionalType)("TypeParameterInstantiation")
    }
  }), r("DeclareClass"), t("DeclareFunction", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, e.validateType)("Identifier"),
      predicate: (0, e.validateOptionalType)("DeclaredPredicate")
    }
  }), r("DeclareInterface"), t("DeclareModule", {
    builder: ["id", "body", "kind"],
    visitor: ["id", "body"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, e.validateType)(["Identifier", "StringLiteral"]),
      body: (0, e.validateType)("BlockStatement"),
      kind: (0, e.validateOptional)((0, e.assertOneOf)("CommonJS", "ES"))
    }
  }), t("DeclareModuleExports", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      typeAnnotation: (0, e.validateType)("TypeAnnotation")
    }
  }), t("DeclareTypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, e.validateType)("Identifier"),
      typeParameters: (0, e.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, e.validateType)("FlowType")
    }
  }), t("DeclareOpaqueType", {
    visitor: ["id", "typeParameters", "supertype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, e.validateType)("Identifier"),
      typeParameters: (0, e.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, e.validateOptionalType)("FlowType"),
      impltype: (0, e.validateOptionalType)("FlowType")
    }
  }), t("DeclareVariable", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, e.validateType)("Identifier")
    }
  }), t("DeclareExportDeclaration", {
    visitor: ["declaration", "specifiers", "source"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      declaration: (0, e.validateOptionalType)("Flow"),
      specifiers: (0, e.validateOptional)((0, e.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])),
      source: (0, e.validateOptionalType)("StringLiteral"),
      default: (0, e.validateOptional)((0, e.assertValueType)("boolean"))
    }
  }), t("DeclareExportAllDeclaration", {
    visitor: ["source"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      source: (0, e.validateType)("StringLiteral"),
      exportKind: (0, e.validateOptional)((0, e.assertOneOf)("type", "value"))
    }
  }), t("DeclaredPredicate", {
    visitor: ["value"],
    aliases: ["FlowPredicate"],
    fields: {
      value: (0, e.validateType)("Flow")
    }
  }), t("ExistsTypeAnnotation", {
    aliases: ["FlowType"]
  }), t("FunctionTypeAnnotation", {
    visitor: ["typeParameters", "params", "rest", "returnType"],
    aliases: ["FlowType"],
    fields: {
      typeParameters: (0, e.validateOptionalType)("TypeParameterDeclaration"),
      params: (0, e.validate)((0, e.arrayOfType)("FunctionTypeParam")),
      rest: (0, e.validateOptionalType)("FunctionTypeParam"),
      this: (0, e.validateOptionalType)("FunctionTypeParam"),
      returnType: (0, e.validateType)("FlowType")
    }
  }), t("FunctionTypeParam", {
    visitor: ["name", "typeAnnotation"],
    fields: {
      name: (0, e.validateOptionalType)("Identifier"),
      typeAnnotation: (0, e.validateType)("FlowType"),
      optional: (0, e.validateOptional)((0, e.assertValueType)("boolean"))
    }
  }), t("GenericTypeAnnotation", {
    visitor: ["id", "typeParameters"],
    aliases: ["FlowType"],
    fields: {
      id: (0, e.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: (0, e.validateOptionalType)("TypeParameterInstantiation")
    }
  }), t("InferredPredicate", {
    aliases: ["FlowPredicate"]
  }), t("InterfaceExtends", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, e.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: (0, e.validateOptionalType)("TypeParameterInstantiation")
    }
  }), r("InterfaceDeclaration"), t("InterfaceTypeAnnotation", {
    visitor: ["extends", "body"],
    aliases: ["FlowType"],
    fields: {
      extends: (0, e.validateOptional)((0, e.arrayOfType)("InterfaceExtends")),
      body: (0, e.validateType)("ObjectTypeAnnotation")
    }
  }), t("IntersectionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, e.validate)((0, e.arrayOfType)("FlowType"))
    }
  }), t("MixedTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), t("EmptyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), t("NullableTypeAnnotation", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowType"],
    fields: {
      typeAnnotation: (0, e.validateType)("FlowType")
    }
  }), t("NumberLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, e.validate)((0, e.assertValueType)("number"))
    }
  }), t("NumberTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), t("ObjectTypeAnnotation", {
    visitor: ["properties", "indexers", "callProperties", "internalSlots"],
    aliases: ["FlowType"],
    builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
    fields: {
      properties: (0, e.validate)((0, e.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])),
      indexers: {
        validate: (0, e.arrayOfType)("ObjectTypeIndexer"),
        optional: !0,
        default: []
      },
      callProperties: {
        validate: (0, e.arrayOfType)("ObjectTypeCallProperty"),
        optional: !0,
        default: []
      },
      internalSlots: {
        validate: (0, e.arrayOfType)("ObjectTypeInternalSlot"),
        optional: !0,
        default: []
      },
      exact: {
        validate: (0, e.assertValueType)("boolean"),
        default: !1
      },
      inexact: (0, e.validateOptional)((0, e.assertValueType)("boolean"))
    }
  }), t("ObjectTypeInternalSlot", {
    visitor: ["id", "value", "optional", "static", "method"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, e.validateType)("Identifier"),
      value: (0, e.validateType)("FlowType"),
      optional: (0, e.validate)((0, e.assertValueType)("boolean")),
      static: (0, e.validate)((0, e.assertValueType)("boolean")),
      method: (0, e.validate)((0, e.assertValueType)("boolean"))
    }
  }), t("ObjectTypeCallProperty", {
    visitor: ["value"],
    aliases: ["UserWhitespacable"],
    fields: {
      value: (0, e.validateType)("FlowType"),
      static: (0, e.validate)((0, e.assertValueType)("boolean"))
    }
  }), t("ObjectTypeIndexer", {
    visitor: ["id", "key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, e.validateOptionalType)("Identifier"),
      key: (0, e.validateType)("FlowType"),
      value: (0, e.validateType)("FlowType"),
      static: (0, e.validate)((0, e.assertValueType)("boolean")),
      variance: (0, e.validateOptionalType)("Variance")
    }
  }), t("ObjectTypeProperty", {
    visitor: ["key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      key: (0, e.validateType)(["Identifier", "StringLiteral"]),
      value: (0, e.validateType)("FlowType"),
      kind: (0, e.validate)((0, e.assertOneOf)("init", "get", "set")),
      static: (0, e.validate)((0, e.assertValueType)("boolean")),
      proto: (0, e.validate)((0, e.assertValueType)("boolean")),
      optional: (0, e.validate)((0, e.assertValueType)("boolean")),
      variance: (0, e.validateOptionalType)("Variance"),
      method: (0, e.validate)((0, e.assertValueType)("boolean"))
    }
  }), t("ObjectTypeSpreadProperty", {
    visitor: ["argument"],
    aliases: ["UserWhitespacable"],
    fields: {
      argument: (0, e.validateType)("FlowType")
    }
  }), t("OpaqueType", {
    visitor: ["id", "typeParameters", "supertype", "impltype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, e.validateType)("Identifier"),
      typeParameters: (0, e.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, e.validateOptionalType)("FlowType"),
      impltype: (0, e.validateType)("FlowType")
    }
  }), t("QualifiedTypeIdentifier", {
    visitor: ["id", "qualification"],
    fields: {
      id: (0, e.validateType)("Identifier"),
      qualification: (0, e.validateType)(["Identifier", "QualifiedTypeIdentifier"])
    }
  }), t("StringLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, e.validate)((0, e.assertValueType)("string"))
    }
  }), t("StringTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), t("SymbolTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), t("ThisTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), t("TupleTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, e.validate)((0, e.arrayOfType)("FlowType"))
    }
  }), t("TypeofTypeAnnotation", {
    visitor: ["argument"],
    aliases: ["FlowType"],
    fields: {
      argument: (0, e.validateType)("FlowType")
    }
  }), t("TypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, e.validateType)("Identifier"),
      typeParameters: (0, e.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, e.validateType)("FlowType")
    }
  }), t("TypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, e.validateType)("FlowType")
    }
  }), t("TypeCastExpression", {
    visitor: ["expression", "typeAnnotation"],
    aliases: ["ExpressionWrapper", "Expression"],
    fields: {
      expression: (0, e.validateType)("Expression"),
      typeAnnotation: (0, e.validateType)("TypeAnnotation")
    }
  }), t("TypeParameter", {
    visitor: ["bound", "default", "variance"],
    fields: {
      name: (0, e.validate)((0, e.assertValueType)("string")),
      bound: (0, e.validateOptionalType)("TypeAnnotation"),
      default: (0, e.validateOptionalType)("FlowType"),
      variance: (0, e.validateOptionalType)("Variance")
    }
  }), t("TypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: (0, e.validate)((0, e.arrayOfType)("TypeParameter"))
    }
  }), t("TypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: (0, e.validate)((0, e.arrayOfType)("FlowType"))
    }
  }), t("UnionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, e.validate)((0, e.arrayOfType)("FlowType"))
    }
  }), t("Variance", {
    builder: ["kind"],
    fields: {
      kind: (0, e.validate)((0, e.assertOneOf)("minus", "plus"))
    }
  }), t("VoidTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), t("EnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      id: (0, e.validateType)("Identifier"),
      body: (0, e.validateType)(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"])
    }
  }), t("EnumBooleanBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, e.validate)((0, e.assertValueType)("boolean")),
      members: (0, e.validateArrayOfType)("EnumBooleanMember"),
      hasUnknownMembers: (0, e.validate)((0, e.assertValueType)("boolean"))
    }
  }), t("EnumNumberBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, e.validate)((0, e.assertValueType)("boolean")),
      members: (0, e.validateArrayOfType)("EnumNumberMember"),
      hasUnknownMembers: (0, e.validate)((0, e.assertValueType)("boolean"))
    }
  }), t("EnumStringBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, e.validate)((0, e.assertValueType)("boolean")),
      members: (0, e.validateArrayOfType)(["EnumStringMember", "EnumDefaultedMember"]),
      hasUnknownMembers: (0, e.validate)((0, e.assertValueType)("boolean"))
    }
  }), t("EnumSymbolBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      members: (0, e.validateArrayOfType)("EnumDefaultedMember"),
      hasUnknownMembers: (0, e.validate)((0, e.assertValueType)("boolean"))
    }
  }), t("EnumBooleanMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, e.validateType)("Identifier"),
      init: (0, e.validateType)("BooleanLiteral")
    }
  }), t("EnumNumberMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, e.validateType)("Identifier"),
      init: (0, e.validateType)("NumericLiteral")
    }
  }), t("EnumStringMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, e.validateType)("Identifier"),
      init: (0, e.validateType)("StringLiteral")
    }
  }), t("EnumDefaultedMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, e.validateType)("Identifier")
    }
  }), t("IndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, e.validateType)("FlowType"),
      indexType: (0, e.validateType)("FlowType")
    }
  }), t("OptionalIndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, e.validateType)("FlowType"),
      indexType: (0, e.validateType)("FlowType"),
      optional: (0, e.validate)((0, e.assertValueType)("boolean"))
    }
  }), Ko;
}
var Wo = {}, Yo;
function ux() {
  if (Yo)
    return Wo;
  Yo = 1;
  var e = Qt();
  const t = (0, e.defineAliasedType)("JSX");
  return t("JSXAttribute", {
    visitor: ["name", "value"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, e.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
      },
      value: {
        optional: !0,
        validate: (0, e.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
      }
    }
  }), t("JSXClosingElement", {
    visitor: ["name"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, e.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      }
    }
  }), t("JSXElement", {
    builder: ["openingElement", "closingElement", "children", "selfClosing"],
    visitor: ["openingElement", "children", "closingElement"],
    aliases: ["Immutable", "Expression"],
    fields: Object.assign({
      openingElement: {
        validate: (0, e.assertNodeType)("JSXOpeningElement")
      },
      closingElement: {
        optional: !0,
        validate: (0, e.assertNodeType)("JSXClosingElement")
      },
      children: {
        validate: (0, e.chain)((0, e.assertValueType)("array"), (0, e.assertEach)((0, e.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
      }
    }, {
      selfClosing: {
        validate: (0, e.assertValueType)("boolean"),
        optional: !0
      }
    })
  }), t("JSXEmptyExpression", {}), t("JSXExpressionContainer", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, e.assertNodeType)("Expression", "JSXEmptyExpression")
      }
    }
  }), t("JSXSpreadChild", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, e.assertNodeType)("Expression")
      }
    }
  }), t("JSXIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, e.assertValueType)("string")
      }
    }
  }), t("JSXMemberExpression", {
    visitor: ["object", "property"],
    fields: {
      object: {
        validate: (0, e.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
      },
      property: {
        validate: (0, e.assertNodeType)("JSXIdentifier")
      }
    }
  }), t("JSXNamespacedName", {
    visitor: ["namespace", "name"],
    fields: {
      namespace: {
        validate: (0, e.assertNodeType)("JSXIdentifier")
      },
      name: {
        validate: (0, e.assertNodeType)("JSXIdentifier")
      }
    }
  }), t("JSXOpeningElement", {
    builder: ["name", "attributes", "selfClosing"],
    visitor: ["name", "attributes"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, e.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      },
      selfClosing: {
        default: !1
      },
      attributes: {
        validate: (0, e.chain)((0, e.assertValueType)("array"), (0, e.assertEach)((0, e.assertNodeType)("JSXAttribute", "JSXSpreadAttribute")))
      },
      typeParameters: {
        validate: (0, e.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  }), t("JSXSpreadAttribute", {
    visitor: ["argument"],
    fields: {
      argument: {
        validate: (0, e.assertNodeType)("Expression")
      }
    }
  }), t("JSXText", {
    aliases: ["Immutable"],
    builder: ["value"],
    fields: {
      value: {
        validate: (0, e.assertValueType)("string")
      }
    }
  }), t("JSXFragment", {
    builder: ["openingFragment", "closingFragment", "children"],
    visitor: ["openingFragment", "children", "closingFragment"],
    aliases: ["Immutable", "Expression"],
    fields: {
      openingFragment: {
        validate: (0, e.assertNodeType)("JSXOpeningFragment")
      },
      closingFragment: {
        validate: (0, e.assertNodeType)("JSXClosingFragment")
      },
      children: {
        validate: (0, e.chain)((0, e.assertValueType)("array"), (0, e.assertEach)((0, e.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
      }
    }
  }), t("JSXOpeningFragment", {
    aliases: ["Immutable"]
  }), t("JSXClosingFragment", {
    aliases: ["Immutable"]
  }), Wo;
}
var Xo = {}, At = {}, Jo;
function kc() {
  if (Jo)
    return At;
  Jo = 1, Object.defineProperty(At, "__esModule", {
    value: !0
  }), At.PLACEHOLDERS_FLIPPED_ALIAS = At.PLACEHOLDERS_ALIAS = At.PLACEHOLDERS = void 0;
  var e = Qt();
  const t = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"];
  At.PLACEHOLDERS = t;
  const r = {
    Declaration: ["Statement"],
    Pattern: ["PatternLike", "LVal"]
  };
  At.PLACEHOLDERS_ALIAS = r;
  for (const s of t) {
    const n = e.ALIAS_KEYS[s];
    n != null && n.length && (r[s] = n);
  }
  const i = {};
  return At.PLACEHOLDERS_FLIPPED_ALIAS = i, Object.keys(r).forEach((s) => {
    r[s].forEach((n) => {
      Object.hasOwnProperty.call(i, n) || (i[n] = []), i[n].push(s);
    });
  }), At;
}
var Ho;
function cx() {
  if (Ho)
    return Xo;
  Ho = 1;
  var e = Qt(), t = kc();
  const r = (0, e.defineAliasedType)("Miscellaneous");
  return r("Noop", {
    visitor: []
  }), r("Placeholder", {
    visitor: [],
    builder: ["expectedNode", "name"],
    fields: {
      name: {
        validate: (0, e.assertNodeType)("Identifier")
      },
      expectedNode: {
        validate: (0, e.assertOneOf)(...t.PLACEHOLDERS)
      }
    }
  }), r("V8IntrinsicIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, e.assertValueType)("string")
      }
    }
  }), Xo;
}
var Go = {}, zo;
function fx() {
  if (zo)
    return Go;
  zo = 1;
  var e = Qt();
  return (0, e.default)("ArgumentPlaceholder", {}), (0, e.default)("BindExpression", {
    visitor: ["object", "callee"],
    aliases: ["Expression"],
    fields: process.env.BABEL_TYPES_8_BREAKING ? {
      object: {
        validate: (0, e.assertNodeType)("Expression")
      },
      callee: {
        validate: (0, e.assertNodeType)("Expression")
      }
    } : {
      object: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      },
      callee: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      }
    }
  }), (0, e.default)("ImportAttribute", {
    visitor: ["key", "value"],
    fields: {
      key: {
        validate: (0, e.assertNodeType)("Identifier", "StringLiteral")
      },
      value: {
        validate: (0, e.assertNodeType)("StringLiteral")
      }
    }
  }), (0, e.default)("Decorator", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, e.assertNodeType)("Expression")
      }
    }
  }), (0, e.default)("DoExpression", {
    visitor: ["body"],
    builder: ["body", "async"],
    aliases: ["Expression"],
    fields: {
      body: {
        validate: (0, e.assertNodeType)("BlockStatement")
      },
      async: {
        validate: (0, e.assertValueType)("boolean"),
        default: !1
      }
    }
  }), (0, e.default)("ExportDefaultSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, e.assertNodeType)("Identifier")
      }
    }
  }), (0, e.default)("RecordExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: (0, e.chain)((0, e.assertValueType)("array"), (0, e.assertEach)((0, e.assertNodeType)("ObjectProperty", "SpreadElement")))
      }
    }
  }), (0, e.default)("TupleExpression", {
    fields: {
      elements: {
        validate: (0, e.chain)((0, e.assertValueType)("array"), (0, e.assertEach)((0, e.assertNodeType)("Expression", "SpreadElement"))),
        default: []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  }), (0, e.default)("DecimalLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, e.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  }), (0, e.default)("ModuleExpression", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, e.assertNodeType)("Program")
      }
    },
    aliases: ["Expression"]
  }), (0, e.default)("TopicReference", {
    aliases: ["Expression"]
  }), (0, e.default)("PipelineTopicExpression", {
    builder: ["expression"],
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, e.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  }), (0, e.default)("PipelineBareFunction", {
    builder: ["callee"],
    visitor: ["callee"],
    fields: {
      callee: {
        validate: (0, e.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  }), (0, e.default)("PipelinePrimaryTopicReference", {
    aliases: ["Expression"]
  }), Go;
}
var Qo = {}, Zo;
function px() {
  if (Zo)
    return Qo;
  Zo = 1;
  var e = Qt(), t = Dc(), r = fi();
  const i = (0, e.defineAliasedType)("TypeScript"), s = (0, e.assertValueType)("boolean"), n = () => ({
    returnType: {
      validate: (0, e.assertNodeType)("TSTypeAnnotation", "Noop"),
      optional: !0
    },
    typeParameters: {
      validate: (0, e.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
      optional: !0
    }
  });
  i("TSParameterProperty", {
    aliases: ["LVal"],
    visitor: ["parameter"],
    fields: {
      accessibility: {
        validate: (0, e.assertOneOf)("public", "private", "protected"),
        optional: !0
      },
      readonly: {
        validate: (0, e.assertValueType)("boolean"),
        optional: !0
      },
      parameter: {
        validate: (0, e.assertNodeType)("Identifier", "AssignmentPattern")
      },
      override: {
        validate: (0, e.assertValueType)("boolean"),
        optional: !0
      },
      decorators: {
        validate: (0, e.chain)((0, e.assertValueType)("array"), (0, e.assertEach)((0, e.assertNodeType)("Decorator"))),
        optional: !0
      }
    }
  }), i("TSDeclareFunction", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, t.functionDeclarationCommon)(), n())
  }), i("TSDeclareMethod", {
    visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, t.classMethodOrDeclareMethodCommon)(), n())
  }), i("TSQualifiedName", {
    aliases: ["TSEntityName"],
    visitor: ["left", "right"],
    fields: {
      left: (0, e.validateType)("TSEntityName"),
      right: (0, e.validateType)("Identifier")
    }
  });
  const a = () => ({
    typeParameters: (0, e.validateOptionalType)("TSTypeParameterDeclaration"),
    parameters: (0, e.validateArrayOfType)(["Identifier", "RestElement"]),
    typeAnnotation: (0, e.validateOptionalType)("TSTypeAnnotation")
  }), o = {
    aliases: ["TSTypeElement"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"],
    fields: a()
  };
  i("TSCallSignatureDeclaration", o), i("TSConstructSignatureDeclaration", o);
  const l = () => ({
    key: (0, e.validateType)("Expression"),
    computed: {
      default: !1
    },
    optional: (0, e.validateOptional)(s)
  });
  i("TSPropertySignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeAnnotation", "initializer"],
    fields: Object.assign({}, l(), {
      readonly: (0, e.validateOptional)(s),
      typeAnnotation: (0, e.validateOptionalType)("TSTypeAnnotation"),
      initializer: (0, e.validateOptionalType)("Expression"),
      kind: {
        validate: (0, e.assertOneOf)("get", "set")
      }
    })
  }), i("TSMethodSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
    fields: Object.assign({}, a(), l(), {
      kind: {
        validate: (0, e.assertOneOf)("method", "get", "set")
      }
    })
  }), i("TSIndexSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["parameters", "typeAnnotation"],
    fields: {
      readonly: (0, e.validateOptional)(s),
      static: (0, e.validateOptional)(s),
      parameters: (0, e.validateArrayOfType)("Identifier"),
      typeAnnotation: (0, e.validateOptionalType)("TSTypeAnnotation")
    }
  });
  const u = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
  for (const y of u)
    i(y, {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {}
    });
  i("TSThisType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: [],
    fields: {}
  });
  const c = {
    aliases: ["TSType"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"]
  };
  i("TSFunctionType", Object.assign({}, c, {
    fields: a()
  })), i("TSConstructorType", Object.assign({}, c, {
    fields: Object.assign({}, a(), {
      abstract: (0, e.validateOptional)(s)
    })
  })), i("TSTypeReference", {
    aliases: ["TSType"],
    visitor: ["typeName", "typeParameters"],
    fields: {
      typeName: (0, e.validateType)("TSEntityName"),
      typeParameters: (0, e.validateOptionalType)("TSTypeParameterInstantiation")
    }
  }), i("TSTypePredicate", {
    aliases: ["TSType"],
    visitor: ["parameterName", "typeAnnotation"],
    builder: ["parameterName", "typeAnnotation", "asserts"],
    fields: {
      parameterName: (0, e.validateType)(["Identifier", "TSThisType"]),
      typeAnnotation: (0, e.validateOptionalType)("TSTypeAnnotation"),
      asserts: (0, e.validateOptional)(s)
    }
  }), i("TSTypeQuery", {
    aliases: ["TSType"],
    visitor: ["exprName", "typeParameters"],
    fields: {
      exprName: (0, e.validateType)(["TSEntityName", "TSImportType"]),
      typeParameters: (0, e.validateOptionalType)("TSTypeParameterInstantiation")
    }
  }), i("TSTypeLiteral", {
    aliases: ["TSType"],
    visitor: ["members"],
    fields: {
      members: (0, e.validateArrayOfType)("TSTypeElement")
    }
  }), i("TSArrayType", {
    aliases: ["TSType"],
    visitor: ["elementType"],
    fields: {
      elementType: (0, e.validateType)("TSType")
    }
  }), i("TSTupleType", {
    aliases: ["TSType"],
    visitor: ["elementTypes"],
    fields: {
      elementTypes: (0, e.validateArrayOfType)(["TSType", "TSNamedTupleMember"])
    }
  }), i("TSOptionalType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, e.validateType)("TSType")
    }
  }), i("TSRestType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, e.validateType)("TSType")
    }
  }), i("TSNamedTupleMember", {
    visitor: ["label", "elementType"],
    builder: ["label", "elementType", "optional"],
    fields: {
      label: (0, e.validateType)("Identifier"),
      optional: {
        validate: s,
        default: !1
      },
      elementType: (0, e.validateType)("TSType")
    }
  });
  const p = {
    aliases: ["TSType"],
    visitor: ["types"],
    fields: {
      types: (0, e.validateArrayOfType)("TSType")
    }
  };
  i("TSUnionType", p), i("TSIntersectionType", p), i("TSConditionalType", {
    aliases: ["TSType"],
    visitor: ["checkType", "extendsType", "trueType", "falseType"],
    fields: {
      checkType: (0, e.validateType)("TSType"),
      extendsType: (0, e.validateType)("TSType"),
      trueType: (0, e.validateType)("TSType"),
      falseType: (0, e.validateType)("TSType")
    }
  }), i("TSInferType", {
    aliases: ["TSType"],
    visitor: ["typeParameter"],
    fields: {
      typeParameter: (0, e.validateType)("TSTypeParameter")
    }
  }), i("TSParenthesizedType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, e.validateType)("TSType")
    }
  }), i("TSTypeOperator", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      operator: (0, e.validate)((0, e.assertValueType)("string")),
      typeAnnotation: (0, e.validateType)("TSType")
    }
  }), i("TSIndexedAccessType", {
    aliases: ["TSType"],
    visitor: ["objectType", "indexType"],
    fields: {
      objectType: (0, e.validateType)("TSType"),
      indexType: (0, e.validateType)("TSType")
    }
  }), i("TSMappedType", {
    aliases: ["TSType"],
    visitor: ["typeParameter", "typeAnnotation", "nameType"],
    fields: {
      readonly: (0, e.validateOptional)((0, e.assertOneOf)(!0, !1, "+", "-")),
      typeParameter: (0, e.validateType)("TSTypeParameter"),
      optional: (0, e.validateOptional)((0, e.assertOneOf)(!0, !1, "+", "-")),
      typeAnnotation: (0, e.validateOptionalType)("TSType"),
      nameType: (0, e.validateOptionalType)("TSType")
    }
  }), i("TSLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["literal"],
    fields: {
      literal: {
        validate: function() {
          const y = (0, e.assertNodeType)("NumericLiteral", "BigIntLiteral"), P = (0, e.assertOneOf)("-"), v = (0, e.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
          function w(x, O, _) {
            (0, r.default)("UnaryExpression", _) ? (P(_, "operator", _.operator), y(_, "argument", _.argument)) : v(x, O, _);
          }
          return w.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral", "UnaryExpression"], w;
        }()
      }
    }
  }), i("TSExpressionWithTypeArguments", {
    aliases: ["TSType"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, e.validateType)("TSEntityName"),
      typeParameters: (0, e.validateOptionalType)("TSTypeParameterInstantiation")
    }
  }), i("TSInterfaceDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "extends", "body"],
    fields: {
      declare: (0, e.validateOptional)(s),
      id: (0, e.validateType)("Identifier"),
      typeParameters: (0, e.validateOptionalType)("TSTypeParameterDeclaration"),
      extends: (0, e.validateOptional)((0, e.arrayOfType)("TSExpressionWithTypeArguments")),
      body: (0, e.validateType)("TSInterfaceBody")
    }
  }), i("TSInterfaceBody", {
    visitor: ["body"],
    fields: {
      body: (0, e.validateArrayOfType)("TSTypeElement")
    }
  }), i("TSTypeAliasDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "typeAnnotation"],
    fields: {
      declare: (0, e.validateOptional)(s),
      id: (0, e.validateType)("Identifier"),
      typeParameters: (0, e.validateOptionalType)("TSTypeParameterDeclaration"),
      typeAnnotation: (0, e.validateType)("TSType")
    }
  }), i("TSInstantiationExpression", {
    aliases: ["Expression"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, e.validateType)("Expression"),
      typeParameters: (0, e.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  const h = {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression", "typeAnnotation"],
    fields: {
      expression: (0, e.validateType)("Expression"),
      typeAnnotation: (0, e.validateType)("TSType")
    }
  };
  return i("TSAsExpression", h), i("TSSatisfiesExpression", h), i("TSTypeAssertion", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["typeAnnotation", "expression"],
    fields: {
      typeAnnotation: (0, e.validateType)("TSType"),
      expression: (0, e.validateType)("Expression")
    }
  }), i("TSEnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "members"],
    fields: {
      declare: (0, e.validateOptional)(s),
      const: (0, e.validateOptional)(s),
      id: (0, e.validateType)("Identifier"),
      members: (0, e.validateArrayOfType)("TSEnumMember"),
      initializer: (0, e.validateOptionalType)("Expression")
    }
  }), i("TSEnumMember", {
    visitor: ["id", "initializer"],
    fields: {
      id: (0, e.validateType)(["Identifier", "StringLiteral"]),
      initializer: (0, e.validateOptionalType)("Expression")
    }
  }), i("TSModuleDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      declare: (0, e.validateOptional)(s),
      global: (0, e.validateOptional)(s),
      id: (0, e.validateType)(["Identifier", "StringLiteral"]),
      body: (0, e.validateType)(["TSModuleBlock", "TSModuleDeclaration"])
    }
  }), i("TSModuleBlock", {
    aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],
    visitor: ["body"],
    fields: {
      body: (0, e.validateArrayOfType)("Statement")
    }
  }), i("TSImportType", {
    aliases: ["TSType"],
    visitor: ["argument", "qualifier", "typeParameters"],
    fields: {
      argument: (0, e.validateType)("StringLiteral"),
      qualifier: (0, e.validateOptionalType)("TSEntityName"),
      typeParameters: (0, e.validateOptionalType)("TSTypeParameterInstantiation")
    }
  }), i("TSImportEqualsDeclaration", {
    aliases: ["Statement"],
    visitor: ["id", "moduleReference"],
    fields: {
      isExport: (0, e.validate)(s),
      id: (0, e.validateType)("Identifier"),
      moduleReference: (0, e.validateType)(["TSEntityName", "TSExternalModuleReference"]),
      importKind: {
        validate: (0, e.assertOneOf)("type", "value"),
        optional: !0
      }
    }
  }), i("TSExternalModuleReference", {
    visitor: ["expression"],
    fields: {
      expression: (0, e.validateType)("StringLiteral")
    }
  }), i("TSNonNullExpression", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression"],
    fields: {
      expression: (0, e.validateType)("Expression")
    }
  }), i("TSExportAssignment", {
    aliases: ["Statement"],
    visitor: ["expression"],
    fields: {
      expression: (0, e.validateType)("Expression")
    }
  }), i("TSNamespaceExportDeclaration", {
    aliases: ["Statement"],
    visitor: ["id"],
    fields: {
      id: (0, e.validateType)("Identifier")
    }
  }), i("TSTypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: {
        validate: (0, e.assertNodeType)("TSType")
      }
    }
  }), i("TSTypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: {
        validate: (0, e.chain)((0, e.assertValueType)("array"), (0, e.assertEach)((0, e.assertNodeType)("TSType")))
      }
    }
  }), i("TSTypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: {
        validate: (0, e.chain)((0, e.assertValueType)("array"), (0, e.assertEach)((0, e.assertNodeType)("TSTypeParameter")))
      }
    }
  }), i("TSTypeParameter", {
    builder: ["constraint", "default", "name"],
    visitor: ["constraint", "default"],
    fields: {
      name: {
        validate: (0, e.assertValueType)("string")
      },
      in: {
        validate: (0, e.assertValueType)("boolean"),
        optional: !0
      },
      out: {
        validate: (0, e.assertValueType)("boolean"),
        optional: !0
      },
      const: {
        validate: (0, e.assertValueType)("boolean"),
        optional: !0
      },
      constraint: {
        validate: (0, e.assertNodeType)("TSType"),
        optional: !0
      },
      default: {
        validate: (0, e.assertNodeType)("TSType"),
        optional: !0
      }
    }
  }), Qo;
}
var vs = {};
Object.defineProperty(vs, "__esModule", {
  value: !0
});
vs.DEPRECATED_ALIASES = void 0;
const hx = {
  ModuleDeclaration: "ImportOrExportDeclaration"
};
vs.DEPRECATED_ALIASES = hx;
var el;
function Et() {
  return el || (el = 1, function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "ALIAS_KEYS", {
      enumerable: !0,
      get: function() {
        return r.ALIAS_KEYS;
      }
    }), Object.defineProperty(e, "BUILDER_KEYS", {
      enumerable: !0,
      get: function() {
        return r.BUILDER_KEYS;
      }
    }), Object.defineProperty(e, "DEPRECATED_ALIASES", {
      enumerable: !0,
      get: function() {
        return s.DEPRECATED_ALIASES;
      }
    }), Object.defineProperty(e, "DEPRECATED_KEYS", {
      enumerable: !0,
      get: function() {
        return r.DEPRECATED_KEYS;
      }
    }), Object.defineProperty(e, "FLIPPED_ALIAS_KEYS", {
      enumerable: !0,
      get: function() {
        return r.FLIPPED_ALIAS_KEYS;
      }
    }), Object.defineProperty(e, "NODE_FIELDS", {
      enumerable: !0,
      get: function() {
        return r.NODE_FIELDS;
      }
    }), Object.defineProperty(e, "NODE_PARENT_VALIDATIONS", {
      enumerable: !0,
      get: function() {
        return r.NODE_PARENT_VALIDATIONS;
      }
    }), Object.defineProperty(e, "PLACEHOLDERS", {
      enumerable: !0,
      get: function() {
        return i.PLACEHOLDERS;
      }
    }), Object.defineProperty(e, "PLACEHOLDERS_ALIAS", {
      enumerable: !0,
      get: function() {
        return i.PLACEHOLDERS_ALIAS;
      }
    }), Object.defineProperty(e, "PLACEHOLDERS_FLIPPED_ALIAS", {
      enumerable: !0,
      get: function() {
        return i.PLACEHOLDERS_FLIPPED_ALIAS;
      }
    }), e.TYPES = void 0, Object.defineProperty(e, "VISITOR_KEYS", {
      enumerable: !0,
      get: function() {
        return r.VISITOR_KEYS;
      }
    });
    var t = BP;
    Dc(), lx(), ux(), cx(), fx(), px();
    var r = Qt(), i = kc(), s = vs;
    Object.keys(s.DEPRECATED_ALIASES).forEach((a) => {
      r.FLIPPED_ALIAS_KEYS[a] = r.FLIPPED_ALIAS_KEYS[s.DEPRECATED_ALIASES[a]];
    }), t(r.VISITOR_KEYS), t(r.ALIAS_KEYS), t(r.FLIPPED_ALIAS_KEYS), t(r.NODE_FIELDS), t(r.BUILDER_KEYS), t(r.DEPRECATED_KEYS), t(i.PLACEHOLDERS_ALIAS), t(i.PLACEHOLDERS_FLIPPED_ALIAS);
    const n = [].concat(Object.keys(r.VISITOR_KEYS), Object.keys(r.FLIPPED_ALIAS_KEYS), Object.keys(r.DEPRECATED_KEYS));
    e.TYPES = n;
  }(dn)), dn;
}
var tl;
function Pa() {
  if (tl)
    return Er;
  tl = 1, Object.defineProperty(Er, "__esModule", {
    value: !0
  }), Er.default = t, Er.validateChild = i, Er.validateField = r;
  var e = Et();
  function t(s, n, a) {
    if (!s)
      return;
    const o = e.NODE_FIELDS[s.type];
    if (!o)
      return;
    const l = o[n];
    r(s, n, a, l), i(s, n, a);
  }
  function r(s, n, a, o) {
    o != null && o.validate && (o.optional && a == null || o.validate(s, n, a));
  }
  function i(s, n, a) {
    if (a == null)
      return;
    const o = e.NODE_PARENT_VALIDATIONS[a.type];
    o && o(s, n, a);
  }
  return Er;
}
var rl;
function dx() {
  if (rl)
    return Di;
  rl = 1, Object.defineProperty(Di, "__esModule", {
    value: !0
  }), Di.default = r;
  var e = Pa(), t = Ae();
  function r(i) {
    const s = t.BUILDER_KEYS[i.type];
    for (const n of s)
      (0, e.default)(i, n, i[n]);
    return i;
  }
  return Di;
}
var il;
function ht() {
  if (il)
    return d;
  il = 1, Object.defineProperty(d, "__esModule", {
    value: !0
  }), d.anyTypeAnnotation = Ap, d.argumentPlaceholder = ed, d.arrayExpression = r, d.arrayPattern = ve, d.arrayTypeAnnotation = Cp, d.arrowFunctionExpression = De, d.assignmentExpression = i, d.assignmentPattern = pe, d.awaitExpression = $t, d.bigIntLiteral = mp, d.binaryExpression = s, d.bindExpression = td, d.blockStatement = l, d.booleanLiteral = ce, d.booleanLiteralTypeAnnotation = wp, d.booleanTypeAnnotation = Ip, d.breakStatement = u, d.callExpression = c, d.catchClause = p, d.classAccessorProperty = gp, d.classBody = $, d.classDeclaration = I, d.classExpression = S, d.classImplements = Np, d.classMethod = re, d.classPrivateMethod = Pp, d.classPrivateProperty = Ep, d.classProperty = bp, d.conditionalExpression = h, d.continueStatement = y, d.debuggerStatement = P, d.decimalLiteral = ld, d.declareClass = _p, d.declareExportAllDeclaration = $p, d.declareExportDeclaration = Rp, d.declareFunction = Dp, d.declareInterface = kp, d.declareModule = Lp, d.declareModuleExports = Mp, d.declareOpaqueType = Fp, d.declareTypeAlias = Bp, d.declareVariable = jp, d.declaredPredicate = Up, d.decorator = id, d.directive = a, d.directiveLiteral = o, d.doExpression = sd, d.doWhileStatement = v, d.emptyStatement = w, d.emptyTypeAnnotation = Qp, d.enumBooleanBody = Ch, d.enumBooleanMember = Nh, d.enumDeclaration = Ah, d.enumDefaultedMember = kh, d.enumNumberBody = Ih, d.enumNumberMember = _h, d.enumStringBody = wh, d.enumStringMember = Dh, d.enumSymbolBody = Oh, d.existsTypeAnnotation = Vp, d.exportAllDeclaration = U, d.exportDefaultDeclaration = G, d.exportDefaultSpecifier = nd, d.exportNamedDeclaration = ue, d.exportNamespaceSpecifier = yp, d.exportSpecifier = xe, d.expressionStatement = x, d.file = O, d.forInStatement = _, d.forOfStatement = Ge, d.forStatement = K, d.functionDeclaration = R, d.functionExpression = B, d.functionTypeAnnotation = Kp, d.functionTypeParam = qp, d.genericTypeAnnotation = Wp, d.identifier = C, d.ifStatement = L, d.import = dp, d.importAttribute = rd, d.importDeclaration = et, d.importDefaultSpecifier = ot, d.importNamespaceSpecifier = ct, d.importSpecifier = tt, d.indexedAccessType = Lh, d.inferredPredicate = Yp, d.interfaceDeclaration = Jp, d.interfaceExtends = Xp, d.interfaceTypeAnnotation = Hp, d.interpreterDirective = n, d.intersectionTypeAnnotation = Gp, d.jSXAttribute = d.jsxAttribute = Bh, d.jSXClosingElement = d.jsxClosingElement = Fh, d.jSXClosingFragment = d.jsxClosingFragment = Gh, d.jSXElement = d.jsxElement = jh, d.jSXEmptyExpression = d.jsxEmptyExpression = Rh, d.jSXExpressionContainer = d.jsxExpressionContainer = $h, d.jSXFragment = d.jsxFragment = Jh, d.jSXIdentifier = d.jsxIdentifier = Vh, d.jSXMemberExpression = d.jsxMemberExpression = Kh, d.jSXNamespacedName = d.jsxNamespacedName = qh, d.jSXOpeningElement = d.jsxOpeningElement = Wh, d.jSXOpeningFragment = d.jsxOpeningFragment = Hh, d.jSXSpreadAttribute = d.jsxSpreadAttribute = Yh, d.jSXSpreadChild = d.jsxSpreadChild = Uh, d.jSXText = d.jsxText = Xh, d.labeledStatement = F, d.logicalExpression = k, d.memberExpression = M, d.metaProperty = ft, d.mixedTypeAnnotation = zp, d.moduleExpression = ud, d.newExpression = D, d.noop = zh, d.nullLiteral = J, d.nullLiteralTypeAnnotation = Op, d.nullableTypeAnnotation = Zp, d.numberLiteral = Am, d.numberLiteralTypeAnnotation = eh, d.numberTypeAnnotation = th, d.numericLiteral = Z, d.objectExpression = X, d.objectMethod = W, d.objectPattern = gr, d.objectProperty = ae, d.objectTypeAnnotation = rh, d.objectTypeCallProperty = sh, d.objectTypeIndexer = nh, d.objectTypeInternalSlot = ih, d.objectTypeProperty = ah, d.objectTypeSpreadProperty = oh, d.opaqueType = lh, d.optionalCallExpression = Sp, d.optionalIndexedAccessType = Mh, d.optionalMemberExpression = Tp, d.parenthesizedExpression = je, d.pipelineBareFunction = pd, d.pipelinePrimaryTopicReference = hd, d.pipelineTopicExpression = fd, d.placeholder = Qh, d.privateName = xp, d.program = j, d.qualifiedTypeIdentifier = uh, d.recordExpression = ad, d.regExpLiteral = me, d.regexLiteral = Cm, d.restElement = ie, d.restProperty = Im, d.returnStatement = ge, d.sequenceExpression = Ce, d.spreadElement = er, d.spreadProperty = wm, d.staticBlock = vp, d.stringLiteral = te, d.stringLiteralTypeAnnotation = ch, d.stringTypeAnnotation = fh, d.super = rn, d.switchCase = Je, d.switchStatement = He, d.symbolTypeAnnotation = ph, d.taggedTemplateExpression = sn, d.templateElement = E, d.templateLiteral = be, d.thisExpression = We, d.thisTypeAnnotation = hh, d.throwStatement = Y, d.topicReference = cd, d.tryStatement = V, d.tSAnyKeyword = d.tsAnyKeyword = xd, d.tSArrayType = d.tsArrayType = Kd, d.tSAsExpression = d.tsAsExpression = lm, d.tSBigIntKeyword = d.tsBigIntKeyword = Ad, d.tSBooleanKeyword = d.tsBooleanKeyword = vd, d.tSCallSignatureDeclaration = d.tsCallSignatureDeclaration = Sd, d.tSConditionalType = d.tsConditionalType = Gd, d.tSConstructSignatureDeclaration = d.tsConstructSignatureDeclaration = bd, d.tSConstructorType = d.tsConstructorType = jd, d.tSDeclareFunction = d.tsDeclareFunction = md, d.tSDeclareMethod = d.tsDeclareMethod = yd, d.tSEnumDeclaration = d.tsEnumDeclaration = fm, d.tSEnumMember = d.tsEnumMember = pm, d.tSExportAssignment = d.tsExportAssignment = bm, d.tSExpressionWithTypeArguments = d.tsExpressionWithTypeArguments = im, d.tSExternalModuleReference = d.tsExternalModuleReference = Tm, d.tSFunctionType = d.tsFunctionType = Fd, d.tSImportEqualsDeclaration = d.tsImportEqualsDeclaration = ym, d.tSImportType = d.tsImportType = mm, d.tSIndexSignature = d.tsIndexSignature = Pd, d.tSIndexedAccessType = d.tsIndexedAccessType = em, d.tSInferType = d.tsInferType = zd, d.tSInstantiationExpression = d.tsInstantiationExpression = om, d.tSInterfaceBody = d.tsInterfaceBody = nm, d.tSInterfaceDeclaration = d.tsInterfaceDeclaration = sm, d.tSIntersectionType = d.tsIntersectionType = Hd, d.tSIntrinsicKeyword = d.tsIntrinsicKeyword = Cd, d.tSLiteralType = d.tsLiteralType = rm, d.tSMappedType = d.tsMappedType = tm, d.tSMethodSignature = d.tsMethodSignature = Ed, d.tSModuleBlock = d.tsModuleBlock = dm, d.tSModuleDeclaration = d.tsModuleDeclaration = hm, d.tSNamedTupleMember = d.tsNamedTupleMember = Xd, d.tSNamespaceExportDeclaration = d.tsNamespaceExportDeclaration = gm, d.tSNeverKeyword = d.tsNeverKeyword = Id, d.tSNonNullExpression = d.tsNonNullExpression = Sm, d.tSNullKeyword = d.tsNullKeyword = wd, d.tSNumberKeyword = d.tsNumberKeyword = Od, d.tSObjectKeyword = d.tsObjectKeyword = Nd, d.tSOptionalType = d.tsOptionalType = Wd, d.tSParameterProperty = d.tsParameterProperty = dd, d.tSParenthesizedType = d.tsParenthesizedType = Qd, d.tSPropertySignature = d.tsPropertySignature = gd, d.tSQualifiedName = d.tsQualifiedName = Td, d.tSRestType = d.tsRestType = Yd, d.tSSatisfiesExpression = d.tsSatisfiesExpression = um, d.tSStringKeyword = d.tsStringKeyword = _d, d.tSSymbolKeyword = d.tsSymbolKeyword = Dd, d.tSThisType = d.tsThisType = Bd, d.tSTupleType = d.tsTupleType = qd, d.tSTypeAliasDeclaration = d.tsTypeAliasDeclaration = am, d.tSTypeAnnotation = d.tsTypeAnnotation = Em, d.tSTypeAssertion = d.tsTypeAssertion = cm, d.tSTypeLiteral = d.tsTypeLiteral = Vd, d.tSTypeOperator = d.tsTypeOperator = Zd, d.tSTypeParameter = d.tsTypeParameter = vm, d.tSTypeParameterDeclaration = d.tsTypeParameterDeclaration = xm, d.tSTypeParameterInstantiation = d.tsTypeParameterInstantiation = Pm, d.tSTypePredicate = d.tsTypePredicate = $d, d.tSTypeQuery = d.tsTypeQuery = Ud, d.tSTypeReference = d.tsTypeReference = Rd, d.tSUndefinedKeyword = d.tsUndefinedKeyword = kd, d.tSUnionType = d.tsUnionType = Jd, d.tSUnknownKeyword = d.tsUnknownKeyword = Ld, d.tSVoidKeyword = d.tsVoidKeyword = Md, d.tupleExpression = od, d.tupleTypeAnnotation = dh, d.typeAlias = yh, d.typeAnnotation = Th, d.typeCastExpression = Sh, d.typeParameter = bh, d.typeParameterDeclaration = gh, d.typeParameterInstantiation = Eh, d.typeofTypeAnnotation = mh, d.unaryExpression = z, d.unionTypeAnnotation = Ph, d.updateExpression = ee, d.v8IntrinsicIdentifier = Zh, d.variableDeclaration = Se, d.variableDeclarator = oe, d.variance = xh, d.voidTypeAnnotation = vh, d.whileStatement = ye, d.withStatement = Q, d.yieldExpression = $e;
  var e = dx(), t = Mr;
  function r(f = []) {
    return (0, e.default)({
      type: "ArrayExpression",
      elements: f
    });
  }
  function i(f, A, q) {
    return (0, e.default)({
      type: "AssignmentExpression",
      operator: f,
      left: A,
      right: q
    });
  }
  function s(f, A, q) {
    return (0, e.default)({
      type: "BinaryExpression",
      operator: f,
      left: A,
      right: q
    });
  }
  function n(f) {
    return (0, e.default)({
      type: "InterpreterDirective",
      value: f
    });
  }
  function a(f) {
    return (0, e.default)({
      type: "Directive",
      value: f
    });
  }
  function o(f) {
    return (0, e.default)({
      type: "DirectiveLiteral",
      value: f
    });
  }
  function l(f, A = []) {
    return (0, e.default)({
      type: "BlockStatement",
      body: f,
      directives: A
    });
  }
  function u(f = null) {
    return (0, e.default)({
      type: "BreakStatement",
      label: f
    });
  }
  function c(f, A) {
    return (0, e.default)({
      type: "CallExpression",
      callee: f,
      arguments: A
    });
  }
  function p(f = null, A) {
    return (0, e.default)({
      type: "CatchClause",
      param: f,
      body: A
    });
  }
  function h(f, A, q) {
    return (0, e.default)({
      type: "ConditionalExpression",
      test: f,
      consequent: A,
      alternate: q
    });
  }
  function y(f = null) {
    return (0, e.default)({
      type: "ContinueStatement",
      label: f
    });
  }
  function P() {
    return {
      type: "DebuggerStatement"
    };
  }
  function v(f, A) {
    return (0, e.default)({
      type: "DoWhileStatement",
      test: f,
      body: A
    });
  }
  function w() {
    return {
      type: "EmptyStatement"
    };
  }
  function x(f) {
    return (0, e.default)({
      type: "ExpressionStatement",
      expression: f
    });
  }
  function O(f, A = null, q = null) {
    return (0, e.default)({
      type: "File",
      program: f,
      comments: A,
      tokens: q
    });
  }
  function _(f, A, q) {
    return (0, e.default)({
      type: "ForInStatement",
      left: f,
      right: A,
      body: q
    });
  }
  function K(f = null, A = null, q = null, he) {
    return (0, e.default)({
      type: "ForStatement",
      init: f,
      test: A,
      update: q,
      body: he
    });
  }
  function R(f = null, A, q, he = !1, qe = !1) {
    return (0, e.default)({
      type: "FunctionDeclaration",
      id: f,
      params: A,
      body: q,
      generator: he,
      async: qe
    });
  }
  function B(f = null, A, q, he = !1, qe = !1) {
    return (0, e.default)({
      type: "FunctionExpression",
      id: f,
      params: A,
      body: q,
      generator: he,
      async: qe
    });
  }
  function C(f) {
    return (0, e.default)({
      type: "Identifier",
      name: f
    });
  }
  function L(f, A, q = null) {
    return (0, e.default)({
      type: "IfStatement",
      test: f,
      consequent: A,
      alternate: q
    });
  }
  function F(f, A) {
    return (0, e.default)({
      type: "LabeledStatement",
      label: f,
      body: A
    });
  }
  function te(f) {
    return (0, e.default)({
      type: "StringLiteral",
      value: f
    });
  }
  function Z(f) {
    return (0, e.default)({
      type: "NumericLiteral",
      value: f
    });
  }
  function J() {
    return {
      type: "NullLiteral"
    };
  }
  function ce(f) {
    return (0, e.default)({
      type: "BooleanLiteral",
      value: f
    });
  }
  function me(f, A = "") {
    return (0, e.default)({
      type: "RegExpLiteral",
      pattern: f,
      flags: A
    });
  }
  function k(f, A, q) {
    return (0, e.default)({
      type: "LogicalExpression",
      operator: f,
      left: A,
      right: q
    });
  }
  function M(f, A, q = !1, he = null) {
    return (0, e.default)({
      type: "MemberExpression",
      object: f,
      property: A,
      computed: q,
      optional: he
    });
  }
  function D(f, A) {
    return (0, e.default)({
      type: "NewExpression",
      callee: f,
      arguments: A
    });
  }
  function j(f, A = [], q = "script", he = null) {
    return (0, e.default)({
      type: "Program",
      body: f,
      directives: A,
      sourceType: q,
      interpreter: he,
      sourceFile: null
    });
  }
  function X(f) {
    return (0, e.default)({
      type: "ObjectExpression",
      properties: f
    });
  }
  function W(f = "method", A, q, he, qe = !1, tr = !1, nn = !1) {
    return (0, e.default)({
      type: "ObjectMethod",
      kind: f,
      key: A,
      params: q,
      body: he,
      computed: qe,
      generator: tr,
      async: nn
    });
  }
  function ae(f, A, q = !1, he = !1, qe = null) {
    return (0, e.default)({
      type: "ObjectProperty",
      key: f,
      value: A,
      computed: q,
      shorthand: he,
      decorators: qe
    });
  }
  function ie(f) {
    return (0, e.default)({
      type: "RestElement",
      argument: f
    });
  }
  function ge(f = null) {
    return (0, e.default)({
      type: "ReturnStatement",
      argument: f
    });
  }
  function Ce(f) {
    return (0, e.default)({
      type: "SequenceExpression",
      expressions: f
    });
  }
  function je(f) {
    return (0, e.default)({
      type: "ParenthesizedExpression",
      expression: f
    });
  }
  function Je(f = null, A) {
    return (0, e.default)({
      type: "SwitchCase",
      test: f,
      consequent: A
    });
  }
  function He(f, A) {
    return (0, e.default)({
      type: "SwitchStatement",
      discriminant: f,
      cases: A
    });
  }
  function We() {
    return {
      type: "ThisExpression"
    };
  }
  function Y(f) {
    return (0, e.default)({
      type: "ThrowStatement",
      argument: f
    });
  }
  function V(f, A = null, q = null) {
    return (0, e.default)({
      type: "TryStatement",
      block: f,
      handler: A,
      finalizer: q
    });
  }
  function z(f, A, q = !0) {
    return (0, e.default)({
      type: "UnaryExpression",
      operator: f,
      argument: A,
      prefix: q
    });
  }
  function ee(f, A, q = !1) {
    return (0, e.default)({
      type: "UpdateExpression",
      operator: f,
      argument: A,
      prefix: q
    });
  }
  function Se(f, A) {
    return (0, e.default)({
      type: "VariableDeclaration",
      kind: f,
      declarations: A
    });
  }
  function oe(f, A = null) {
    return (0, e.default)({
      type: "VariableDeclarator",
      id: f,
      init: A
    });
  }
  function ye(f, A) {
    return (0, e.default)({
      type: "WhileStatement",
      test: f,
      body: A
    });
  }
  function Q(f, A) {
    return (0, e.default)({
      type: "WithStatement",
      object: f,
      body: A
    });
  }
  function pe(f, A) {
    return (0, e.default)({
      type: "AssignmentPattern",
      left: f,
      right: A
    });
  }
  function ve(f) {
    return (0, e.default)({
      type: "ArrayPattern",
      elements: f
    });
  }
  function De(f, A, q = !1) {
    return (0, e.default)({
      type: "ArrowFunctionExpression",
      params: f,
      body: A,
      async: q,
      expression: null
    });
  }
  function $(f) {
    return (0, e.default)({
      type: "ClassBody",
      body: f
    });
  }
  function S(f = null, A = null, q, he = null) {
    return (0, e.default)({
      type: "ClassExpression",
      id: f,
      superClass: A,
      body: q,
      decorators: he
    });
  }
  function I(f, A = null, q, he = null) {
    return (0, e.default)({
      type: "ClassDeclaration",
      id: f,
      superClass: A,
      body: q,
      decorators: he
    });
  }
  function U(f) {
    return (0, e.default)({
      type: "ExportAllDeclaration",
      source: f
    });
  }
  function G(f) {
    return (0, e.default)({
      type: "ExportDefaultDeclaration",
      declaration: f
    });
  }
  function ue(f = null, A = [], q = null) {
    return (0, e.default)({
      type: "ExportNamedDeclaration",
      declaration: f,
      specifiers: A,
      source: q
    });
  }
  function xe(f, A) {
    return (0, e.default)({
      type: "ExportSpecifier",
      local: f,
      exported: A
    });
  }
  function Ge(f, A, q, he = !1) {
    return (0, e.default)({
      type: "ForOfStatement",
      left: f,
      right: A,
      body: q,
      await: he
    });
  }
  function et(f, A) {
    return (0, e.default)({
      type: "ImportDeclaration",
      specifiers: f,
      source: A
    });
  }
  function ot(f) {
    return (0, e.default)({
      type: "ImportDefaultSpecifier",
      local: f
    });
  }
  function ct(f) {
    return (0, e.default)({
      type: "ImportNamespaceSpecifier",
      local: f
    });
  }
  function tt(f, A) {
    return (0, e.default)({
      type: "ImportSpecifier",
      local: f,
      imported: A
    });
  }
  function ft(f, A) {
    return (0, e.default)({
      type: "MetaProperty",
      meta: f,
      property: A
    });
  }
  function re(f = "method", A, q, he, qe = !1, tr = !1, nn = !1, Om = !1) {
    return (0, e.default)({
      type: "ClassMethod",
      kind: f,
      key: A,
      params: q,
      body: he,
      computed: qe,
      static: tr,
      generator: nn,
      async: Om
    });
  }
  function gr(f) {
    return (0, e.default)({
      type: "ObjectPattern",
      properties: f
    });
  }
  function er(f) {
    return (0, e.default)({
      type: "SpreadElement",
      argument: f
    });
  }
  function rn() {
    return {
      type: "Super"
    };
  }
  function sn(f, A) {
    return (0, e.default)({
      type: "TaggedTemplateExpression",
      tag: f,
      quasi: A
    });
  }
  function E(f, A = !1) {
    return (0, e.default)({
      type: "TemplateElement",
      value: f,
      tail: A
    });
  }
  function be(f, A) {
    return (0, e.default)({
      type: "TemplateLiteral",
      quasis: f,
      expressions: A
    });
  }
  function $e(f = null, A = !1) {
    return (0, e.default)({
      type: "YieldExpression",
      argument: f,
      delegate: A
    });
  }
  function $t(f) {
    return (0, e.default)({
      type: "AwaitExpression",
      argument: f
    });
  }
  function dp() {
    return {
      type: "Import"
    };
  }
  function mp(f) {
    return (0, e.default)({
      type: "BigIntLiteral",
      value: f
    });
  }
  function yp(f) {
    return (0, e.default)({
      type: "ExportNamespaceSpecifier",
      exported: f
    });
  }
  function Tp(f, A, q = !1, he) {
    return (0, e.default)({
      type: "OptionalMemberExpression",
      object: f,
      property: A,
      computed: q,
      optional: he
    });
  }
  function Sp(f, A, q) {
    return (0, e.default)({
      type: "OptionalCallExpression",
      callee: f,
      arguments: A,
      optional: q
    });
  }
  function bp(f, A = null, q = null, he = null, qe = !1, tr = !1) {
    return (0, e.default)({
      type: "ClassProperty",
      key: f,
      value: A,
      typeAnnotation: q,
      decorators: he,
      computed: qe,
      static: tr
    });
  }
  function gp(f, A = null, q = null, he = null, qe = !1, tr = !1) {
    return (0, e.default)({
      type: "ClassAccessorProperty",
      key: f,
      value: A,
      typeAnnotation: q,
      decorators: he,
      computed: qe,
      static: tr
    });
  }
  function Ep(f, A = null, q = null, he = !1) {
    return (0, e.default)({
      type: "ClassPrivateProperty",
      key: f,
      value: A,
      decorators: q,
      static: he
    });
  }
  function Pp(f = "method", A, q, he, qe = !1) {
    return (0, e.default)({
      type: "ClassPrivateMethod",
      kind: f,
      key: A,
      params: q,
      body: he,
      static: qe
    });
  }
  function xp(f) {
    return (0, e.default)({
      type: "PrivateName",
      id: f
    });
  }
  function vp(f) {
    return (0, e.default)({
      type: "StaticBlock",
      body: f
    });
  }
  function Ap() {
    return {
      type: "AnyTypeAnnotation"
    };
  }
  function Cp(f) {
    return (0, e.default)({
      type: "ArrayTypeAnnotation",
      elementType: f
    });
  }
  function Ip() {
    return {
      type: "BooleanTypeAnnotation"
    };
  }
  function wp(f) {
    return (0, e.default)({
      type: "BooleanLiteralTypeAnnotation",
      value: f
    });
  }
  function Op() {
    return {
      type: "NullLiteralTypeAnnotation"
    };
  }
  function Np(f, A = null) {
    return (0, e.default)({
      type: "ClassImplements",
      id: f,
      typeParameters: A
    });
  }
  function _p(f, A = null, q = null, he) {
    return (0, e.default)({
      type: "DeclareClass",
      id: f,
      typeParameters: A,
      extends: q,
      body: he
    });
  }
  function Dp(f) {
    return (0, e.default)({
      type: "DeclareFunction",
      id: f
    });
  }
  function kp(f, A = null, q = null, he) {
    return (0, e.default)({
      type: "DeclareInterface",
      id: f,
      typeParameters: A,
      extends: q,
      body: he
    });
  }
  function Lp(f, A, q = null) {
    return (0, e.default)({
      type: "DeclareModule",
      id: f,
      body: A,
      kind: q
    });
  }
  function Mp(f) {
    return (0, e.default)({
      type: "DeclareModuleExports",
      typeAnnotation: f
    });
  }
  function Bp(f, A = null, q) {
    return (0, e.default)({
      type: "DeclareTypeAlias",
      id: f,
      typeParameters: A,
      right: q
    });
  }
  function Fp(f, A = null, q = null) {
    return (0, e.default)({
      type: "DeclareOpaqueType",
      id: f,
      typeParameters: A,
      supertype: q
    });
  }
  function jp(f) {
    return (0, e.default)({
      type: "DeclareVariable",
      id: f
    });
  }
  function Rp(f = null, A = null, q = null) {
    return (0, e.default)({
      type: "DeclareExportDeclaration",
      declaration: f,
      specifiers: A,
      source: q
    });
  }
  function $p(f) {
    return (0, e.default)({
      type: "DeclareExportAllDeclaration",
      source: f
    });
  }
  function Up(f) {
    return (0, e.default)({
      type: "DeclaredPredicate",
      value: f
    });
  }
  function Vp() {
    return {
      type: "ExistsTypeAnnotation"
    };
  }
  function Kp(f = null, A, q = null, he) {
    return (0, e.default)({
      type: "FunctionTypeAnnotation",
      typeParameters: f,
      params: A,
      rest: q,
      returnType: he
    });
  }
  function qp(f = null, A) {
    return (0, e.default)({
      type: "FunctionTypeParam",
      name: f,
      typeAnnotation: A
    });
  }
  function Wp(f, A = null) {
    return (0, e.default)({
      type: "GenericTypeAnnotation",
      id: f,
      typeParameters: A
    });
  }
  function Yp() {
    return {
      type: "InferredPredicate"
    };
  }
  function Xp(f, A = null) {
    return (0, e.default)({
      type: "InterfaceExtends",
      id: f,
      typeParameters: A
    });
  }
  function Jp(f, A = null, q = null, he) {
    return (0, e.default)({
      type: "InterfaceDeclaration",
      id: f,
      typeParameters: A,
      extends: q,
      body: he
    });
  }
  function Hp(f = null, A) {
    return (0, e.default)({
      type: "InterfaceTypeAnnotation",
      extends: f,
      body: A
    });
  }
  function Gp(f) {
    return (0, e.default)({
      type: "IntersectionTypeAnnotation",
      types: f
    });
  }
  function zp() {
    return {
      type: "MixedTypeAnnotation"
    };
  }
  function Qp() {
    return {
      type: "EmptyTypeAnnotation"
    };
  }
  function Zp(f) {
    return (0, e.default)({
      type: "NullableTypeAnnotation",
      typeAnnotation: f
    });
  }
  function eh(f) {
    return (0, e.default)({
      type: "NumberLiteralTypeAnnotation",
      value: f
    });
  }
  function th() {
    return {
      type: "NumberTypeAnnotation"
    };
  }
  function rh(f, A = [], q = [], he = [], qe = !1) {
    return (0, e.default)({
      type: "ObjectTypeAnnotation",
      properties: f,
      indexers: A,
      callProperties: q,
      internalSlots: he,
      exact: qe
    });
  }
  function ih(f, A, q, he, qe) {
    return (0, e.default)({
      type: "ObjectTypeInternalSlot",
      id: f,
      value: A,
      optional: q,
      static: he,
      method: qe
    });
  }
  function sh(f) {
    return (0, e.default)({
      type: "ObjectTypeCallProperty",
      value: f,
      static: null
    });
  }
  function nh(f = null, A, q, he = null) {
    return (0, e.default)({
      type: "ObjectTypeIndexer",
      id: f,
      key: A,
      value: q,
      variance: he,
      static: null
    });
  }
  function ah(f, A, q = null) {
    return (0, e.default)({
      type: "ObjectTypeProperty",
      key: f,
      value: A,
      variance: q,
      kind: null,
      method: null,
      optional: null,
      proto: null,
      static: null
    });
  }
  function oh(f) {
    return (0, e.default)({
      type: "ObjectTypeSpreadProperty",
      argument: f
    });
  }
  function lh(f, A = null, q = null, he) {
    return (0, e.default)({
      type: "OpaqueType",
      id: f,
      typeParameters: A,
      supertype: q,
      impltype: he
    });
  }
  function uh(f, A) {
    return (0, e.default)({
      type: "QualifiedTypeIdentifier",
      id: f,
      qualification: A
    });
  }
  function ch(f) {
    return (0, e.default)({
      type: "StringLiteralTypeAnnotation",
      value: f
    });
  }
  function fh() {
    return {
      type: "StringTypeAnnotation"
    };
  }
  function ph() {
    return {
      type: "SymbolTypeAnnotation"
    };
  }
  function hh() {
    return {
      type: "ThisTypeAnnotation"
    };
  }
  function dh(f) {
    return (0, e.default)({
      type: "TupleTypeAnnotation",
      types: f
    });
  }
  function mh(f) {
    return (0, e.default)({
      type: "TypeofTypeAnnotation",
      argument: f
    });
  }
  function yh(f, A = null, q) {
    return (0, e.default)({
      type: "TypeAlias",
      id: f,
      typeParameters: A,
      right: q
    });
  }
  function Th(f) {
    return (0, e.default)({
      type: "TypeAnnotation",
      typeAnnotation: f
    });
  }
  function Sh(f, A) {
    return (0, e.default)({
      type: "TypeCastExpression",
      expression: f,
      typeAnnotation: A
    });
  }
  function bh(f = null, A = null, q = null) {
    return (0, e.default)({
      type: "TypeParameter",
      bound: f,
      default: A,
      variance: q,
      name: null
    });
  }
  function gh(f) {
    return (0, e.default)({
      type: "TypeParameterDeclaration",
      params: f
    });
  }
  function Eh(f) {
    return (0, e.default)({
      type: "TypeParameterInstantiation",
      params: f
    });
  }
  function Ph(f) {
    return (0, e.default)({
      type: "UnionTypeAnnotation",
      types: f
    });
  }
  function xh(f) {
    return (0, e.default)({
      type: "Variance",
      kind: f
    });
  }
  function vh() {
    return {
      type: "VoidTypeAnnotation"
    };
  }
  function Ah(f, A) {
    return (0, e.default)({
      type: "EnumDeclaration",
      id: f,
      body: A
    });
  }
  function Ch(f) {
    return (0, e.default)({
      type: "EnumBooleanBody",
      members: f,
      explicitType: null,
      hasUnknownMembers: null
    });
  }
  function Ih(f) {
    return (0, e.default)({
      type: "EnumNumberBody",
      members: f,
      explicitType: null,
      hasUnknownMembers: null
    });
  }
  function wh(f) {
    return (0, e.default)({
      type: "EnumStringBody",
      members: f,
      explicitType: null,
      hasUnknownMembers: null
    });
  }
  function Oh(f) {
    return (0, e.default)({
      type: "EnumSymbolBody",
      members: f,
      hasUnknownMembers: null
    });
  }
  function Nh(f) {
    return (0, e.default)({
      type: "EnumBooleanMember",
      id: f,
      init: null
    });
  }
  function _h(f, A) {
    return (0, e.default)({
      type: "EnumNumberMember",
      id: f,
      init: A
    });
  }
  function Dh(f, A) {
    return (0, e.default)({
      type: "EnumStringMember",
      id: f,
      init: A
    });
  }
  function kh(f) {
    return (0, e.default)({
      type: "EnumDefaultedMember",
      id: f
    });
  }
  function Lh(f, A) {
    return (0, e.default)({
      type: "IndexedAccessType",
      objectType: f,
      indexType: A
    });
  }
  function Mh(f, A) {
    return (0, e.default)({
      type: "OptionalIndexedAccessType",
      objectType: f,
      indexType: A,
      optional: null
    });
  }
  function Bh(f, A = null) {
    return (0, e.default)({
      type: "JSXAttribute",
      name: f,
      value: A
    });
  }
  function Fh(f) {
    return (0, e.default)({
      type: "JSXClosingElement",
      name: f
    });
  }
  function jh(f, A = null, q, he = null) {
    return (0, e.default)({
      type: "JSXElement",
      openingElement: f,
      closingElement: A,
      children: q,
      selfClosing: he
    });
  }
  function Rh() {
    return {
      type: "JSXEmptyExpression"
    };
  }
  function $h(f) {
    return (0, e.default)({
      type: "JSXExpressionContainer",
      expression: f
    });
  }
  function Uh(f) {
    return (0, e.default)({
      type: "JSXSpreadChild",
      expression: f
    });
  }
  function Vh(f) {
    return (0, e.default)({
      type: "JSXIdentifier",
      name: f
    });
  }
  function Kh(f, A) {
    return (0, e.default)({
      type: "JSXMemberExpression",
      object: f,
      property: A
    });
  }
  function qh(f, A) {
    return (0, e.default)({
      type: "JSXNamespacedName",
      namespace: f,
      name: A
    });
  }
  function Wh(f, A, q = !1) {
    return (0, e.default)({
      type: "JSXOpeningElement",
      name: f,
      attributes: A,
      selfClosing: q
    });
  }
  function Yh(f) {
    return (0, e.default)({
      type: "JSXSpreadAttribute",
      argument: f
    });
  }
  function Xh(f) {
    return (0, e.default)({
      type: "JSXText",
      value: f
    });
  }
  function Jh(f, A, q) {
    return (0, e.default)({
      type: "JSXFragment",
      openingFragment: f,
      closingFragment: A,
      children: q
    });
  }
  function Hh() {
    return {
      type: "JSXOpeningFragment"
    };
  }
  function Gh() {
    return {
      type: "JSXClosingFragment"
    };
  }
  function zh() {
    return {
      type: "Noop"
    };
  }
  function Qh(f, A) {
    return (0, e.default)({
      type: "Placeholder",
      expectedNode: f,
      name: A
    });
  }
  function Zh(f) {
    return (0, e.default)({
      type: "V8IntrinsicIdentifier",
      name: f
    });
  }
  function ed() {
    return {
      type: "ArgumentPlaceholder"
    };
  }
  function td(f, A) {
    return (0, e.default)({
      type: "BindExpression",
      object: f,
      callee: A
    });
  }
  function rd(f, A) {
    return (0, e.default)({
      type: "ImportAttribute",
      key: f,
      value: A
    });
  }
  function id(f) {
    return (0, e.default)({
      type: "Decorator",
      expression: f
    });
  }
  function sd(f, A = !1) {
    return (0, e.default)({
      type: "DoExpression",
      body: f,
      async: A
    });
  }
  function nd(f) {
    return (0, e.default)({
      type: "ExportDefaultSpecifier",
      exported: f
    });
  }
  function ad(f) {
    return (0, e.default)({
      type: "RecordExpression",
      properties: f
    });
  }
  function od(f = []) {
    return (0, e.default)({
      type: "TupleExpression",
      elements: f
    });
  }
  function ld(f) {
    return (0, e.default)({
      type: "DecimalLiteral",
      value: f
    });
  }
  function ud(f) {
    return (0, e.default)({
      type: "ModuleExpression",
      body: f
    });
  }
  function cd() {
    return {
      type: "TopicReference"
    };
  }
  function fd(f) {
    return (0, e.default)({
      type: "PipelineTopicExpression",
      expression: f
    });
  }
  function pd(f) {
    return (0, e.default)({
      type: "PipelineBareFunction",
      callee: f
    });
  }
  function hd() {
    return {
      type: "PipelinePrimaryTopicReference"
    };
  }
  function dd(f) {
    return (0, e.default)({
      type: "TSParameterProperty",
      parameter: f
    });
  }
  function md(f = null, A = null, q, he = null) {
    return (0, e.default)({
      type: "TSDeclareFunction",
      id: f,
      typeParameters: A,
      params: q,
      returnType: he
    });
  }
  function yd(f = null, A, q = null, he, qe = null) {
    return (0, e.default)({
      type: "TSDeclareMethod",
      decorators: f,
      key: A,
      typeParameters: q,
      params: he,
      returnType: qe
    });
  }
  function Td(f, A) {
    return (0, e.default)({
      type: "TSQualifiedName",
      left: f,
      right: A
    });
  }
  function Sd(f = null, A, q = null) {
    return (0, e.default)({
      type: "TSCallSignatureDeclaration",
      typeParameters: f,
      parameters: A,
      typeAnnotation: q
    });
  }
  function bd(f = null, A, q = null) {
    return (0, e.default)({
      type: "TSConstructSignatureDeclaration",
      typeParameters: f,
      parameters: A,
      typeAnnotation: q
    });
  }
  function gd(f, A = null, q = null) {
    return (0, e.default)({
      type: "TSPropertySignature",
      key: f,
      typeAnnotation: A,
      initializer: q,
      kind: null
    });
  }
  function Ed(f, A = null, q, he = null) {
    return (0, e.default)({
      type: "TSMethodSignature",
      key: f,
      typeParameters: A,
      parameters: q,
      typeAnnotation: he,
      kind: null
    });
  }
  function Pd(f, A = null) {
    return (0, e.default)({
      type: "TSIndexSignature",
      parameters: f,
      typeAnnotation: A
    });
  }
  function xd() {
    return {
      type: "TSAnyKeyword"
    };
  }
  function vd() {
    return {
      type: "TSBooleanKeyword"
    };
  }
  function Ad() {
    return {
      type: "TSBigIntKeyword"
    };
  }
  function Cd() {
    return {
      type: "TSIntrinsicKeyword"
    };
  }
  function Id() {
    return {
      type: "TSNeverKeyword"
    };
  }
  function wd() {
    return {
      type: "TSNullKeyword"
    };
  }
  function Od() {
    return {
      type: "TSNumberKeyword"
    };
  }
  function Nd() {
    return {
      type: "TSObjectKeyword"
    };
  }
  function _d() {
    return {
      type: "TSStringKeyword"
    };
  }
  function Dd() {
    return {
      type: "TSSymbolKeyword"
    };
  }
  function kd() {
    return {
      type: "TSUndefinedKeyword"
    };
  }
  function Ld() {
    return {
      type: "TSUnknownKeyword"
    };
  }
  function Md() {
    return {
      type: "TSVoidKeyword"
    };
  }
  function Bd() {
    return {
      type: "TSThisType"
    };
  }
  function Fd(f = null, A, q = null) {
    return (0, e.default)({
      type: "TSFunctionType",
      typeParameters: f,
      parameters: A,
      typeAnnotation: q
    });
  }
  function jd(f = null, A, q = null) {
    return (0, e.default)({
      type: "TSConstructorType",
      typeParameters: f,
      parameters: A,
      typeAnnotation: q
    });
  }
  function Rd(f, A = null) {
    return (0, e.default)({
      type: "TSTypeReference",
      typeName: f,
      typeParameters: A
    });
  }
  function $d(f, A = null, q = null) {
    return (0, e.default)({
      type: "TSTypePredicate",
      parameterName: f,
      typeAnnotation: A,
      asserts: q
    });
  }
  function Ud(f, A = null) {
    return (0, e.default)({
      type: "TSTypeQuery",
      exprName: f,
      typeParameters: A
    });
  }
  function Vd(f) {
    return (0, e.default)({
      type: "TSTypeLiteral",
      members: f
    });
  }
  function Kd(f) {
    return (0, e.default)({
      type: "TSArrayType",
      elementType: f
    });
  }
  function qd(f) {
    return (0, e.default)({
      type: "TSTupleType",
      elementTypes: f
    });
  }
  function Wd(f) {
    return (0, e.default)({
      type: "TSOptionalType",
      typeAnnotation: f
    });
  }
  function Yd(f) {
    return (0, e.default)({
      type: "TSRestType",
      typeAnnotation: f
    });
  }
  function Xd(f, A, q = !1) {
    return (0, e.default)({
      type: "TSNamedTupleMember",
      label: f,
      elementType: A,
      optional: q
    });
  }
  function Jd(f) {
    return (0, e.default)({
      type: "TSUnionType",
      types: f
    });
  }
  function Hd(f) {
    return (0, e.default)({
      type: "TSIntersectionType",
      types: f
    });
  }
  function Gd(f, A, q, he) {
    return (0, e.default)({
      type: "TSConditionalType",
      checkType: f,
      extendsType: A,
      trueType: q,
      falseType: he
    });
  }
  function zd(f) {
    return (0, e.default)({
      type: "TSInferType",
      typeParameter: f
    });
  }
  function Qd(f) {
    return (0, e.default)({
      type: "TSParenthesizedType",
      typeAnnotation: f
    });
  }
  function Zd(f) {
    return (0, e.default)({
      type: "TSTypeOperator",
      typeAnnotation: f,
      operator: null
    });
  }
  function em(f, A) {
    return (0, e.default)({
      type: "TSIndexedAccessType",
      objectType: f,
      indexType: A
    });
  }
  function tm(f, A = null, q = null) {
    return (0, e.default)({
      type: "TSMappedType",
      typeParameter: f,
      typeAnnotation: A,
      nameType: q
    });
  }
  function rm(f) {
    return (0, e.default)({
      type: "TSLiteralType",
      literal: f
    });
  }
  function im(f, A = null) {
    return (0, e.default)({
      type: "TSExpressionWithTypeArguments",
      expression: f,
      typeParameters: A
    });
  }
  function sm(f, A = null, q = null, he) {
    return (0, e.default)({
      type: "TSInterfaceDeclaration",
      id: f,
      typeParameters: A,
      extends: q,
      body: he
    });
  }
  function nm(f) {
    return (0, e.default)({
      type: "TSInterfaceBody",
      body: f
    });
  }
  function am(f, A = null, q) {
    return (0, e.default)({
      type: "TSTypeAliasDeclaration",
      id: f,
      typeParameters: A,
      typeAnnotation: q
    });
  }
  function om(f, A = null) {
    return (0, e.default)({
      type: "TSInstantiationExpression",
      expression: f,
      typeParameters: A
    });
  }
  function lm(f, A) {
    return (0, e.default)({
      type: "TSAsExpression",
      expression: f,
      typeAnnotation: A
    });
  }
  function um(f, A) {
    return (0, e.default)({
      type: "TSSatisfiesExpression",
      expression: f,
      typeAnnotation: A
    });
  }
  function cm(f, A) {
    return (0, e.default)({
      type: "TSTypeAssertion",
      typeAnnotation: f,
      expression: A
    });
  }
  function fm(f, A) {
    return (0, e.default)({
      type: "TSEnumDeclaration",
      id: f,
      members: A
    });
  }
  function pm(f, A = null) {
    return (0, e.default)({
      type: "TSEnumMember",
      id: f,
      initializer: A
    });
  }
  function hm(f, A) {
    return (0, e.default)({
      type: "TSModuleDeclaration",
      id: f,
      body: A
    });
  }
  function dm(f) {
    return (0, e.default)({
      type: "TSModuleBlock",
      body: f
    });
  }
  function mm(f, A = null, q = null) {
    return (0, e.default)({
      type: "TSImportType",
      argument: f,
      qualifier: A,
      typeParameters: q
    });
  }
  function ym(f, A) {
    return (0, e.default)({
      type: "TSImportEqualsDeclaration",
      id: f,
      moduleReference: A,
      isExport: null
    });
  }
  function Tm(f) {
    return (0, e.default)({
      type: "TSExternalModuleReference",
      expression: f
    });
  }
  function Sm(f) {
    return (0, e.default)({
      type: "TSNonNullExpression",
      expression: f
    });
  }
  function bm(f) {
    return (0, e.default)({
      type: "TSExportAssignment",
      expression: f
    });
  }
  function gm(f) {
    return (0, e.default)({
      type: "TSNamespaceExportDeclaration",
      id: f
    });
  }
  function Em(f) {
    return (0, e.default)({
      type: "TSTypeAnnotation",
      typeAnnotation: f
    });
  }
  function Pm(f) {
    return (0, e.default)({
      type: "TSTypeParameterInstantiation",
      params: f
    });
  }
  function xm(f) {
    return (0, e.default)({
      type: "TSTypeParameterDeclaration",
      params: f
    });
  }
  function vm(f = null, A = null, q) {
    return (0, e.default)({
      type: "TSTypeParameter",
      constraint: f,
      default: A,
      name: q
    });
  }
  function Am(f) {
    return (0, t.default)("NumberLiteral", "NumericLiteral", "The node type "), Z(f);
  }
  function Cm(f, A = "") {
    return (0, t.default)("RegexLiteral", "RegExpLiteral", "The node type "), me(f, A);
  }
  function Im(f) {
    return (0, t.default)("RestProperty", "RestElement", "The node type "), ie(f);
  }
  function wm(f) {
    return (0, t.default)("SpreadProperty", "SpreadElement", "The node type "), er(f);
  }
  return d;
}
var sl;
function mx() {
  if (sl)
    return _i;
  sl = 1, Object.defineProperty(_i, "__esModule", {
    value: !0
  }), _i.default = r;
  var e = ht(), t = Ae();
  function r(i, s) {
    const n = i.value.split(/\r\n|\n|\r/);
    let a = 0;
    for (let l = 0; l < n.length; l++)
      n[l].match(/[^ \t]/) && (a = l);
    let o = "";
    for (let l = 0; l < n.length; l++) {
      const u = n[l], c = l === 0, p = l === n.length - 1, h = l === a;
      let y = u.replace(/\t/g, " ");
      c || (y = y.replace(/^[ ]+/, "")), p || (y = y.replace(/[ ]+$/, "")), y && (h || (y += " "), o += y);
    }
    o && s.push((0, t.inherits)((0, e.stringLiteral)(o), i));
  }
  return _i;
}
var nl;
function yx() {
  if (nl)
    return Ni;
  nl = 1, Object.defineProperty(Ni, "__esModule", {
    value: !0
  }), Ni.default = r;
  var e = m, t = mx();
  function r(i) {
    const s = [];
    for (let n = 0; n < i.children.length; n++) {
      let a = i.children[n];
      if ((0, e.isJSXText)(a)) {
        (0, t.default)(a, s);
        continue;
      }
      (0, e.isJSXExpressionContainer)(a) && (a = a.expression), !(0, e.isJSXEmptyExpression)(a) && s.push(a);
    }
    return s;
  }
  return Ni;
}
var xa = {}, As = {};
Object.defineProperty(As, "__esModule", {
  value: !0
});
As.default = Sx;
var Tx = Et();
function Sx(e) {
  return !!(e && Tx.VISITOR_KEYS[e.type]);
}
Object.defineProperty(xa, "__esModule", {
  value: !0
});
xa.default = gx;
var bx = As;
function gx(e) {
  if (!(0, bx.default)(e)) {
    var t;
    const r = (t = e == null ? void 0 : e.type) != null ? t : JSON.stringify(e);
    throw new TypeError(`Not a valid node of type "${r}"`);
  }
}
var T = {};
Object.defineProperty(T, "__esModule", {
  value: !0
});
T.assertAccessor = MI;
T.assertAnyTypeAnnotation = tA;
T.assertArgumentPlaceholder = N1;
T.assertArrayExpression = Px;
T.assertArrayPattern = gv;
T.assertArrayTypeAnnotation = rA;
T.assertArrowFunctionExpression = Ev;
T.assertAssignmentExpression = xx;
T.assertAssignmentPattern = bv;
T.assertAwaitExpression = Kv;
T.assertBigIntLiteral = Wv;
T.assertBinary = iI;
T.assertBinaryExpression = vx;
T.assertBindExpression = _1;
T.assertBlock = aI;
T.assertBlockParent = nI;
T.assertBlockStatement = wx;
T.assertBooleanLiteral = Hx;
T.assertBooleanLiteralTypeAnnotation = sA;
T.assertBooleanTypeAnnotation = iA;
T.assertBreakStatement = Ox;
T.assertCallExpression = Nx;
T.assertCatchClause = _x;
T.assertClass = _I;
T.assertClassAccessorProperty = Gv;
T.assertClassBody = Pv;
T.assertClassDeclaration = vv;
T.assertClassExpression = xv;
T.assertClassImplements = aA;
T.assertClassMethod = Mv;
T.assertClassPrivateMethod = Qv;
T.assertClassPrivateProperty = zv;
T.assertClassProperty = Hv;
T.assertCompletionStatement = uI;
T.assertConditional = cI;
T.assertConditionalExpression = Dx;
T.assertContinueStatement = kx;
T.assertDebuggerStatement = Lx;
T.assertDecimalLiteral = j1;
T.assertDeclaration = bI;
T.assertDeclareClass = oA;
T.assertDeclareExportAllDeclaration = yA;
T.assertDeclareExportDeclaration = mA;
T.assertDeclareFunction = lA;
T.assertDeclareInterface = uA;
T.assertDeclareModule = cA;
T.assertDeclareModuleExports = fA;
T.assertDeclareOpaqueType = hA;
T.assertDeclareTypeAlias = pA;
T.assertDeclareVariable = dA;
T.assertDeclaredPredicate = TA;
T.assertDecorator = k1;
T.assertDirective = Cx;
T.assertDirectiveLiteral = Ix;
T.assertDoExpression = L1;
T.assertDoWhileStatement = Mx;
T.assertEmptyStatement = Bx;
T.assertEmptyTypeAnnotation = wA;
T.assertEnumBody = VI;
T.assertEnumBooleanBody = r1;
T.assertEnumBooleanMember = a1;
T.assertEnumDeclaration = t1;
T.assertEnumDefaultedMember = u1;
T.assertEnumMember = KI;
T.assertEnumNumberBody = i1;
T.assertEnumNumberMember = o1;
T.assertEnumStringBody = s1;
T.assertEnumStringMember = l1;
T.assertEnumSymbolBody = n1;
T.assertExistsTypeAnnotation = SA;
T.assertExportAllDeclaration = Av;
T.assertExportDeclaration = kI;
T.assertExportDefaultDeclaration = Cv;
T.assertExportDefaultSpecifier = M1;
T.assertExportNamedDeclaration = Iv;
T.assertExportNamespaceSpecifier = Yv;
T.assertExportSpecifier = wv;
T.assertExpression = rI;
T.assertExpressionStatement = Fx;
T.assertExpressionWrapper = hI;
T.assertFile = jx;
T.assertFlow = FI;
T.assertFlowBaseAnnotation = RI;
T.assertFlowDeclaration = $I;
T.assertFlowPredicate = UI;
T.assertFlowType = jI;
T.assertFor = dI;
T.assertForInStatement = Rx;
T.assertForOfStatement = Ov;
T.assertForStatement = $x;
T.assertForXStatement = mI;
T.assertFunction = yI;
T.assertFunctionDeclaration = Ux;
T.assertFunctionExpression = Vx;
T.assertFunctionParent = TI;
T.assertFunctionTypeAnnotation = bA;
T.assertFunctionTypeParam = gA;
T.assertGenericTypeAnnotation = EA;
T.assertIdentifier = Kx;
T.assertIfStatement = qx;
T.assertImmutable = vI;
T.assertImport = qv;
T.assertImportAttribute = D1;
T.assertImportDeclaration = Nv;
T.assertImportDefaultSpecifier = _v;
T.assertImportNamespaceSpecifier = Dv;
T.assertImportOrExportDeclaration = DI;
T.assertImportSpecifier = kv;
T.assertIndexedAccessType = c1;
T.assertInferredPredicate = PA;
T.assertInterfaceDeclaration = vA;
T.assertInterfaceExtends = xA;
T.assertInterfaceTypeAnnotation = AA;
T.assertInterpreterDirective = Ax;
T.assertIntersectionTypeAnnotation = CA;
T.assertJSX = qI;
T.assertJSXAttribute = p1;
T.assertJSXClosingElement = h1;
T.assertJSXClosingFragment = C1;
T.assertJSXElement = d1;
T.assertJSXEmptyExpression = m1;
T.assertJSXExpressionContainer = y1;
T.assertJSXFragment = v1;
T.assertJSXIdentifier = S1;
T.assertJSXMemberExpression = b1;
T.assertJSXNamespacedName = g1;
T.assertJSXOpeningElement = E1;
T.assertJSXOpeningFragment = A1;
T.assertJSXSpreadAttribute = P1;
T.assertJSXSpreadChild = T1;
T.assertJSXText = x1;
T.assertLVal = EI;
T.assertLabeledStatement = Wx;
T.assertLiteral = xI;
T.assertLogicalExpression = zx;
T.assertLoop = fI;
T.assertMemberExpression = Qx;
T.assertMetaProperty = Lv;
T.assertMethod = CI;
T.assertMiscellaneous = WI;
T.assertMixedTypeAnnotation = IA;
T.assertModuleDeclaration = ew;
T.assertModuleExpression = R1;
T.assertModuleSpecifier = LI;
T.assertNewExpression = Zx;
T.assertNoop = I1;
T.assertNullLiteral = Jx;
T.assertNullLiteralTypeAnnotation = nA;
T.assertNullableTypeAnnotation = OA;
T.assertNumberLiteral = GI;
T.assertNumberLiteralTypeAnnotation = NA;
T.assertNumberTypeAnnotation = _A;
T.assertNumericLiteral = Xx;
T.assertObjectExpression = tv;
T.assertObjectMember = II;
T.assertObjectMethod = rv;
T.assertObjectPattern = Bv;
T.assertObjectProperty = iv;
T.assertObjectTypeAnnotation = DA;
T.assertObjectTypeCallProperty = LA;
T.assertObjectTypeIndexer = MA;
T.assertObjectTypeInternalSlot = kA;
T.assertObjectTypeProperty = BA;
T.assertObjectTypeSpreadProperty = FA;
T.assertOpaqueType = jA;
T.assertOptionalCallExpression = Jv;
T.assertOptionalIndexedAccessType = f1;
T.assertOptionalMemberExpression = Xv;
T.assertParenthesizedExpression = ov;
T.assertPattern = NI;
T.assertPatternLike = gI;
T.assertPipelineBareFunction = V1;
T.assertPipelinePrimaryTopicReference = K1;
T.assertPipelineTopicExpression = U1;
T.assertPlaceholder = w1;
T.assertPrivate = BI;
T.assertPrivateName = Zv;
T.assertProgram = ev;
T.assertProperty = wI;
T.assertPureish = SI;
T.assertQualifiedTypeIdentifier = RA;
T.assertRecordExpression = B1;
T.assertRegExpLiteral = Gx;
T.assertRegexLiteral = zI;
T.assertRestElement = sv;
T.assertRestProperty = QI;
T.assertReturnStatement = nv;
T.assertScopable = sI;
T.assertSequenceExpression = av;
T.assertSpreadElement = Fv;
T.assertSpreadProperty = ZI;
T.assertStandardized = tI;
T.assertStatement = oI;
T.assertStaticBlock = eA;
T.assertStringLiteral = Yx;
T.assertStringLiteralTypeAnnotation = $A;
T.assertStringTypeAnnotation = UA;
T.assertSuper = jv;
T.assertSwitchCase = lv;
T.assertSwitchStatement = uv;
T.assertSymbolTypeAnnotation = VA;
T.assertTSAnyKeyword = Z1;
T.assertTSArrayType = bC;
T.assertTSAsExpression = jC;
T.assertTSBaseType = HI;
T.assertTSBigIntKeyword = tC;
T.assertTSBooleanKeyword = eC;
T.assertTSCallSignatureDeclaration = J1;
T.assertTSConditionalType = CC;
T.assertTSConstructSignatureDeclaration = H1;
T.assertTSConstructorType = dC;
T.assertTSDeclareFunction = W1;
T.assertTSDeclareMethod = Y1;
T.assertTSEntityName = PI;
T.assertTSEnumDeclaration = UC;
T.assertTSEnumMember = VC;
T.assertTSExportAssignment = HC;
T.assertTSExpressionWithTypeArguments = kC;
T.assertTSExternalModuleReference = XC;
T.assertTSFunctionType = hC;
T.assertTSImportEqualsDeclaration = YC;
T.assertTSImportType = WC;
T.assertTSIndexSignature = Q1;
T.assertTSIndexedAccessType = NC;
T.assertTSInferType = IC;
T.assertTSInstantiationExpression = FC;
T.assertTSInterfaceBody = MC;
T.assertTSInterfaceDeclaration = LC;
T.assertTSIntersectionType = AC;
T.assertTSIntrinsicKeyword = rC;
T.assertTSLiteralType = DC;
T.assertTSMappedType = _C;
T.assertTSMethodSignature = z1;
T.assertTSModuleBlock = qC;
T.assertTSModuleDeclaration = KC;
T.assertTSNamedTupleMember = xC;
T.assertTSNamespaceExportDeclaration = GC;
T.assertTSNeverKeyword = iC;
T.assertTSNonNullExpression = JC;
T.assertTSNullKeyword = sC;
T.assertTSNumberKeyword = nC;
T.assertTSObjectKeyword = aC;
T.assertTSOptionalType = EC;
T.assertTSParameterProperty = q1;
T.assertTSParenthesizedType = wC;
T.assertTSPropertySignature = G1;
T.assertTSQualifiedName = X1;
T.assertTSRestType = PC;
T.assertTSSatisfiesExpression = RC;
T.assertTSStringKeyword = oC;
T.assertTSSymbolKeyword = lC;
T.assertTSThisType = pC;
T.assertTSTupleType = gC;
T.assertTSType = JI;
T.assertTSTypeAliasDeclaration = BC;
T.assertTSTypeAnnotation = zC;
T.assertTSTypeAssertion = $C;
T.assertTSTypeElement = XI;
T.assertTSTypeLiteral = SC;
T.assertTSTypeOperator = OC;
T.assertTSTypeParameter = eI;
T.assertTSTypeParameterDeclaration = ZC;
T.assertTSTypeParameterInstantiation = QC;
T.assertTSTypePredicate = yC;
T.assertTSTypeQuery = TC;
T.assertTSTypeReference = mC;
T.assertTSUndefinedKeyword = uC;
T.assertTSUnionType = vC;
T.assertTSUnknownKeyword = cC;
T.assertTSVoidKeyword = fC;
T.assertTaggedTemplateExpression = Rv;
T.assertTemplateElement = $v;
T.assertTemplateLiteral = Uv;
T.assertTerminatorless = lI;
T.assertThisExpression = cv;
T.assertThisTypeAnnotation = KA;
T.assertThrowStatement = fv;
T.assertTopicReference = $1;
T.assertTryStatement = pv;
T.assertTupleExpression = F1;
T.assertTupleTypeAnnotation = qA;
T.assertTypeAlias = YA;
T.assertTypeAnnotation = XA;
T.assertTypeCastExpression = JA;
T.assertTypeParameter = HA;
T.assertTypeParameterDeclaration = GA;
T.assertTypeParameterInstantiation = zA;
T.assertTypeScript = YI;
T.assertTypeofTypeAnnotation = WA;
T.assertUnaryExpression = hv;
T.assertUnaryLike = OI;
T.assertUnionTypeAnnotation = QA;
T.assertUpdateExpression = dv;
T.assertUserWhitespacable = AI;
T.assertV8IntrinsicIdentifier = O1;
T.assertVariableDeclaration = mv;
T.assertVariableDeclarator = yv;
T.assertVariance = ZA;
T.assertVoidTypeAnnotation = e1;
T.assertWhile = pI;
T.assertWhileStatement = Tv;
T.assertWithStatement = Sv;
T.assertYieldExpression = Vv;
var Ex = fi(), mi = Mr;
function b(e, t, r) {
  if (!(0, Ex.default)(e, t, r))
    throw new Error(`Expected type "${e}" with option ${JSON.stringify(r)}, but instead got "${t.type}".`);
}
function Px(e, t) {
  b("ArrayExpression", e, t);
}
function xx(e, t) {
  b("AssignmentExpression", e, t);
}
function vx(e, t) {
  b("BinaryExpression", e, t);
}
function Ax(e, t) {
  b("InterpreterDirective", e, t);
}
function Cx(e, t) {
  b("Directive", e, t);
}
function Ix(e, t) {
  b("DirectiveLiteral", e, t);
}
function wx(e, t) {
  b("BlockStatement", e, t);
}
function Ox(e, t) {
  b("BreakStatement", e, t);
}
function Nx(e, t) {
  b("CallExpression", e, t);
}
function _x(e, t) {
  b("CatchClause", e, t);
}
function Dx(e, t) {
  b("ConditionalExpression", e, t);
}
function kx(e, t) {
  b("ContinueStatement", e, t);
}
function Lx(e, t) {
  b("DebuggerStatement", e, t);
}
function Mx(e, t) {
  b("DoWhileStatement", e, t);
}
function Bx(e, t) {
  b("EmptyStatement", e, t);
}
function Fx(e, t) {
  b("ExpressionStatement", e, t);
}
function jx(e, t) {
  b("File", e, t);
}
function Rx(e, t) {
  b("ForInStatement", e, t);
}
function $x(e, t) {
  b("ForStatement", e, t);
}
function Ux(e, t) {
  b("FunctionDeclaration", e, t);
}
function Vx(e, t) {
  b("FunctionExpression", e, t);
}
function Kx(e, t) {
  b("Identifier", e, t);
}
function qx(e, t) {
  b("IfStatement", e, t);
}
function Wx(e, t) {
  b("LabeledStatement", e, t);
}
function Yx(e, t) {
  b("StringLiteral", e, t);
}
function Xx(e, t) {
  b("NumericLiteral", e, t);
}
function Jx(e, t) {
  b("NullLiteral", e, t);
}
function Hx(e, t) {
  b("BooleanLiteral", e, t);
}
function Gx(e, t) {
  b("RegExpLiteral", e, t);
}
function zx(e, t) {
  b("LogicalExpression", e, t);
}
function Qx(e, t) {
  b("MemberExpression", e, t);
}
function Zx(e, t) {
  b("NewExpression", e, t);
}
function ev(e, t) {
  b("Program", e, t);
}
function tv(e, t) {
  b("ObjectExpression", e, t);
}
function rv(e, t) {
  b("ObjectMethod", e, t);
}
function iv(e, t) {
  b("ObjectProperty", e, t);
}
function sv(e, t) {
  b("RestElement", e, t);
}
function nv(e, t) {
  b("ReturnStatement", e, t);
}
function av(e, t) {
  b("SequenceExpression", e, t);
}
function ov(e, t) {
  b("ParenthesizedExpression", e, t);
}
function lv(e, t) {
  b("SwitchCase", e, t);
}
function uv(e, t) {
  b("SwitchStatement", e, t);
}
function cv(e, t) {
  b("ThisExpression", e, t);
}
function fv(e, t) {
  b("ThrowStatement", e, t);
}
function pv(e, t) {
  b("TryStatement", e, t);
}
function hv(e, t) {
  b("UnaryExpression", e, t);
}
function dv(e, t) {
  b("UpdateExpression", e, t);
}
function mv(e, t) {
  b("VariableDeclaration", e, t);
}
function yv(e, t) {
  b("VariableDeclarator", e, t);
}
function Tv(e, t) {
  b("WhileStatement", e, t);
}
function Sv(e, t) {
  b("WithStatement", e, t);
}
function bv(e, t) {
  b("AssignmentPattern", e, t);
}
function gv(e, t) {
  b("ArrayPattern", e, t);
}
function Ev(e, t) {
  b("ArrowFunctionExpression", e, t);
}
function Pv(e, t) {
  b("ClassBody", e, t);
}
function xv(e, t) {
  b("ClassExpression", e, t);
}
function vv(e, t) {
  b("ClassDeclaration", e, t);
}
function Av(e, t) {
  b("ExportAllDeclaration", e, t);
}
function Cv(e, t) {
  b("ExportDefaultDeclaration", e, t);
}
function Iv(e, t) {
  b("ExportNamedDeclaration", e, t);
}
function wv(e, t) {
  b("ExportSpecifier", e, t);
}
function Ov(e, t) {
  b("ForOfStatement", e, t);
}
function Nv(e, t) {
  b("ImportDeclaration", e, t);
}
function _v(e, t) {
  b("ImportDefaultSpecifier", e, t);
}
function Dv(e, t) {
  b("ImportNamespaceSpecifier", e, t);
}
function kv(e, t) {
  b("ImportSpecifier", e, t);
}
function Lv(e, t) {
  b("MetaProperty", e, t);
}
function Mv(e, t) {
  b("ClassMethod", e, t);
}
function Bv(e, t) {
  b("ObjectPattern", e, t);
}
function Fv(e, t) {
  b("SpreadElement", e, t);
}
function jv(e, t) {
  b("Super", e, t);
}
function Rv(e, t) {
  b("TaggedTemplateExpression", e, t);
}
function $v(e, t) {
  b("TemplateElement", e, t);
}
function Uv(e, t) {
  b("TemplateLiteral", e, t);
}
function Vv(e, t) {
  b("YieldExpression", e, t);
}
function Kv(e, t) {
  b("AwaitExpression", e, t);
}
function qv(e, t) {
  b("Import", e, t);
}
function Wv(e, t) {
  b("BigIntLiteral", e, t);
}
function Yv(e, t) {
  b("ExportNamespaceSpecifier", e, t);
}
function Xv(e, t) {
  b("OptionalMemberExpression", e, t);
}
function Jv(e, t) {
  b("OptionalCallExpression", e, t);
}
function Hv(e, t) {
  b("ClassProperty", e, t);
}
function Gv(e, t) {
  b("ClassAccessorProperty", e, t);
}
function zv(e, t) {
  b("ClassPrivateProperty", e, t);
}
function Qv(e, t) {
  b("ClassPrivateMethod", e, t);
}
function Zv(e, t) {
  b("PrivateName", e, t);
}
function eA(e, t) {
  b("StaticBlock", e, t);
}
function tA(e, t) {
  b("AnyTypeAnnotation", e, t);
}
function rA(e, t) {
  b("ArrayTypeAnnotation", e, t);
}
function iA(e, t) {
  b("BooleanTypeAnnotation", e, t);
}
function sA(e, t) {
  b("BooleanLiteralTypeAnnotation", e, t);
}
function nA(e, t) {
  b("NullLiteralTypeAnnotation", e, t);
}
function aA(e, t) {
  b("ClassImplements", e, t);
}
function oA(e, t) {
  b("DeclareClass", e, t);
}
function lA(e, t) {
  b("DeclareFunction", e, t);
}
function uA(e, t) {
  b("DeclareInterface", e, t);
}
function cA(e, t) {
  b("DeclareModule", e, t);
}
function fA(e, t) {
  b("DeclareModuleExports", e, t);
}
function pA(e, t) {
  b("DeclareTypeAlias", e, t);
}
function hA(e, t) {
  b("DeclareOpaqueType", e, t);
}
function dA(e, t) {
  b("DeclareVariable", e, t);
}
function mA(e, t) {
  b("DeclareExportDeclaration", e, t);
}
function yA(e, t) {
  b("DeclareExportAllDeclaration", e, t);
}
function TA(e, t) {
  b("DeclaredPredicate", e, t);
}
function SA(e, t) {
  b("ExistsTypeAnnotation", e, t);
}
function bA(e, t) {
  b("FunctionTypeAnnotation", e, t);
}
function gA(e, t) {
  b("FunctionTypeParam", e, t);
}
function EA(e, t) {
  b("GenericTypeAnnotation", e, t);
}
function PA(e, t) {
  b("InferredPredicate", e, t);
}
function xA(e, t) {
  b("InterfaceExtends", e, t);
}
function vA(e, t) {
  b("InterfaceDeclaration", e, t);
}
function AA(e, t) {
  b("InterfaceTypeAnnotation", e, t);
}
function CA(e, t) {
  b("IntersectionTypeAnnotation", e, t);
}
function IA(e, t) {
  b("MixedTypeAnnotation", e, t);
}
function wA(e, t) {
  b("EmptyTypeAnnotation", e, t);
}
function OA(e, t) {
  b("NullableTypeAnnotation", e, t);
}
function NA(e, t) {
  b("NumberLiteralTypeAnnotation", e, t);
}
function _A(e, t) {
  b("NumberTypeAnnotation", e, t);
}
function DA(e, t) {
  b("ObjectTypeAnnotation", e, t);
}
function kA(e, t) {
  b("ObjectTypeInternalSlot", e, t);
}
function LA(e, t) {
  b("ObjectTypeCallProperty", e, t);
}
function MA(e, t) {
  b("ObjectTypeIndexer", e, t);
}
function BA(e, t) {
  b("ObjectTypeProperty", e, t);
}
function FA(e, t) {
  b("ObjectTypeSpreadProperty", e, t);
}
function jA(e, t) {
  b("OpaqueType", e, t);
}
function RA(e, t) {
  b("QualifiedTypeIdentifier", e, t);
}
function $A(e, t) {
  b("StringLiteralTypeAnnotation", e, t);
}
function UA(e, t) {
  b("StringTypeAnnotation", e, t);
}
function VA(e, t) {
  b("SymbolTypeAnnotation", e, t);
}
function KA(e, t) {
  b("ThisTypeAnnotation", e, t);
}
function qA(e, t) {
  b("TupleTypeAnnotation", e, t);
}
function WA(e, t) {
  b("TypeofTypeAnnotation", e, t);
}
function YA(e, t) {
  b("TypeAlias", e, t);
}
function XA(e, t) {
  b("TypeAnnotation", e, t);
}
function JA(e, t) {
  b("TypeCastExpression", e, t);
}
function HA(e, t) {
  b("TypeParameter", e, t);
}
function GA(e, t) {
  b("TypeParameterDeclaration", e, t);
}
function zA(e, t) {
  b("TypeParameterInstantiation", e, t);
}
function QA(e, t) {
  b("UnionTypeAnnotation", e, t);
}
function ZA(e, t) {
  b("Variance", e, t);
}
function e1(e, t) {
  b("VoidTypeAnnotation", e, t);
}
function t1(e, t) {
  b("EnumDeclaration", e, t);
}
function r1(e, t) {
  b("EnumBooleanBody", e, t);
}
function i1(e, t) {
  b("EnumNumberBody", e, t);
}
function s1(e, t) {
  b("EnumStringBody", e, t);
}
function n1(e, t) {
  b("EnumSymbolBody", e, t);
}
function a1(e, t) {
  b("EnumBooleanMember", e, t);
}
function o1(e, t) {
  b("EnumNumberMember", e, t);
}
function l1(e, t) {
  b("EnumStringMember", e, t);
}
function u1(e, t) {
  b("EnumDefaultedMember", e, t);
}
function c1(e, t) {
  b("IndexedAccessType", e, t);
}
function f1(e, t) {
  b("OptionalIndexedAccessType", e, t);
}
function p1(e, t) {
  b("JSXAttribute", e, t);
}
function h1(e, t) {
  b("JSXClosingElement", e, t);
}
function d1(e, t) {
  b("JSXElement", e, t);
}
function m1(e, t) {
  b("JSXEmptyExpression", e, t);
}
function y1(e, t) {
  b("JSXExpressionContainer", e, t);
}
function T1(e, t) {
  b("JSXSpreadChild", e, t);
}
function S1(e, t) {
  b("JSXIdentifier", e, t);
}
function b1(e, t) {
  b("JSXMemberExpression", e, t);
}
function g1(e, t) {
  b("JSXNamespacedName", e, t);
}
function E1(e, t) {
  b("JSXOpeningElement", e, t);
}
function P1(e, t) {
  b("JSXSpreadAttribute", e, t);
}
function x1(e, t) {
  b("JSXText", e, t);
}
function v1(e, t) {
  b("JSXFragment", e, t);
}
function A1(e, t) {
  b("JSXOpeningFragment", e, t);
}
function C1(e, t) {
  b("JSXClosingFragment", e, t);
}
function I1(e, t) {
  b("Noop", e, t);
}
function w1(e, t) {
  b("Placeholder", e, t);
}
function O1(e, t) {
  b("V8IntrinsicIdentifier", e, t);
}
function N1(e, t) {
  b("ArgumentPlaceholder", e, t);
}
function _1(e, t) {
  b("BindExpression", e, t);
}
function D1(e, t) {
  b("ImportAttribute", e, t);
}
function k1(e, t) {
  b("Decorator", e, t);
}
function L1(e, t) {
  b("DoExpression", e, t);
}
function M1(e, t) {
  b("ExportDefaultSpecifier", e, t);
}
function B1(e, t) {
  b("RecordExpression", e, t);
}
function F1(e, t) {
  b("TupleExpression", e, t);
}
function j1(e, t) {
  b("DecimalLiteral", e, t);
}
function R1(e, t) {
  b("ModuleExpression", e, t);
}
function $1(e, t) {
  b("TopicReference", e, t);
}
function U1(e, t) {
  b("PipelineTopicExpression", e, t);
}
function V1(e, t) {
  b("PipelineBareFunction", e, t);
}
function K1(e, t) {
  b("PipelinePrimaryTopicReference", e, t);
}
function q1(e, t) {
  b("TSParameterProperty", e, t);
}
function W1(e, t) {
  b("TSDeclareFunction", e, t);
}
function Y1(e, t) {
  b("TSDeclareMethod", e, t);
}
function X1(e, t) {
  b("TSQualifiedName", e, t);
}
function J1(e, t) {
  b("TSCallSignatureDeclaration", e, t);
}
function H1(e, t) {
  b("TSConstructSignatureDeclaration", e, t);
}
function G1(e, t) {
  b("TSPropertySignature", e, t);
}
function z1(e, t) {
  b("TSMethodSignature", e, t);
}
function Q1(e, t) {
  b("TSIndexSignature", e, t);
}
function Z1(e, t) {
  b("TSAnyKeyword", e, t);
}
function eC(e, t) {
  b("TSBooleanKeyword", e, t);
}
function tC(e, t) {
  b("TSBigIntKeyword", e, t);
}
function rC(e, t) {
  b("TSIntrinsicKeyword", e, t);
}
function iC(e, t) {
  b("TSNeverKeyword", e, t);
}
function sC(e, t) {
  b("TSNullKeyword", e, t);
}
function nC(e, t) {
  b("TSNumberKeyword", e, t);
}
function aC(e, t) {
  b("TSObjectKeyword", e, t);
}
function oC(e, t) {
  b("TSStringKeyword", e, t);
}
function lC(e, t) {
  b("TSSymbolKeyword", e, t);
}
function uC(e, t) {
  b("TSUndefinedKeyword", e, t);
}
function cC(e, t) {
  b("TSUnknownKeyword", e, t);
}
function fC(e, t) {
  b("TSVoidKeyword", e, t);
}
function pC(e, t) {
  b("TSThisType", e, t);
}
function hC(e, t) {
  b("TSFunctionType", e, t);
}
function dC(e, t) {
  b("TSConstructorType", e, t);
}
function mC(e, t) {
  b("TSTypeReference", e, t);
}
function yC(e, t) {
  b("TSTypePredicate", e, t);
}
function TC(e, t) {
  b("TSTypeQuery", e, t);
}
function SC(e, t) {
  b("TSTypeLiteral", e, t);
}
function bC(e, t) {
  b("TSArrayType", e, t);
}
function gC(e, t) {
  b("TSTupleType", e, t);
}
function EC(e, t) {
  b("TSOptionalType", e, t);
}
function PC(e, t) {
  b("TSRestType", e, t);
}
function xC(e, t) {
  b("TSNamedTupleMember", e, t);
}
function vC(e, t) {
  b("TSUnionType", e, t);
}
function AC(e, t) {
  b("TSIntersectionType", e, t);
}
function CC(e, t) {
  b("TSConditionalType", e, t);
}
function IC(e, t) {
  b("TSInferType", e, t);
}
function wC(e, t) {
  b("TSParenthesizedType", e, t);
}
function OC(e, t) {
  b("TSTypeOperator", e, t);
}
function NC(e, t) {
  b("TSIndexedAccessType", e, t);
}
function _C(e, t) {
  b("TSMappedType", e, t);
}
function DC(e, t) {
  b("TSLiteralType", e, t);
}
function kC(e, t) {
  b("TSExpressionWithTypeArguments", e, t);
}
function LC(e, t) {
  b("TSInterfaceDeclaration", e, t);
}
function MC(e, t) {
  b("TSInterfaceBody", e, t);
}
function BC(e, t) {
  b("TSTypeAliasDeclaration", e, t);
}
function FC(e, t) {
  b("TSInstantiationExpression", e, t);
}
function jC(e, t) {
  b("TSAsExpression", e, t);
}
function RC(e, t) {
  b("TSSatisfiesExpression", e, t);
}
function $C(e, t) {
  b("TSTypeAssertion", e, t);
}
function UC(e, t) {
  b("TSEnumDeclaration", e, t);
}
function VC(e, t) {
  b("TSEnumMember", e, t);
}
function KC(e, t) {
  b("TSModuleDeclaration", e, t);
}
function qC(e, t) {
  b("TSModuleBlock", e, t);
}
function WC(e, t) {
  b("TSImportType", e, t);
}
function YC(e, t) {
  b("TSImportEqualsDeclaration", e, t);
}
function XC(e, t) {
  b("TSExternalModuleReference", e, t);
}
function JC(e, t) {
  b("TSNonNullExpression", e, t);
}
function HC(e, t) {
  b("TSExportAssignment", e, t);
}
function GC(e, t) {
  b("TSNamespaceExportDeclaration", e, t);
}
function zC(e, t) {
  b("TSTypeAnnotation", e, t);
}
function QC(e, t) {
  b("TSTypeParameterInstantiation", e, t);
}
function ZC(e, t) {
  b("TSTypeParameterDeclaration", e, t);
}
function eI(e, t) {
  b("TSTypeParameter", e, t);
}
function tI(e, t) {
  b("Standardized", e, t);
}
function rI(e, t) {
  b("Expression", e, t);
}
function iI(e, t) {
  b("Binary", e, t);
}
function sI(e, t) {
  b("Scopable", e, t);
}
function nI(e, t) {
  b("BlockParent", e, t);
}
function aI(e, t) {
  b("Block", e, t);
}
function oI(e, t) {
  b("Statement", e, t);
}
function lI(e, t) {
  b("Terminatorless", e, t);
}
function uI(e, t) {
  b("CompletionStatement", e, t);
}
function cI(e, t) {
  b("Conditional", e, t);
}
function fI(e, t) {
  b("Loop", e, t);
}
function pI(e, t) {
  b("While", e, t);
}
function hI(e, t) {
  b("ExpressionWrapper", e, t);
}
function dI(e, t) {
  b("For", e, t);
}
function mI(e, t) {
  b("ForXStatement", e, t);
}
function yI(e, t) {
  b("Function", e, t);
}
function TI(e, t) {
  b("FunctionParent", e, t);
}
function SI(e, t) {
  b("Pureish", e, t);
}
function bI(e, t) {
  b("Declaration", e, t);
}
function gI(e, t) {
  b("PatternLike", e, t);
}
function EI(e, t) {
  b("LVal", e, t);
}
function PI(e, t) {
  b("TSEntityName", e, t);
}
function xI(e, t) {
  b("Literal", e, t);
}
function vI(e, t) {
  b("Immutable", e, t);
}
function AI(e, t) {
  b("UserWhitespacable", e, t);
}
function CI(e, t) {
  b("Method", e, t);
}
function II(e, t) {
  b("ObjectMember", e, t);
}
function wI(e, t) {
  b("Property", e, t);
}
function OI(e, t) {
  b("UnaryLike", e, t);
}
function NI(e, t) {
  b("Pattern", e, t);
}
function _I(e, t) {
  b("Class", e, t);
}
function DI(e, t) {
  b("ImportOrExportDeclaration", e, t);
}
function kI(e, t) {
  b("ExportDeclaration", e, t);
}
function LI(e, t) {
  b("ModuleSpecifier", e, t);
}
function MI(e, t) {
  b("Accessor", e, t);
}
function BI(e, t) {
  b("Private", e, t);
}
function FI(e, t) {
  b("Flow", e, t);
}
function jI(e, t) {
  b("FlowType", e, t);
}
function RI(e, t) {
  b("FlowBaseAnnotation", e, t);
}
function $I(e, t) {
  b("FlowDeclaration", e, t);
}
function UI(e, t) {
  b("FlowPredicate", e, t);
}
function VI(e, t) {
  b("EnumBody", e, t);
}
function KI(e, t) {
  b("EnumMember", e, t);
}
function qI(e, t) {
  b("JSX", e, t);
}
function WI(e, t) {
  b("Miscellaneous", e, t);
}
function YI(e, t) {
  b("TypeScript", e, t);
}
function XI(e, t) {
  b("TSTypeElement", e, t);
}
function JI(e, t) {
  b("TSType", e, t);
}
function HI(e, t) {
  b("TSBaseType", e, t);
}
function GI(e, t) {
  (0, mi.default)("assertNumberLiteral", "assertNumericLiteral"), b("NumberLiteral", e, t);
}
function zI(e, t) {
  (0, mi.default)("assertRegexLiteral", "assertRegExpLiteral"), b("RegexLiteral", e, t);
}
function QI(e, t) {
  (0, mi.default)("assertRestProperty", "assertRestElement"), b("RestProperty", e, t);
}
function ZI(e, t) {
  (0, mi.default)("assertSpreadProperty", "assertSpreadElement"), b("SpreadProperty", e, t);
}
function ew(e, t) {
  (0, mi.default)("assertModuleDeclaration", "assertImportOrExportDeclaration"), b("ModuleDeclaration", e, t);
}
var Kr = {}, al;
function tw() {
  if (al)
    return Kr;
  al = 1, Object.defineProperty(Kr, "__esModule", {
    value: !0
  }), Kr.default = void 0;
  var e = ht(), t = r;
  Kr.default = t;
  function r(i) {
    switch (i) {
      case "string":
        return (0, e.stringTypeAnnotation)();
      case "number":
        return (0, e.numberTypeAnnotation)();
      case "undefined":
        return (0, e.voidTypeAnnotation)();
      case "boolean":
        return (0, e.booleanTypeAnnotation)();
      case "function":
        return (0, e.genericTypeAnnotation)((0, e.identifier)("Function"));
      case "object":
        return (0, e.genericTypeAnnotation)((0, e.identifier)("Object"));
      case "symbol":
        return (0, e.genericTypeAnnotation)((0, e.identifier)("Symbol"));
      case "bigint":
        return (0, e.anyTypeAnnotation)();
    }
    throw new Error("Invalid typeof value: " + i);
  }
  return Kr;
}
var Fi = {}, Cs = {};
Object.defineProperty(Cs, "__esModule", {
  value: !0
});
Cs.default = Mc;
var Qr = m;
function Lc(e) {
  return (0, Qr.isIdentifier)(e) ? e.name : `${e.id.name}.${Lc(e.qualification)}`;
}
function Mc(e) {
  const t = Array.from(e), r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Set(), n = [];
  for (let a = 0; a < t.length; a++) {
    const o = t[a];
    if (o && !(n.indexOf(o) >= 0)) {
      if ((0, Qr.isAnyTypeAnnotation)(o))
        return [o];
      if ((0, Qr.isFlowBaseAnnotation)(o)) {
        i.set(o.type, o);
        continue;
      }
      if ((0, Qr.isUnionTypeAnnotation)(o)) {
        s.has(o.types) || (t.push(...o.types), s.add(o.types));
        continue;
      }
      if ((0, Qr.isGenericTypeAnnotation)(o)) {
        const l = Lc(o.id);
        if (r.has(l)) {
          let u = r.get(l);
          u.typeParameters ? o.typeParameters && (u.typeParameters.params.push(...o.typeParameters.params), u.typeParameters.params = Mc(u.typeParameters.params)) : u = o.typeParameters;
        } else
          r.set(l, o);
        continue;
      }
      n.push(o);
    }
  }
  for (const [, a] of i)
    n.push(a);
  for (const [, a] of r)
    n.push(a);
  return n;
}
var ol;
function rw() {
  if (ol)
    return Fi;
  ol = 1, Object.defineProperty(Fi, "__esModule", {
    value: !0
  }), Fi.default = r;
  var e = ht(), t = Cs;
  function r(i) {
    const s = (0, t.default)(i);
    return s.length === 1 ? s[0] : (0, e.unionTypeAnnotation)(s);
  }
  return Fi;
}
var ji = {}, va = {};
Object.defineProperty(va, "__esModule", {
  value: !0
});
va.default = Fc;
var Zr = m;
function Bc(e) {
  return (0, Zr.isIdentifier)(e) ? e.name : `${e.right.name}.${Bc(e.left)}`;
}
function Fc(e) {
  const t = Array.from(e), r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Set(), n = [];
  for (let a = 0; a < t.length; a++) {
    const o = t[a];
    if (o && !(n.indexOf(o) >= 0)) {
      if ((0, Zr.isTSAnyKeyword)(o))
        return [o];
      if ((0, Zr.isTSBaseType)(o)) {
        i.set(o.type, o);
        continue;
      }
      if ((0, Zr.isTSUnionType)(o)) {
        s.has(o.types) || (t.push(...o.types), s.add(o.types));
        continue;
      }
      if ((0, Zr.isTSTypeReference)(o) && o.typeParameters) {
        const l = Bc(o.typeName);
        if (r.has(l)) {
          let u = r.get(l);
          u.typeParameters ? o.typeParameters && (u.typeParameters.params.push(...o.typeParameters.params), u.typeParameters.params = Fc(u.typeParameters.params)) : u = o.typeParameters;
        } else
          r.set(l, o);
        continue;
      }
      n.push(o);
    }
  }
  for (const [, a] of i)
    n.push(a);
  for (const [, a] of r)
    n.push(a);
  return n;
}
var ll;
function iw() {
  if (ll)
    return ji;
  ll = 1, Object.defineProperty(ji, "__esModule", {
    value: !0
  }), ji.default = i;
  var e = ht(), t = va, r = m;
  function i(s) {
    const n = s.map((o) => (0, r.isTSTypeAnnotation)(o) ? o.typeAnnotation : o), a = (0, t.default)(n);
    return a.length === 1 ? a[0] : (0, e.tsUnionType)(a);
  }
  return ji;
}
var yn = {}, ul;
function sw() {
  return ul || (ul = 1, function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "AnyTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.anyTypeAnnotation;
      }
    }), Object.defineProperty(e, "ArgumentPlaceholder", {
      enumerable: !0,
      get: function() {
        return t.argumentPlaceholder;
      }
    }), Object.defineProperty(e, "ArrayExpression", {
      enumerable: !0,
      get: function() {
        return t.arrayExpression;
      }
    }), Object.defineProperty(e, "ArrayPattern", {
      enumerable: !0,
      get: function() {
        return t.arrayPattern;
      }
    }), Object.defineProperty(e, "ArrayTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.arrayTypeAnnotation;
      }
    }), Object.defineProperty(e, "ArrowFunctionExpression", {
      enumerable: !0,
      get: function() {
        return t.arrowFunctionExpression;
      }
    }), Object.defineProperty(e, "AssignmentExpression", {
      enumerable: !0,
      get: function() {
        return t.assignmentExpression;
      }
    }), Object.defineProperty(e, "AssignmentPattern", {
      enumerable: !0,
      get: function() {
        return t.assignmentPattern;
      }
    }), Object.defineProperty(e, "AwaitExpression", {
      enumerable: !0,
      get: function() {
        return t.awaitExpression;
      }
    }), Object.defineProperty(e, "BigIntLiteral", {
      enumerable: !0,
      get: function() {
        return t.bigIntLiteral;
      }
    }), Object.defineProperty(e, "BinaryExpression", {
      enumerable: !0,
      get: function() {
        return t.binaryExpression;
      }
    }), Object.defineProperty(e, "BindExpression", {
      enumerable: !0,
      get: function() {
        return t.bindExpression;
      }
    }), Object.defineProperty(e, "BlockStatement", {
      enumerable: !0,
      get: function() {
        return t.blockStatement;
      }
    }), Object.defineProperty(e, "BooleanLiteral", {
      enumerable: !0,
      get: function() {
        return t.booleanLiteral;
      }
    }), Object.defineProperty(e, "BooleanLiteralTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.booleanLiteralTypeAnnotation;
      }
    }), Object.defineProperty(e, "BooleanTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.booleanTypeAnnotation;
      }
    }), Object.defineProperty(e, "BreakStatement", {
      enumerable: !0,
      get: function() {
        return t.breakStatement;
      }
    }), Object.defineProperty(e, "CallExpression", {
      enumerable: !0,
      get: function() {
        return t.callExpression;
      }
    }), Object.defineProperty(e, "CatchClause", {
      enumerable: !0,
      get: function() {
        return t.catchClause;
      }
    }), Object.defineProperty(e, "ClassAccessorProperty", {
      enumerable: !0,
      get: function() {
        return t.classAccessorProperty;
      }
    }), Object.defineProperty(e, "ClassBody", {
      enumerable: !0,
      get: function() {
        return t.classBody;
      }
    }), Object.defineProperty(e, "ClassDeclaration", {
      enumerable: !0,
      get: function() {
        return t.classDeclaration;
      }
    }), Object.defineProperty(e, "ClassExpression", {
      enumerable: !0,
      get: function() {
        return t.classExpression;
      }
    }), Object.defineProperty(e, "ClassImplements", {
      enumerable: !0,
      get: function() {
        return t.classImplements;
      }
    }), Object.defineProperty(e, "ClassMethod", {
      enumerable: !0,
      get: function() {
        return t.classMethod;
      }
    }), Object.defineProperty(e, "ClassPrivateMethod", {
      enumerable: !0,
      get: function() {
        return t.classPrivateMethod;
      }
    }), Object.defineProperty(e, "ClassPrivateProperty", {
      enumerable: !0,
      get: function() {
        return t.classPrivateProperty;
      }
    }), Object.defineProperty(e, "ClassProperty", {
      enumerable: !0,
      get: function() {
        return t.classProperty;
      }
    }), Object.defineProperty(e, "ConditionalExpression", {
      enumerable: !0,
      get: function() {
        return t.conditionalExpression;
      }
    }), Object.defineProperty(e, "ContinueStatement", {
      enumerable: !0,
      get: function() {
        return t.continueStatement;
      }
    }), Object.defineProperty(e, "DebuggerStatement", {
      enumerable: !0,
      get: function() {
        return t.debuggerStatement;
      }
    }), Object.defineProperty(e, "DecimalLiteral", {
      enumerable: !0,
      get: function() {
        return t.decimalLiteral;
      }
    }), Object.defineProperty(e, "DeclareClass", {
      enumerable: !0,
      get: function() {
        return t.declareClass;
      }
    }), Object.defineProperty(e, "DeclareExportAllDeclaration", {
      enumerable: !0,
      get: function() {
        return t.declareExportAllDeclaration;
      }
    }), Object.defineProperty(e, "DeclareExportDeclaration", {
      enumerable: !0,
      get: function() {
        return t.declareExportDeclaration;
      }
    }), Object.defineProperty(e, "DeclareFunction", {
      enumerable: !0,
      get: function() {
        return t.declareFunction;
      }
    }), Object.defineProperty(e, "DeclareInterface", {
      enumerable: !0,
      get: function() {
        return t.declareInterface;
      }
    }), Object.defineProperty(e, "DeclareModule", {
      enumerable: !0,
      get: function() {
        return t.declareModule;
      }
    }), Object.defineProperty(e, "DeclareModuleExports", {
      enumerable: !0,
      get: function() {
        return t.declareModuleExports;
      }
    }), Object.defineProperty(e, "DeclareOpaqueType", {
      enumerable: !0,
      get: function() {
        return t.declareOpaqueType;
      }
    }), Object.defineProperty(e, "DeclareTypeAlias", {
      enumerable: !0,
      get: function() {
        return t.declareTypeAlias;
      }
    }), Object.defineProperty(e, "DeclareVariable", {
      enumerable: !0,
      get: function() {
        return t.declareVariable;
      }
    }), Object.defineProperty(e, "DeclaredPredicate", {
      enumerable: !0,
      get: function() {
        return t.declaredPredicate;
      }
    }), Object.defineProperty(e, "Decorator", {
      enumerable: !0,
      get: function() {
        return t.decorator;
      }
    }), Object.defineProperty(e, "Directive", {
      enumerable: !0,
      get: function() {
        return t.directive;
      }
    }), Object.defineProperty(e, "DirectiveLiteral", {
      enumerable: !0,
      get: function() {
        return t.directiveLiteral;
      }
    }), Object.defineProperty(e, "DoExpression", {
      enumerable: !0,
      get: function() {
        return t.doExpression;
      }
    }), Object.defineProperty(e, "DoWhileStatement", {
      enumerable: !0,
      get: function() {
        return t.doWhileStatement;
      }
    }), Object.defineProperty(e, "EmptyStatement", {
      enumerable: !0,
      get: function() {
        return t.emptyStatement;
      }
    }), Object.defineProperty(e, "EmptyTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.emptyTypeAnnotation;
      }
    }), Object.defineProperty(e, "EnumBooleanBody", {
      enumerable: !0,
      get: function() {
        return t.enumBooleanBody;
      }
    }), Object.defineProperty(e, "EnumBooleanMember", {
      enumerable: !0,
      get: function() {
        return t.enumBooleanMember;
      }
    }), Object.defineProperty(e, "EnumDeclaration", {
      enumerable: !0,
      get: function() {
        return t.enumDeclaration;
      }
    }), Object.defineProperty(e, "EnumDefaultedMember", {
      enumerable: !0,
      get: function() {
        return t.enumDefaultedMember;
      }
    }), Object.defineProperty(e, "EnumNumberBody", {
      enumerable: !0,
      get: function() {
        return t.enumNumberBody;
      }
    }), Object.defineProperty(e, "EnumNumberMember", {
      enumerable: !0,
      get: function() {
        return t.enumNumberMember;
      }
    }), Object.defineProperty(e, "EnumStringBody", {
      enumerable: !0,
      get: function() {
        return t.enumStringBody;
      }
    }), Object.defineProperty(e, "EnumStringMember", {
      enumerable: !0,
      get: function() {
        return t.enumStringMember;
      }
    }), Object.defineProperty(e, "EnumSymbolBody", {
      enumerable: !0,
      get: function() {
        return t.enumSymbolBody;
      }
    }), Object.defineProperty(e, "ExistsTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.existsTypeAnnotation;
      }
    }), Object.defineProperty(e, "ExportAllDeclaration", {
      enumerable: !0,
      get: function() {
        return t.exportAllDeclaration;
      }
    }), Object.defineProperty(e, "ExportDefaultDeclaration", {
      enumerable: !0,
      get: function() {
        return t.exportDefaultDeclaration;
      }
    }), Object.defineProperty(e, "ExportDefaultSpecifier", {
      enumerable: !0,
      get: function() {
        return t.exportDefaultSpecifier;
      }
    }), Object.defineProperty(e, "ExportNamedDeclaration", {
      enumerable: !0,
      get: function() {
        return t.exportNamedDeclaration;
      }
    }), Object.defineProperty(e, "ExportNamespaceSpecifier", {
      enumerable: !0,
      get: function() {
        return t.exportNamespaceSpecifier;
      }
    }), Object.defineProperty(e, "ExportSpecifier", {
      enumerable: !0,
      get: function() {
        return t.exportSpecifier;
      }
    }), Object.defineProperty(e, "ExpressionStatement", {
      enumerable: !0,
      get: function() {
        return t.expressionStatement;
      }
    }), Object.defineProperty(e, "File", {
      enumerable: !0,
      get: function() {
        return t.file;
      }
    }), Object.defineProperty(e, "ForInStatement", {
      enumerable: !0,
      get: function() {
        return t.forInStatement;
      }
    }), Object.defineProperty(e, "ForOfStatement", {
      enumerable: !0,
      get: function() {
        return t.forOfStatement;
      }
    }), Object.defineProperty(e, "ForStatement", {
      enumerable: !0,
      get: function() {
        return t.forStatement;
      }
    }), Object.defineProperty(e, "FunctionDeclaration", {
      enumerable: !0,
      get: function() {
        return t.functionDeclaration;
      }
    }), Object.defineProperty(e, "FunctionExpression", {
      enumerable: !0,
      get: function() {
        return t.functionExpression;
      }
    }), Object.defineProperty(e, "FunctionTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.functionTypeAnnotation;
      }
    }), Object.defineProperty(e, "FunctionTypeParam", {
      enumerable: !0,
      get: function() {
        return t.functionTypeParam;
      }
    }), Object.defineProperty(e, "GenericTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.genericTypeAnnotation;
      }
    }), Object.defineProperty(e, "Identifier", {
      enumerable: !0,
      get: function() {
        return t.identifier;
      }
    }), Object.defineProperty(e, "IfStatement", {
      enumerable: !0,
      get: function() {
        return t.ifStatement;
      }
    }), Object.defineProperty(e, "Import", {
      enumerable: !0,
      get: function() {
        return t.import;
      }
    }), Object.defineProperty(e, "ImportAttribute", {
      enumerable: !0,
      get: function() {
        return t.importAttribute;
      }
    }), Object.defineProperty(e, "ImportDeclaration", {
      enumerable: !0,
      get: function() {
        return t.importDeclaration;
      }
    }), Object.defineProperty(e, "ImportDefaultSpecifier", {
      enumerable: !0,
      get: function() {
        return t.importDefaultSpecifier;
      }
    }), Object.defineProperty(e, "ImportNamespaceSpecifier", {
      enumerable: !0,
      get: function() {
        return t.importNamespaceSpecifier;
      }
    }), Object.defineProperty(e, "ImportSpecifier", {
      enumerable: !0,
      get: function() {
        return t.importSpecifier;
      }
    }), Object.defineProperty(e, "IndexedAccessType", {
      enumerable: !0,
      get: function() {
        return t.indexedAccessType;
      }
    }), Object.defineProperty(e, "InferredPredicate", {
      enumerable: !0,
      get: function() {
        return t.inferredPredicate;
      }
    }), Object.defineProperty(e, "InterfaceDeclaration", {
      enumerable: !0,
      get: function() {
        return t.interfaceDeclaration;
      }
    }), Object.defineProperty(e, "InterfaceExtends", {
      enumerable: !0,
      get: function() {
        return t.interfaceExtends;
      }
    }), Object.defineProperty(e, "InterfaceTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.interfaceTypeAnnotation;
      }
    }), Object.defineProperty(e, "InterpreterDirective", {
      enumerable: !0,
      get: function() {
        return t.interpreterDirective;
      }
    }), Object.defineProperty(e, "IntersectionTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.intersectionTypeAnnotation;
      }
    }), Object.defineProperty(e, "JSXAttribute", {
      enumerable: !0,
      get: function() {
        return t.jsxAttribute;
      }
    }), Object.defineProperty(e, "JSXClosingElement", {
      enumerable: !0,
      get: function() {
        return t.jsxClosingElement;
      }
    }), Object.defineProperty(e, "JSXClosingFragment", {
      enumerable: !0,
      get: function() {
        return t.jsxClosingFragment;
      }
    }), Object.defineProperty(e, "JSXElement", {
      enumerable: !0,
      get: function() {
        return t.jsxElement;
      }
    }), Object.defineProperty(e, "JSXEmptyExpression", {
      enumerable: !0,
      get: function() {
        return t.jsxEmptyExpression;
      }
    }), Object.defineProperty(e, "JSXExpressionContainer", {
      enumerable: !0,
      get: function() {
        return t.jsxExpressionContainer;
      }
    }), Object.defineProperty(e, "JSXFragment", {
      enumerable: !0,
      get: function() {
        return t.jsxFragment;
      }
    }), Object.defineProperty(e, "JSXIdentifier", {
      enumerable: !0,
      get: function() {
        return t.jsxIdentifier;
      }
    }), Object.defineProperty(e, "JSXMemberExpression", {
      enumerable: !0,
      get: function() {
        return t.jsxMemberExpression;
      }
    }), Object.defineProperty(e, "JSXNamespacedName", {
      enumerable: !0,
      get: function() {
        return t.jsxNamespacedName;
      }
    }), Object.defineProperty(e, "JSXOpeningElement", {
      enumerable: !0,
      get: function() {
        return t.jsxOpeningElement;
      }
    }), Object.defineProperty(e, "JSXOpeningFragment", {
      enumerable: !0,
      get: function() {
        return t.jsxOpeningFragment;
      }
    }), Object.defineProperty(e, "JSXSpreadAttribute", {
      enumerable: !0,
      get: function() {
        return t.jsxSpreadAttribute;
      }
    }), Object.defineProperty(e, "JSXSpreadChild", {
      enumerable: !0,
      get: function() {
        return t.jsxSpreadChild;
      }
    }), Object.defineProperty(e, "JSXText", {
      enumerable: !0,
      get: function() {
        return t.jsxText;
      }
    }), Object.defineProperty(e, "LabeledStatement", {
      enumerable: !0,
      get: function() {
        return t.labeledStatement;
      }
    }), Object.defineProperty(e, "LogicalExpression", {
      enumerable: !0,
      get: function() {
        return t.logicalExpression;
      }
    }), Object.defineProperty(e, "MemberExpression", {
      enumerable: !0,
      get: function() {
        return t.memberExpression;
      }
    }), Object.defineProperty(e, "MetaProperty", {
      enumerable: !0,
      get: function() {
        return t.metaProperty;
      }
    }), Object.defineProperty(e, "MixedTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.mixedTypeAnnotation;
      }
    }), Object.defineProperty(e, "ModuleExpression", {
      enumerable: !0,
      get: function() {
        return t.moduleExpression;
      }
    }), Object.defineProperty(e, "NewExpression", {
      enumerable: !0,
      get: function() {
        return t.newExpression;
      }
    }), Object.defineProperty(e, "Noop", {
      enumerable: !0,
      get: function() {
        return t.noop;
      }
    }), Object.defineProperty(e, "NullLiteral", {
      enumerable: !0,
      get: function() {
        return t.nullLiteral;
      }
    }), Object.defineProperty(e, "NullLiteralTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.nullLiteralTypeAnnotation;
      }
    }), Object.defineProperty(e, "NullableTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.nullableTypeAnnotation;
      }
    }), Object.defineProperty(e, "NumberLiteral", {
      enumerable: !0,
      get: function() {
        return t.numberLiteral;
      }
    }), Object.defineProperty(e, "NumberLiteralTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.numberLiteralTypeAnnotation;
      }
    }), Object.defineProperty(e, "NumberTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.numberTypeAnnotation;
      }
    }), Object.defineProperty(e, "NumericLiteral", {
      enumerable: !0,
      get: function() {
        return t.numericLiteral;
      }
    }), Object.defineProperty(e, "ObjectExpression", {
      enumerable: !0,
      get: function() {
        return t.objectExpression;
      }
    }), Object.defineProperty(e, "ObjectMethod", {
      enumerable: !0,
      get: function() {
        return t.objectMethod;
      }
    }), Object.defineProperty(e, "ObjectPattern", {
      enumerable: !0,
      get: function() {
        return t.objectPattern;
      }
    }), Object.defineProperty(e, "ObjectProperty", {
      enumerable: !0,
      get: function() {
        return t.objectProperty;
      }
    }), Object.defineProperty(e, "ObjectTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.objectTypeAnnotation;
      }
    }), Object.defineProperty(e, "ObjectTypeCallProperty", {
      enumerable: !0,
      get: function() {
        return t.objectTypeCallProperty;
      }
    }), Object.defineProperty(e, "ObjectTypeIndexer", {
      enumerable: !0,
      get: function() {
        return t.objectTypeIndexer;
      }
    }), Object.defineProperty(e, "ObjectTypeInternalSlot", {
      enumerable: !0,
      get: function() {
        return t.objectTypeInternalSlot;
      }
    }), Object.defineProperty(e, "ObjectTypeProperty", {
      enumerable: !0,
      get: function() {
        return t.objectTypeProperty;
      }
    }), Object.defineProperty(e, "ObjectTypeSpreadProperty", {
      enumerable: !0,
      get: function() {
        return t.objectTypeSpreadProperty;
      }
    }), Object.defineProperty(e, "OpaqueType", {
      enumerable: !0,
      get: function() {
        return t.opaqueType;
      }
    }), Object.defineProperty(e, "OptionalCallExpression", {
      enumerable: !0,
      get: function() {
        return t.optionalCallExpression;
      }
    }), Object.defineProperty(e, "OptionalIndexedAccessType", {
      enumerable: !0,
      get: function() {
        return t.optionalIndexedAccessType;
      }
    }), Object.defineProperty(e, "OptionalMemberExpression", {
      enumerable: !0,
      get: function() {
        return t.optionalMemberExpression;
      }
    }), Object.defineProperty(e, "ParenthesizedExpression", {
      enumerable: !0,
      get: function() {
        return t.parenthesizedExpression;
      }
    }), Object.defineProperty(e, "PipelineBareFunction", {
      enumerable: !0,
      get: function() {
        return t.pipelineBareFunction;
      }
    }), Object.defineProperty(e, "PipelinePrimaryTopicReference", {
      enumerable: !0,
      get: function() {
        return t.pipelinePrimaryTopicReference;
      }
    }), Object.defineProperty(e, "PipelineTopicExpression", {
      enumerable: !0,
      get: function() {
        return t.pipelineTopicExpression;
      }
    }), Object.defineProperty(e, "Placeholder", {
      enumerable: !0,
      get: function() {
        return t.placeholder;
      }
    }), Object.defineProperty(e, "PrivateName", {
      enumerable: !0,
      get: function() {
        return t.privateName;
      }
    }), Object.defineProperty(e, "Program", {
      enumerable: !0,
      get: function() {
        return t.program;
      }
    }), Object.defineProperty(e, "QualifiedTypeIdentifier", {
      enumerable: !0,
      get: function() {
        return t.qualifiedTypeIdentifier;
      }
    }), Object.defineProperty(e, "RecordExpression", {
      enumerable: !0,
      get: function() {
        return t.recordExpression;
      }
    }), Object.defineProperty(e, "RegExpLiteral", {
      enumerable: !0,
      get: function() {
        return t.regExpLiteral;
      }
    }), Object.defineProperty(e, "RegexLiteral", {
      enumerable: !0,
      get: function() {
        return t.regexLiteral;
      }
    }), Object.defineProperty(e, "RestElement", {
      enumerable: !0,
      get: function() {
        return t.restElement;
      }
    }), Object.defineProperty(e, "RestProperty", {
      enumerable: !0,
      get: function() {
        return t.restProperty;
      }
    }), Object.defineProperty(e, "ReturnStatement", {
      enumerable: !0,
      get: function() {
        return t.returnStatement;
      }
    }), Object.defineProperty(e, "SequenceExpression", {
      enumerable: !0,
      get: function() {
        return t.sequenceExpression;
      }
    }), Object.defineProperty(e, "SpreadElement", {
      enumerable: !0,
      get: function() {
        return t.spreadElement;
      }
    }), Object.defineProperty(e, "SpreadProperty", {
      enumerable: !0,
      get: function() {
        return t.spreadProperty;
      }
    }), Object.defineProperty(e, "StaticBlock", {
      enumerable: !0,
      get: function() {
        return t.staticBlock;
      }
    }), Object.defineProperty(e, "StringLiteral", {
      enumerable: !0,
      get: function() {
        return t.stringLiteral;
      }
    }), Object.defineProperty(e, "StringLiteralTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.stringLiteralTypeAnnotation;
      }
    }), Object.defineProperty(e, "StringTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.stringTypeAnnotation;
      }
    }), Object.defineProperty(e, "Super", {
      enumerable: !0,
      get: function() {
        return t.super;
      }
    }), Object.defineProperty(e, "SwitchCase", {
      enumerable: !0,
      get: function() {
        return t.switchCase;
      }
    }), Object.defineProperty(e, "SwitchStatement", {
      enumerable: !0,
      get: function() {
        return t.switchStatement;
      }
    }), Object.defineProperty(e, "SymbolTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.symbolTypeAnnotation;
      }
    }), Object.defineProperty(e, "TSAnyKeyword", {
      enumerable: !0,
      get: function() {
        return t.tsAnyKeyword;
      }
    }), Object.defineProperty(e, "TSArrayType", {
      enumerable: !0,
      get: function() {
        return t.tsArrayType;
      }
    }), Object.defineProperty(e, "TSAsExpression", {
      enumerable: !0,
      get: function() {
        return t.tsAsExpression;
      }
    }), Object.defineProperty(e, "TSBigIntKeyword", {
      enumerable: !0,
      get: function() {
        return t.tsBigIntKeyword;
      }
    }), Object.defineProperty(e, "TSBooleanKeyword", {
      enumerable: !0,
      get: function() {
        return t.tsBooleanKeyword;
      }
    }), Object.defineProperty(e, "TSCallSignatureDeclaration", {
      enumerable: !0,
      get: function() {
        return t.tsCallSignatureDeclaration;
      }
    }), Object.defineProperty(e, "TSConditionalType", {
      enumerable: !0,
      get: function() {
        return t.tsConditionalType;
      }
    }), Object.defineProperty(e, "TSConstructSignatureDeclaration", {
      enumerable: !0,
      get: function() {
        return t.tsConstructSignatureDeclaration;
      }
    }), Object.defineProperty(e, "TSConstructorType", {
      enumerable: !0,
      get: function() {
        return t.tsConstructorType;
      }
    }), Object.defineProperty(e, "TSDeclareFunction", {
      enumerable: !0,
      get: function() {
        return t.tsDeclareFunction;
      }
    }), Object.defineProperty(e, "TSDeclareMethod", {
      enumerable: !0,
      get: function() {
        return t.tsDeclareMethod;
      }
    }), Object.defineProperty(e, "TSEnumDeclaration", {
      enumerable: !0,
      get: function() {
        return t.tsEnumDeclaration;
      }
    }), Object.defineProperty(e, "TSEnumMember", {
      enumerable: !0,
      get: function() {
        return t.tsEnumMember;
      }
    }), Object.defineProperty(e, "TSExportAssignment", {
      enumerable: !0,
      get: function() {
        return t.tsExportAssignment;
      }
    }), Object.defineProperty(e, "TSExpressionWithTypeArguments", {
      enumerable: !0,
      get: function() {
        return t.tsExpressionWithTypeArguments;
      }
    }), Object.defineProperty(e, "TSExternalModuleReference", {
      enumerable: !0,
      get: function() {
        return t.tsExternalModuleReference;
      }
    }), Object.defineProperty(e, "TSFunctionType", {
      enumerable: !0,
      get: function() {
        return t.tsFunctionType;
      }
    }), Object.defineProperty(e, "TSImportEqualsDeclaration", {
      enumerable: !0,
      get: function() {
        return t.tsImportEqualsDeclaration;
      }
    }), Object.defineProperty(e, "TSImportType", {
      enumerable: !0,
      get: function() {
        return t.tsImportType;
      }
    }), Object.defineProperty(e, "TSIndexSignature", {
      enumerable: !0,
      get: function() {
        return t.tsIndexSignature;
      }
    }), Object.defineProperty(e, "TSIndexedAccessType", {
      enumerable: !0,
      get: function() {
        return t.tsIndexedAccessType;
      }
    }), Object.defineProperty(e, "TSInferType", {
      enumerable: !0,
      get: function() {
        return t.tsInferType;
      }
    }), Object.defineProperty(e, "TSInstantiationExpression", {
      enumerable: !0,
      get: function() {
        return t.tsInstantiationExpression;
      }
    }), Object.defineProperty(e, "TSInterfaceBody", {
      enumerable: !0,
      get: function() {
        return t.tsInterfaceBody;
      }
    }), Object.defineProperty(e, "TSInterfaceDeclaration", {
      enumerable: !0,
      get: function() {
        return t.tsInterfaceDeclaration;
      }
    }), Object.defineProperty(e, "TSIntersectionType", {
      enumerable: !0,
      get: function() {
        return t.tsIntersectionType;
      }
    }), Object.defineProperty(e, "TSIntrinsicKeyword", {
      enumerable: !0,
      get: function() {
        return t.tsIntrinsicKeyword;
      }
    }), Object.defineProperty(e, "TSLiteralType", {
      enumerable: !0,
      get: function() {
        return t.tsLiteralType;
      }
    }), Object.defineProperty(e, "TSMappedType", {
      enumerable: !0,
      get: function() {
        return t.tsMappedType;
      }
    }), Object.defineProperty(e, "TSMethodSignature", {
      enumerable: !0,
      get: function() {
        return t.tsMethodSignature;
      }
    }), Object.defineProperty(e, "TSModuleBlock", {
      enumerable: !0,
      get: function() {
        return t.tsModuleBlock;
      }
    }), Object.defineProperty(e, "TSModuleDeclaration", {
      enumerable: !0,
      get: function() {
        return t.tsModuleDeclaration;
      }
    }), Object.defineProperty(e, "TSNamedTupleMember", {
      enumerable: !0,
      get: function() {
        return t.tsNamedTupleMember;
      }
    }), Object.defineProperty(e, "TSNamespaceExportDeclaration", {
      enumerable: !0,
      get: function() {
        return t.tsNamespaceExportDeclaration;
      }
    }), Object.defineProperty(e, "TSNeverKeyword", {
      enumerable: !0,
      get: function() {
        return t.tsNeverKeyword;
      }
    }), Object.defineProperty(e, "TSNonNullExpression", {
      enumerable: !0,
      get: function() {
        return t.tsNonNullExpression;
      }
    }), Object.defineProperty(e, "TSNullKeyword", {
      enumerable: !0,
      get: function() {
        return t.tsNullKeyword;
      }
    }), Object.defineProperty(e, "TSNumberKeyword", {
      enumerable: !0,
      get: function() {
        return t.tsNumberKeyword;
      }
    }), Object.defineProperty(e, "TSObjectKeyword", {
      enumerable: !0,
      get: function() {
        return t.tsObjectKeyword;
      }
    }), Object.defineProperty(e, "TSOptionalType", {
      enumerable: !0,
      get: function() {
        return t.tsOptionalType;
      }
    }), Object.defineProperty(e, "TSParameterProperty", {
      enumerable: !0,
      get: function() {
        return t.tsParameterProperty;
      }
    }), Object.defineProperty(e, "TSParenthesizedType", {
      enumerable: !0,
      get: function() {
        return t.tsParenthesizedType;
      }
    }), Object.defineProperty(e, "TSPropertySignature", {
      enumerable: !0,
      get: function() {
        return t.tsPropertySignature;
      }
    }), Object.defineProperty(e, "TSQualifiedName", {
      enumerable: !0,
      get: function() {
        return t.tsQualifiedName;
      }
    }), Object.defineProperty(e, "TSRestType", {
      enumerable: !0,
      get: function() {
        return t.tsRestType;
      }
    }), Object.defineProperty(e, "TSSatisfiesExpression", {
      enumerable: !0,
      get: function() {
        return t.tsSatisfiesExpression;
      }
    }), Object.defineProperty(e, "TSStringKeyword", {
      enumerable: !0,
      get: function() {
        return t.tsStringKeyword;
      }
    }), Object.defineProperty(e, "TSSymbolKeyword", {
      enumerable: !0,
      get: function() {
        return t.tsSymbolKeyword;
      }
    }), Object.defineProperty(e, "TSThisType", {
      enumerable: !0,
      get: function() {
        return t.tsThisType;
      }
    }), Object.defineProperty(e, "TSTupleType", {
      enumerable: !0,
      get: function() {
        return t.tsTupleType;
      }
    }), Object.defineProperty(e, "TSTypeAliasDeclaration", {
      enumerable: !0,
      get: function() {
        return t.tsTypeAliasDeclaration;
      }
    }), Object.defineProperty(e, "TSTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.tsTypeAnnotation;
      }
    }), Object.defineProperty(e, "TSTypeAssertion", {
      enumerable: !0,
      get: function() {
        return t.tsTypeAssertion;
      }
    }), Object.defineProperty(e, "TSTypeLiteral", {
      enumerable: !0,
      get: function() {
        return t.tsTypeLiteral;
      }
    }), Object.defineProperty(e, "TSTypeOperator", {
      enumerable: !0,
      get: function() {
        return t.tsTypeOperator;
      }
    }), Object.defineProperty(e, "TSTypeParameter", {
      enumerable: !0,
      get: function() {
        return t.tsTypeParameter;
      }
    }), Object.defineProperty(e, "TSTypeParameterDeclaration", {
      enumerable: !0,
      get: function() {
        return t.tsTypeParameterDeclaration;
      }
    }), Object.defineProperty(e, "TSTypeParameterInstantiation", {
      enumerable: !0,
      get: function() {
        return t.tsTypeParameterInstantiation;
      }
    }), Object.defineProperty(e, "TSTypePredicate", {
      enumerable: !0,
      get: function() {
        return t.tsTypePredicate;
      }
    }), Object.defineProperty(e, "TSTypeQuery", {
      enumerable: !0,
      get: function() {
        return t.tsTypeQuery;
      }
    }), Object.defineProperty(e, "TSTypeReference", {
      enumerable: !0,
      get: function() {
        return t.tsTypeReference;
      }
    }), Object.defineProperty(e, "TSUndefinedKeyword", {
      enumerable: !0,
      get: function() {
        return t.tsUndefinedKeyword;
      }
    }), Object.defineProperty(e, "TSUnionType", {
      enumerable: !0,
      get: function() {
        return t.tsUnionType;
      }
    }), Object.defineProperty(e, "TSUnknownKeyword", {
      enumerable: !0,
      get: function() {
        return t.tsUnknownKeyword;
      }
    }), Object.defineProperty(e, "TSVoidKeyword", {
      enumerable: !0,
      get: function() {
        return t.tsVoidKeyword;
      }
    }), Object.defineProperty(e, "TaggedTemplateExpression", {
      enumerable: !0,
      get: function() {
        return t.taggedTemplateExpression;
      }
    }), Object.defineProperty(e, "TemplateElement", {
      enumerable: !0,
      get: function() {
        return t.templateElement;
      }
    }), Object.defineProperty(e, "TemplateLiteral", {
      enumerable: !0,
      get: function() {
        return t.templateLiteral;
      }
    }), Object.defineProperty(e, "ThisExpression", {
      enumerable: !0,
      get: function() {
        return t.thisExpression;
      }
    }), Object.defineProperty(e, "ThisTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.thisTypeAnnotation;
      }
    }), Object.defineProperty(e, "ThrowStatement", {
      enumerable: !0,
      get: function() {
        return t.throwStatement;
      }
    }), Object.defineProperty(e, "TopicReference", {
      enumerable: !0,
      get: function() {
        return t.topicReference;
      }
    }), Object.defineProperty(e, "TryStatement", {
      enumerable: !0,
      get: function() {
        return t.tryStatement;
      }
    }), Object.defineProperty(e, "TupleExpression", {
      enumerable: !0,
      get: function() {
        return t.tupleExpression;
      }
    }), Object.defineProperty(e, "TupleTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.tupleTypeAnnotation;
      }
    }), Object.defineProperty(e, "TypeAlias", {
      enumerable: !0,
      get: function() {
        return t.typeAlias;
      }
    }), Object.defineProperty(e, "TypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.typeAnnotation;
      }
    }), Object.defineProperty(e, "TypeCastExpression", {
      enumerable: !0,
      get: function() {
        return t.typeCastExpression;
      }
    }), Object.defineProperty(e, "TypeParameter", {
      enumerable: !0,
      get: function() {
        return t.typeParameter;
      }
    }), Object.defineProperty(e, "TypeParameterDeclaration", {
      enumerable: !0,
      get: function() {
        return t.typeParameterDeclaration;
      }
    }), Object.defineProperty(e, "TypeParameterInstantiation", {
      enumerable: !0,
      get: function() {
        return t.typeParameterInstantiation;
      }
    }), Object.defineProperty(e, "TypeofTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.typeofTypeAnnotation;
      }
    }), Object.defineProperty(e, "UnaryExpression", {
      enumerable: !0,
      get: function() {
        return t.unaryExpression;
      }
    }), Object.defineProperty(e, "UnionTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.unionTypeAnnotation;
      }
    }), Object.defineProperty(e, "UpdateExpression", {
      enumerable: !0,
      get: function() {
        return t.updateExpression;
      }
    }), Object.defineProperty(e, "V8IntrinsicIdentifier", {
      enumerable: !0,
      get: function() {
        return t.v8IntrinsicIdentifier;
      }
    }), Object.defineProperty(e, "VariableDeclaration", {
      enumerable: !0,
      get: function() {
        return t.variableDeclaration;
      }
    }), Object.defineProperty(e, "VariableDeclarator", {
      enumerable: !0,
      get: function() {
        return t.variableDeclarator;
      }
    }), Object.defineProperty(e, "Variance", {
      enumerable: !0,
      get: function() {
        return t.variance;
      }
    }), Object.defineProperty(e, "VoidTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.voidTypeAnnotation;
      }
    }), Object.defineProperty(e, "WhileStatement", {
      enumerable: !0,
      get: function() {
        return t.whileStatement;
      }
    }), Object.defineProperty(e, "WithStatement", {
      enumerable: !0,
      get: function() {
        return t.withStatement;
      }
    }), Object.defineProperty(e, "YieldExpression", {
      enumerable: !0,
      get: function() {
        return t.yieldExpression;
      }
    });
    var t = ht();
  }(yn)), yn;
}
var jt = {};
Object.defineProperty(jt, "__esModule", {
  value: !0
});
jt.default = nw;
var cl = Et(), fl = m;
const Ct = Function.call.bind(Object.prototype.hasOwnProperty);
function pl(e, t, r, i) {
  return e && typeof e.type == "string" ? jc(e, t, r, i) : e;
}
function hl(e, t, r, i) {
  return Array.isArray(e) ? e.map((s) => pl(s, t, r, i)) : pl(e, t, r, i);
}
function nw(e, t = !0, r = !1) {
  return jc(e, t, r, /* @__PURE__ */ new Map());
}
function jc(e, t = !0, r = !1, i) {
  if (!e)
    return e;
  const {
    type: s
  } = e, n = {
    type: e.type
  };
  if ((0, fl.isIdentifier)(e))
    n.name = e.name, Ct(e, "optional") && typeof e.optional == "boolean" && (n.optional = e.optional), Ct(e, "typeAnnotation") && (n.typeAnnotation = t ? hl(e.typeAnnotation, !0, r, i) : e.typeAnnotation);
  else if (Ct(cl.NODE_FIELDS, s))
    for (const a of Object.keys(cl.NODE_FIELDS[s]))
      Ct(e, a) && (t ? n[a] = (0, fl.isFile)(e) && a === "comments" ? Ri(e.comments, t, r, i) : hl(e[a], !0, r, i) : n[a] = e[a]);
  else
    throw new Error(`Unknown node type: "${s}"`);
  return Ct(e, "loc") && (r ? n.loc = null : n.loc = e.loc), Ct(e, "leadingComments") && (n.leadingComments = Ri(e.leadingComments, t, r, i)), Ct(e, "innerComments") && (n.innerComments = Ri(e.innerComments, t, r, i)), Ct(e, "trailingComments") && (n.trailingComments = Ri(e.trailingComments, t, r, i)), Ct(e, "extra") && (n.extra = Object.assign({}, e.extra)), n;
}
function Ri(e, t, r, i) {
  return !e || !t ? e : e.map((s) => {
    const n = i.get(s);
    if (n)
      return n;
    const {
      type: a,
      value: o,
      loc: l
    } = s, u = {
      type: a,
      value: o,
      loc: l
    };
    return r && (u.loc = null), i.set(s, u), u;
  });
}
var Aa = {};
Object.defineProperty(Aa, "__esModule", {
  value: !0
});
Aa.default = ow;
var aw = jt;
function ow(e) {
  return (0, aw.default)(e, !1);
}
var Ca = {};
Object.defineProperty(Ca, "__esModule", {
  value: !0
});
Ca.default = uw;
var lw = jt;
function uw(e) {
  return (0, lw.default)(e);
}
var Ia = {};
Object.defineProperty(Ia, "__esModule", {
  value: !0
});
Ia.default = fw;
var cw = jt;
function fw(e) {
  return (0, cw.default)(e, !0, !0);
}
var wa = {};
Object.defineProperty(wa, "__esModule", {
  value: !0
});
wa.default = hw;
var pw = jt;
function hw(e) {
  return (0, pw.default)(e, !1, !0);
}
var Oa = {}, Is = {};
Object.defineProperty(Is, "__esModule", {
  value: !0
});
Is.default = dw;
function dw(e, t, r) {
  if (!r || !e)
    return e;
  const i = `${t}Comments`;
  return e[i] ? t === "leading" ? e[i] = r.concat(e[i]) : e[i].push(...r) : e[i] = r, e;
}
Object.defineProperty(Oa, "__esModule", {
  value: !0
});
Oa.default = yw;
var mw = Is;
function yw(e, t, r, i) {
  return (0, mw.default)(e, t, [{
    type: i ? "CommentLine" : "CommentBlock",
    value: r
  }]);
}
var ws = {}, yi = {};
Object.defineProperty(yi, "__esModule", {
  value: !0
});
yi.default = Tw;
function Tw(e, t, r) {
  t && r && (t[e] = Array.from(new Set([].concat(t[e], r[e]).filter(Boolean))));
}
Object.defineProperty(ws, "__esModule", {
  value: !0
});
ws.default = bw;
var Sw = yi;
function bw(e, t) {
  (0, Sw.default)("innerComments", e, t);
}
var Os = {};
Object.defineProperty(Os, "__esModule", {
  value: !0
});
Os.default = Ew;
var gw = yi;
function Ew(e, t) {
  (0, gw.default)("leadingComments", e, t);
}
var Ns = {}, _s = {};
Object.defineProperty(_s, "__esModule", {
  value: !0
});
_s.default = xw;
var Pw = yi;
function xw(e, t) {
  (0, Pw.default)("trailingComments", e, t);
}
Object.defineProperty(Ns, "__esModule", {
  value: !0
});
Ns.default = Iw;
var vw = _s, Aw = Os, Cw = ws;
function Iw(e, t) {
  return (0, vw.default)(e, t), (0, Aw.default)(e, t), (0, Cw.default)(e, t), e;
}
var Na = {};
Object.defineProperty(Na, "__esModule", {
  value: !0
});
Na.default = Ow;
var ww = Pe;
function Ow(e) {
  return ww.COMMENT_KEYS.forEach((t) => {
    e[t] = null;
  }), e;
}
var H = {};
Object.defineProperty(H, "__esModule", {
  value: !0
});
H.WHILE_TYPES = H.USERWHITESPACABLE_TYPES = H.UNARYLIKE_TYPES = H.TYPESCRIPT_TYPES = H.TSTYPE_TYPES = H.TSTYPEELEMENT_TYPES = H.TSENTITYNAME_TYPES = H.TSBASETYPE_TYPES = H.TERMINATORLESS_TYPES = H.STATEMENT_TYPES = H.STANDARDIZED_TYPES = H.SCOPABLE_TYPES = H.PUREISH_TYPES = H.PROPERTY_TYPES = H.PRIVATE_TYPES = H.PATTERN_TYPES = H.PATTERNLIKE_TYPES = H.OBJECTMEMBER_TYPES = H.MODULESPECIFIER_TYPES = H.MODULEDECLARATION_TYPES = H.MISCELLANEOUS_TYPES = H.METHOD_TYPES = H.LVAL_TYPES = H.LOOP_TYPES = H.LITERAL_TYPES = H.JSX_TYPES = H.IMPORTOREXPORTDECLARATION_TYPES = H.IMMUTABLE_TYPES = H.FUNCTION_TYPES = H.FUNCTIONPARENT_TYPES = H.FOR_TYPES = H.FORXSTATEMENT_TYPES = H.FLOW_TYPES = H.FLOWTYPE_TYPES = H.FLOWPREDICATE_TYPES = H.FLOWDECLARATION_TYPES = H.FLOWBASEANNOTATION_TYPES = H.EXPRESSION_TYPES = H.EXPRESSIONWRAPPER_TYPES = H.EXPORTDECLARATION_TYPES = H.ENUMMEMBER_TYPES = H.ENUMBODY_TYPES = H.DECLARATION_TYPES = H.CONDITIONAL_TYPES = H.COMPLETIONSTATEMENT_TYPES = H.CLASS_TYPES = H.BLOCK_TYPES = H.BLOCKPARENT_TYPES = H.BINARY_TYPES = H.ACCESSOR_TYPES = void 0;
var Ee = Et();
const Nw = Ee.FLIPPED_ALIAS_KEYS.Standardized;
H.STANDARDIZED_TYPES = Nw;
const _w = Ee.FLIPPED_ALIAS_KEYS.Expression;
H.EXPRESSION_TYPES = _w;
const Dw = Ee.FLIPPED_ALIAS_KEYS.Binary;
H.BINARY_TYPES = Dw;
const kw = Ee.FLIPPED_ALIAS_KEYS.Scopable;
H.SCOPABLE_TYPES = kw;
const Lw = Ee.FLIPPED_ALIAS_KEYS.BlockParent;
H.BLOCKPARENT_TYPES = Lw;
const Mw = Ee.FLIPPED_ALIAS_KEYS.Block;
H.BLOCK_TYPES = Mw;
const Bw = Ee.FLIPPED_ALIAS_KEYS.Statement;
H.STATEMENT_TYPES = Bw;
const Fw = Ee.FLIPPED_ALIAS_KEYS.Terminatorless;
H.TERMINATORLESS_TYPES = Fw;
const jw = Ee.FLIPPED_ALIAS_KEYS.CompletionStatement;
H.COMPLETIONSTATEMENT_TYPES = jw;
const Rw = Ee.FLIPPED_ALIAS_KEYS.Conditional;
H.CONDITIONAL_TYPES = Rw;
const $w = Ee.FLIPPED_ALIAS_KEYS.Loop;
H.LOOP_TYPES = $w;
const Uw = Ee.FLIPPED_ALIAS_KEYS.While;
H.WHILE_TYPES = Uw;
const Vw = Ee.FLIPPED_ALIAS_KEYS.ExpressionWrapper;
H.EXPRESSIONWRAPPER_TYPES = Vw;
const Kw = Ee.FLIPPED_ALIAS_KEYS.For;
H.FOR_TYPES = Kw;
const qw = Ee.FLIPPED_ALIAS_KEYS.ForXStatement;
H.FORXSTATEMENT_TYPES = qw;
const Ww = Ee.FLIPPED_ALIAS_KEYS.Function;
H.FUNCTION_TYPES = Ww;
const Yw = Ee.FLIPPED_ALIAS_KEYS.FunctionParent;
H.FUNCTIONPARENT_TYPES = Yw;
const Xw = Ee.FLIPPED_ALIAS_KEYS.Pureish;
H.PUREISH_TYPES = Xw;
const Jw = Ee.FLIPPED_ALIAS_KEYS.Declaration;
H.DECLARATION_TYPES = Jw;
const Hw = Ee.FLIPPED_ALIAS_KEYS.PatternLike;
H.PATTERNLIKE_TYPES = Hw;
const Gw = Ee.FLIPPED_ALIAS_KEYS.LVal;
H.LVAL_TYPES = Gw;
const zw = Ee.FLIPPED_ALIAS_KEYS.TSEntityName;
H.TSENTITYNAME_TYPES = zw;
const Qw = Ee.FLIPPED_ALIAS_KEYS.Literal;
H.LITERAL_TYPES = Qw;
const Zw = Ee.FLIPPED_ALIAS_KEYS.Immutable;
H.IMMUTABLE_TYPES = Zw;
const eO = Ee.FLIPPED_ALIAS_KEYS.UserWhitespacable;
H.USERWHITESPACABLE_TYPES = eO;
const tO = Ee.FLIPPED_ALIAS_KEYS.Method;
H.METHOD_TYPES = tO;
const rO = Ee.FLIPPED_ALIAS_KEYS.ObjectMember;
H.OBJECTMEMBER_TYPES = rO;
const iO = Ee.FLIPPED_ALIAS_KEYS.Property;
H.PROPERTY_TYPES = iO;
const sO = Ee.FLIPPED_ALIAS_KEYS.UnaryLike;
H.UNARYLIKE_TYPES = sO;
const nO = Ee.FLIPPED_ALIAS_KEYS.Pattern;
H.PATTERN_TYPES = nO;
const aO = Ee.FLIPPED_ALIAS_KEYS.Class;
H.CLASS_TYPES = aO;
const Rc = Ee.FLIPPED_ALIAS_KEYS.ImportOrExportDeclaration;
H.IMPORTOREXPORTDECLARATION_TYPES = Rc;
const oO = Ee.FLIPPED_ALIAS_KEYS.ExportDeclaration;
H.EXPORTDECLARATION_TYPES = oO;
const lO = Ee.FLIPPED_ALIAS_KEYS.ModuleSpecifier;
H.MODULESPECIFIER_TYPES = lO;
const uO = Ee.FLIPPED_ALIAS_KEYS.Accessor;
H.ACCESSOR_TYPES = uO;
const cO = Ee.FLIPPED_ALIAS_KEYS.Private;
H.PRIVATE_TYPES = cO;
const fO = Ee.FLIPPED_ALIAS_KEYS.Flow;
H.FLOW_TYPES = fO;
const pO = Ee.FLIPPED_ALIAS_KEYS.FlowType;
H.FLOWTYPE_TYPES = pO;
const hO = Ee.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation;
H.FLOWBASEANNOTATION_TYPES = hO;
const dO = Ee.FLIPPED_ALIAS_KEYS.FlowDeclaration;
H.FLOWDECLARATION_TYPES = dO;
const mO = Ee.FLIPPED_ALIAS_KEYS.FlowPredicate;
H.FLOWPREDICATE_TYPES = mO;
const yO = Ee.FLIPPED_ALIAS_KEYS.EnumBody;
H.ENUMBODY_TYPES = yO;
const TO = Ee.FLIPPED_ALIAS_KEYS.EnumMember;
H.ENUMMEMBER_TYPES = TO;
const SO = Ee.FLIPPED_ALIAS_KEYS.JSX;
H.JSX_TYPES = SO;
const bO = Ee.FLIPPED_ALIAS_KEYS.Miscellaneous;
H.MISCELLANEOUS_TYPES = bO;
const gO = Ee.FLIPPED_ALIAS_KEYS.TypeScript;
H.TYPESCRIPT_TYPES = gO;
const EO = Ee.FLIPPED_ALIAS_KEYS.TSTypeElement;
H.TSTYPEELEMENT_TYPES = EO;
const PO = Ee.FLIPPED_ALIAS_KEYS.TSType;
H.TSTYPE_TYPES = PO;
const xO = Ee.FLIPPED_ALIAS_KEYS.TSBaseType;
H.TSBASETYPE_TYPES = xO;
const vO = Rc;
H.MODULEDECLARATION_TYPES = vO;
var $i = {}, Ui = {}, dl;
function $c() {
  if (dl)
    return Ui;
  dl = 1, Object.defineProperty(Ui, "__esModule", {
    value: !0
  }), Ui.default = r;
  var e = m, t = ht();
  function r(i, s) {
    if ((0, e.isBlockStatement)(i))
      return i;
    let n = [];
    return (0, e.isEmptyStatement)(i) ? n = [] : ((0, e.isStatement)(i) || ((0, e.isFunction)(s) ? i = (0, t.returnStatement)(i) : i = (0, t.expressionStatement)(i)), n = [i]), (0, t.blockStatement)(n);
  }
  return Ui;
}
var ml;
function AO() {
  if (ml)
    return $i;
  ml = 1, Object.defineProperty($i, "__esModule", {
    value: !0
  }), $i.default = t;
  var e = $c();
  function t(r, i = "body") {
    const s = (0, e.default)(r[i], r);
    return r[i] = s, s;
  }
  return $i;
}
var _a = {}, Ds = {};
Object.defineProperty(Ds, "__esModule", {
  value: !0
});
Ds.default = wO;
var CO = hr, IO = pi;
function wO(e) {
  e = e + "";
  let t = "";
  for (const r of e)
    t += (0, IO.isIdentifierChar)(r.codePointAt(0)) ? r : "-";
  return t = t.replace(/^[-0-9]+/, ""), t = t.replace(/[-\s]+(.)?/g, function(r, i) {
    return i ? i.toUpperCase() : "";
  }), (0, CO.default)(t) || (t = `_${t}`), t || "_";
}
Object.defineProperty(_a, "__esModule", {
  value: !0
});
_a.default = NO;
var OO = Ds;
function NO(e) {
  return e = (0, OO.default)(e), (e === "eval" || e === "arguments") && (e = "_" + e), e;
}
var Vi = {}, yl;
function _O() {
  if (yl)
    return Vi;
  yl = 1, Object.defineProperty(Vi, "__esModule", {
    value: !0
  }), Vi.default = r;
  var e = m, t = ht();
  function r(i, s = i.key || i.property) {
    return !i.computed && (0, e.isIdentifier)(s) && (s = (0, t.stringLiteral)(s.name)), s;
  }
  return Vi;
}
var ks = {};
Object.defineProperty(ks, "__esModule", {
  value: !0
});
ks.default = void 0;
var qr = m, DO = kO;
ks.default = DO;
function kO(e) {
  if ((0, qr.isExpressionStatement)(e) && (e = e.expression), (0, qr.isExpression)(e))
    return e;
  if ((0, qr.isClass)(e) ? e.type = "ClassExpression" : (0, qr.isFunction)(e) && (e.type = "FunctionExpression"), !(0, qr.isExpression)(e))
    throw new Error(`cannot turn ${e.type} to an expression`);
  return e;
}
var Da = {}, Ls = {}, Ms = {};
Object.defineProperty(Ms, "__esModule", {
  value: !0
});
Ms.default = Rn;
var LO = Et();
function Rn(e, t, r) {
  if (!e)
    return;
  const i = LO.VISITOR_KEYS[e.type];
  if (i) {
    r = r || {}, t(e, r);
    for (const s of i) {
      const n = e[s];
      if (Array.isArray(n))
        for (const a of n)
          Rn(a, t, r);
      else
        Rn(n, t, r);
    }
  }
}
var Bs = {};
Object.defineProperty(Bs, "__esModule", {
  value: !0
});
Bs.default = FO;
var MO = Pe;
const Uc = ["tokens", "start", "end", "loc", "raw", "rawValue"], BO = [...MO.COMMENT_KEYS, "comments", ...Uc];
function FO(e, t = {}) {
  const r = t.preserveComments ? Uc : BO;
  for (const s of r)
    e[s] != null && (e[s] = void 0);
  for (const s of Object.keys(e))
    s[0] === "_" && e[s] != null && (e[s] = void 0);
  const i = Object.getOwnPropertySymbols(e);
  for (const s of i)
    e[s] = null;
}
Object.defineProperty(Ls, "__esModule", {
  value: !0
});
Ls.default = $O;
var jO = Ms, RO = Bs;
function $O(e, t) {
  return (0, jO.default)(e, RO.default, t), e;
}
Object.defineProperty(Da, "__esModule", {
  value: !0
});
Da.default = or;
var Tl = m, UO = jt, VO = Ls;
function or(e, t = e.key) {
  let r;
  return e.kind === "method" ? or.increment() + "" : ((0, Tl.isIdentifier)(t) ? r = t.name : (0, Tl.isStringLiteral)(t) ? r = JSON.stringify(t.value) : r = JSON.stringify((0, VO.default)((0, UO.default)(t))), e.computed && (r = `[${r}]`), e.static && (r = `static:${r}`), r);
}
or.uid = 0;
or.increment = function() {
  return or.uid >= Number.MAX_SAFE_INTEGER ? or.uid = 0 : or.uid++;
};
var Ki = {}, qi = {}, Br = {};
Object.defineProperty(Br, "__esModule", {
  value: !0
});
Br.default = ka;
var Pr = m;
function ka(e, t, r) {
  const i = [].concat(e), s = /* @__PURE__ */ Object.create(null);
  for (; i.length; ) {
    const n = i.shift();
    if (!n)
      continue;
    const a = ka.keys[n.type];
    if ((0, Pr.isIdentifier)(n)) {
      t ? (s[n.name] = s[n.name] || []).push(n) : s[n.name] = n;
      continue;
    }
    if ((0, Pr.isExportDeclaration)(n) && !(0, Pr.isExportAllDeclaration)(n)) {
      (0, Pr.isDeclaration)(n.declaration) && i.push(n.declaration);
      continue;
    }
    if (r) {
      if ((0, Pr.isFunctionDeclaration)(n)) {
        i.push(n.id);
        continue;
      }
      if ((0, Pr.isFunctionExpression)(n))
        continue;
    }
    if (a)
      for (let o = 0; o < a.length; o++) {
        const l = a[o], u = n[l];
        u && (Array.isArray(u) ? i.push(...u) : i.push(u));
      }
  }
  return s;
}
ka.keys = {
  DeclareClass: ["id"],
  DeclareFunction: ["id"],
  DeclareModule: ["id"],
  DeclareVariable: ["id"],
  DeclareInterface: ["id"],
  DeclareTypeAlias: ["id"],
  DeclareOpaqueType: ["id"],
  InterfaceDeclaration: ["id"],
  TypeAlias: ["id"],
  OpaqueType: ["id"],
  CatchClause: ["param"],
  LabeledStatement: ["label"],
  UnaryExpression: ["argument"],
  AssignmentExpression: ["left"],
  ImportSpecifier: ["local"],
  ImportNamespaceSpecifier: ["local"],
  ImportDefaultSpecifier: ["local"],
  ImportDeclaration: ["specifiers"],
  ExportSpecifier: ["exported"],
  ExportNamespaceSpecifier: ["exported"],
  ExportDefaultSpecifier: ["exported"],
  FunctionDeclaration: ["id", "params"],
  FunctionExpression: ["id", "params"],
  ArrowFunctionExpression: ["params"],
  ObjectMethod: ["params"],
  ClassMethod: ["params"],
  ClassPrivateMethod: ["params"],
  ForInStatement: ["left"],
  ForOfStatement: ["left"],
  ClassDeclaration: ["id"],
  ClassExpression: ["id"],
  RestElement: ["argument"],
  UpdateExpression: ["argument"],
  ObjectProperty: ["value"],
  AssignmentPattern: ["left"],
  ArrayPattern: ["elements"],
  ObjectPattern: ["properties"],
  VariableDeclaration: ["declarations"],
  VariableDeclarator: ["id"]
};
var Sl;
function KO() {
  if (Sl)
    return qi;
  Sl = 1, Object.defineProperty(qi, "__esModule", {
    value: !0
  }), qi.default = s;
  var e = Br, t = m, r = ht(), i = jt;
  function s(n, a, o) {
    const l = [];
    let u = !0;
    for (const c of n)
      if ((0, t.isEmptyStatement)(c) || (u = !1), (0, t.isExpression)(c))
        l.push(c);
      else if ((0, t.isExpressionStatement)(c))
        l.push(c.expression);
      else if ((0, t.isVariableDeclaration)(c)) {
        if (c.kind !== "var")
          return;
        for (const p of c.declarations) {
          const h = (0, e.default)(p);
          for (const y of Object.keys(h))
            o.push({
              kind: c.kind,
              id: (0, i.default)(h[y])
            });
          p.init && l.push((0, r.assignmentExpression)("=", p.id, p.init));
        }
        u = !0;
      } else if ((0, t.isIfStatement)(c)) {
        const p = c.consequent ? s([c.consequent], a, o) : a.buildUndefinedNode(), h = c.alternate ? s([c.alternate], a, o) : a.buildUndefinedNode();
        if (!p || !h)
          return;
        l.push((0, r.conditionalExpression)(c.test, p, h));
      } else if ((0, t.isBlockStatement)(c)) {
        const p = s(c.body, a, o);
        if (!p)
          return;
        l.push(p);
      } else if ((0, t.isEmptyStatement)(c))
        n.indexOf(c) === 0 && (u = !0);
      else
        return;
    return u && l.push(a.buildUndefinedNode()), l.length === 1 ? l[0] : (0, r.sequenceExpression)(l);
  }
  return qi;
}
var bl;
function qO() {
  if (bl)
    return Ki;
  bl = 1, Object.defineProperty(Ki, "__esModule", {
    value: !0
  }), Ki.default = t;
  var e = KO();
  function t(r, i) {
    if (!(r != null && r.length))
      return;
    const s = [], n = (0, e.default)(r, i, s);
    if (n) {
      for (const a of s)
        i.push(a);
      return n;
    }
  }
  return Ki;
}
var Wr = {}, gl;
function WO() {
  if (gl)
    return Wr;
  gl = 1, Object.defineProperty(Wr, "__esModule", {
    value: !0
  }), Wr.default = void 0;
  var e = m, t = ht(), r = i;
  Wr.default = r;
  function i(s, n) {
    if ((0, e.isStatement)(s))
      return s;
    let a = !1, o;
    if ((0, e.isClass)(s))
      a = !0, o = "ClassDeclaration";
    else if ((0, e.isFunction)(s))
      a = !0, o = "FunctionDeclaration";
    else if ((0, e.isAssignmentExpression)(s))
      return (0, t.expressionStatement)(s);
    if (a && !s.id && (o = !1), !o) {
      if (n)
        return !1;
      throw new Error(`cannot turn ${s.type} to a statement`);
    }
    return s.type = o, s;
  }
  return Wr;
}
var Yr = {}, El;
function YO() {
  if (El)
    return Yr;
  El = 1, Object.defineProperty(Yr, "__esModule", {
    value: !0
  }), Yr.default = void 0;
  var e = hr, t = ht(), r = a;
  Yr.default = r;
  const i = Function.call.bind(Object.prototype.toString);
  function s(o) {
    return i(o) === "[object RegExp]";
  }
  function n(o) {
    if (typeof o != "object" || o === null || Object.prototype.toString.call(o) !== "[object Object]")
      return !1;
    const l = Object.getPrototypeOf(o);
    return l === null || Object.getPrototypeOf(l) === null;
  }
  function a(o) {
    if (o === void 0)
      return (0, t.identifier)("undefined");
    if (o === !0 || o === !1)
      return (0, t.booleanLiteral)(o);
    if (o === null)
      return (0, t.nullLiteral)();
    if (typeof o == "string")
      return (0, t.stringLiteral)(o);
    if (typeof o == "number") {
      let l;
      if (Number.isFinite(o))
        l = (0, t.numericLiteral)(Math.abs(o));
      else {
        let u;
        Number.isNaN(o) ? u = (0, t.numericLiteral)(0) : u = (0, t.numericLiteral)(1), l = (0, t.binaryExpression)("/", u, (0, t.numericLiteral)(0));
      }
      return (o < 0 || Object.is(o, -0)) && (l = (0, t.unaryExpression)("-", l)), l;
    }
    if (s(o)) {
      const l = o.source, u = o.toString().match(/\/([a-z]+|)$/)[1];
      return (0, t.regExpLiteral)(l, u);
    }
    if (Array.isArray(o))
      return (0, t.arrayExpression)(o.map(a));
    if (n(o)) {
      const l = [];
      for (const u of Object.keys(o)) {
        let c;
        (0, e.default)(u) ? c = (0, t.identifier)(u) : c = (0, t.stringLiteral)(u), l.push((0, t.objectProperty)(c, a(o[u])));
      }
      return (0, t.objectExpression)(l);
    }
    throw new Error("don't know how to turn this value into a node");
  }
  return Yr;
}
var Wi = {}, Pl;
function XO() {
  if (Pl)
    return Wi;
  Pl = 1, Object.defineProperty(Wi, "__esModule", {
    value: !0
  }), Wi.default = t;
  var e = ht();
  function t(r, i, s = !1) {
    return r.object = (0, e.memberExpression)(r.object, r.property, r.computed), r.property = i, r.computed = !!s, r;
  }
  return Wi;
}
var La = {};
Object.defineProperty(La, "__esModule", {
  value: !0
});
La.default = HO;
var xl = Pe, JO = Ns;
function HO(e, t) {
  if (!e || !t)
    return e;
  for (const r of xl.INHERIT_KEYS.optional)
    e[r] == null && (e[r] = t[r]);
  for (const r of Object.keys(t))
    r[0] === "_" && r !== "__clone" && (e[r] = t[r]);
  for (const r of xl.INHERIT_KEYS.force)
    e[r] = t[r];
  return (0, JO.default)(e, t), e;
}
var Yi = {}, vl;
function GO() {
  if (vl)
    return Yi;
  vl = 1, Object.defineProperty(Yi, "__esModule", {
    value: !0
  }), Yi.default = r;
  var e = ht(), t = Ae();
  function r(i, s) {
    if ((0, t.isSuper)(i.object))
      throw new Error("Cannot prepend node to super property access (`super.foo`).");
    return i.object = (0, e.memberExpression)(s, i.object), i;
  }
  return Yi;
}
var Fs = {};
Object.defineProperty(Fs, "__esModule", {
  value: !0
});
Fs.default = void 0;
var zO = Br, QO = ZO;
Fs.default = QO;
function ZO(e, t) {
  return (0, zO.default)(e, t, !0);
}
var Ma = {};
Object.defineProperty(Ma, "__esModule", {
  value: !0
});
Ma.default = tN;
var eN = Et();
function tN(e, t, r) {
  typeof t == "function" && (t = {
    enter: t
  });
  const {
    enter: i,
    exit: s
  } = t;
  $n(e, i, s, r, []);
}
function $n(e, t, r, i, s) {
  const n = eN.VISITOR_KEYS[e.type];
  if (n) {
    t && t(e, s, i);
    for (const a of n) {
      const o = e[a];
      if (Array.isArray(o))
        for (let l = 0; l < o.length; l++) {
          const u = o[l];
          u && (s.push({
            node: e,
            key: a,
            index: l
          }), $n(u, t, r, i, s), s.pop());
        }
      else
        o && (s.push({
          node: e,
          key: a
        }), $n(o, t, r, i, s), s.pop());
    }
    r && r(e, s, i);
  }
}
var Ba = {};
Object.defineProperty(Ba, "__esModule", {
  value: !0
});
Ba.default = iN;
var rN = Br;
function iN(e, t, r) {
  if (r && e.type === "Identifier" && t.type === "ObjectProperty" && r.type === "ObjectExpression")
    return !1;
  const i = rN.default.keys[t.type];
  if (i)
    for (let s = 0; s < i.length; s++) {
      const n = i[s], a = t[n];
      if (Array.isArray(a)) {
        if (a.indexOf(e) >= 0)
          return !0;
      } else if (a === e)
        return !0;
    }
  return !1;
}
var Fa = {}, js = {};
Object.defineProperty(js, "__esModule", {
  value: !0
});
js.default = aN;
var sN = m, nN = Pe;
function aN(e) {
  return (0, sN.isVariableDeclaration)(e) && (e.kind !== "var" || e[nN.BLOCK_SCOPED_SYMBOL]);
}
Object.defineProperty(Fa, "__esModule", {
  value: !0
});
Fa.default = lN;
var Al = m, oN = js;
function lN(e) {
  return (0, Al.isFunctionDeclaration)(e) || (0, Al.isClassDeclaration)(e) || (0, oN.default)(e);
}
var ja = {};
Object.defineProperty(ja, "__esModule", {
  value: !0
});
ja.default = fN;
var uN = Sa(), cN = m;
function fN(e) {
  return (0, uN.default)(e.type, "Immutable") ? !0 : (0, cN.isIdentifier)(e) ? e.name === "undefined" : !1;
}
var Ra = {};
Object.defineProperty(Ra, "__esModule", {
  value: !0
});
Ra.default = Un;
var Cl = Et();
function Un(e, t) {
  if (typeof e != "object" || typeof t != "object" || e == null || t == null)
    return e === t;
  if (e.type !== t.type)
    return !1;
  const r = Object.keys(Cl.NODE_FIELDS[e.type] || e.type), i = Cl.VISITOR_KEYS[e.type];
  for (const s of r) {
    const n = e[s], a = t[s];
    if (typeof n != typeof a)
      return !1;
    if (!(n == null && a == null)) {
      if (n == null || a == null)
        return !1;
      if (Array.isArray(n)) {
        if (!Array.isArray(a) || n.length !== a.length)
          return !1;
        for (let o = 0; o < n.length; o++)
          if (!Un(n[o], a[o]))
            return !1;
        continue;
      }
      if (typeof n == "object" && !(i != null && i.includes(s))) {
        for (const o of Object.keys(n))
          if (n[o] !== a[o])
            return !1;
        continue;
      }
      if (!Un(n, a))
        return !1;
    }
  }
  return !0;
}
var $a = {};
Object.defineProperty($a, "__esModule", {
  value: !0
});
$a.default = pN;
function pN(e, t, r) {
  switch (t.type) {
    case "MemberExpression":
    case "OptionalMemberExpression":
      return t.property === e ? !!t.computed : t.object === e;
    case "JSXMemberExpression":
      return t.object === e;
    case "VariableDeclarator":
      return t.init === e;
    case "ArrowFunctionExpression":
      return t.body === e;
    case "PrivateName":
      return !1;
    case "ClassMethod":
    case "ClassPrivateMethod":
    case "ObjectMethod":
      return t.key === e ? !!t.computed : !1;
    case "ObjectProperty":
      return t.key === e ? !!t.computed : !r || r.type !== "ObjectPattern";
    case "ClassProperty":
    case "ClassAccessorProperty":
      return t.key === e ? !!t.computed : !0;
    case "ClassPrivateProperty":
      return t.key !== e;
    case "ClassDeclaration":
    case "ClassExpression":
      return t.superClass === e;
    case "AssignmentExpression":
      return t.right === e;
    case "AssignmentPattern":
      return t.right === e;
    case "LabeledStatement":
      return !1;
    case "CatchClause":
      return !1;
    case "RestElement":
      return !1;
    case "BreakStatement":
    case "ContinueStatement":
      return !1;
    case "FunctionDeclaration":
    case "FunctionExpression":
      return !1;
    case "ExportNamespaceSpecifier":
    case "ExportDefaultSpecifier":
      return !1;
    case "ExportSpecifier":
      return r != null && r.source ? !1 : t.local === e;
    case "ImportDefaultSpecifier":
    case "ImportNamespaceSpecifier":
    case "ImportSpecifier":
      return !1;
    case "ImportAttribute":
      return !1;
    case "JSXAttribute":
      return !1;
    case "ObjectPattern":
    case "ArrayPattern":
      return !1;
    case "MetaProperty":
      return !1;
    case "ObjectTypeProperty":
      return t.key !== e;
    case "TSEnumMember":
      return t.id !== e;
    case "TSPropertySignature":
      return t.key === e ? !!t.computed : !0;
  }
  return !0;
}
var Ua = {};
Object.defineProperty(Ua, "__esModule", {
  value: !0
});
Ua.default = hN;
var sr = m;
function hN(e, t) {
  return (0, sr.isBlockStatement)(e) && ((0, sr.isFunction)(t) || (0, sr.isCatchClause)(t)) ? !1 : (0, sr.isPattern)(e) && ((0, sr.isFunction)(t) || (0, sr.isCatchClause)(t)) ? !0 : (0, sr.isScopable)(e);
}
var Va = {};
Object.defineProperty(Va, "__esModule", {
  value: !0
});
Va.default = dN;
var Il = m;
function dN(e) {
  return (0, Il.isImportDefaultSpecifier)(e) || (0, Il.isIdentifier)(e.imported || e.exported, {
    name: "default"
  });
}
var Ka = {};
Object.defineProperty(Ka, "__esModule", {
  value: !0
});
Ka.default = TN;
var mN = hr;
const yN = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
function TN(e) {
  return (0, mN.default)(e) && !yN.has(e);
}
var qa = {};
Object.defineProperty(qa, "__esModule", {
  value: !0
});
qa.default = gN;
var SN = m, bN = Pe;
function gN(e) {
  return (0, SN.isVariableDeclaration)(e, {
    kind: "var"
  }) && !e[bN.BLOCK_SCOPED_SYMBOL];
}
var wl;
function Ae() {
  return wl || (wl = 1, function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    });
    var t = {
      react: !0,
      assertNode: !0,
      createTypeAnnotationBasedOnTypeof: !0,
      createUnionTypeAnnotation: !0,
      createFlowUnionType: !0,
      createTSUnionType: !0,
      cloneNode: !0,
      clone: !0,
      cloneDeep: !0,
      cloneDeepWithoutLoc: !0,
      cloneWithoutLoc: !0,
      addComment: !0,
      addComments: !0,
      inheritInnerComments: !0,
      inheritLeadingComments: !0,
      inheritsComments: !0,
      inheritTrailingComments: !0,
      removeComments: !0,
      ensureBlock: !0,
      toBindingIdentifierName: !0,
      toBlock: !0,
      toComputedKey: !0,
      toExpression: !0,
      toIdentifier: !0,
      toKeyAlias: !0,
      toSequenceExpression: !0,
      toStatement: !0,
      valueToNode: !0,
      appendToMemberExpression: !0,
      inherits: !0,
      prependToMemberExpression: !0,
      removeProperties: !0,
      removePropertiesDeep: !0,
      removeTypeDuplicates: !0,
      getBindingIdentifiers: !0,
      getOuterBindingIdentifiers: !0,
      traverse: !0,
      traverseFast: !0,
      shallowEqual: !0,
      is: !0,
      isBinding: !0,
      isBlockScoped: !0,
      isImmutable: !0,
      isLet: !0,
      isNode: !0,
      isNodesEquivalent: !0,
      isPlaceholderType: !0,
      isReferenced: !0,
      isScope: !0,
      isSpecifierDefault: !0,
      isType: !0,
      isValidES3Identifier: !0,
      isValidIdentifier: !0,
      isVar: !0,
      matchesPattern: !0,
      validate: !0,
      buildMatchMemberExpression: !0,
      __internal__deprecationWarning: !0
    };
    Object.defineProperty(e, "__internal__deprecationWarning", {
      enumerable: !0,
      get: function() {
        return tt.default;
      }
    }), Object.defineProperty(e, "addComment", {
      enumerable: !0,
      get: function() {
        return x.default;
      }
    }), Object.defineProperty(e, "addComments", {
      enumerable: !0,
      get: function() {
        return O.default;
      }
    }), Object.defineProperty(e, "appendToMemberExpression", {
      enumerable: !0,
      get: function() {
        return ae.default;
      }
    }), Object.defineProperty(e, "assertNode", {
      enumerable: !0,
      get: function() {
        return n.default;
      }
    }), Object.defineProperty(e, "buildMatchMemberExpression", {
      enumerable: !0,
      get: function() {
        return ot.default;
      }
    }), Object.defineProperty(e, "clone", {
      enumerable: !0,
      get: function() {
        return y.default;
      }
    }), Object.defineProperty(e, "cloneDeep", {
      enumerable: !0,
      get: function() {
        return P.default;
      }
    }), Object.defineProperty(e, "cloneDeepWithoutLoc", {
      enumerable: !0,
      get: function() {
        return v.default;
      }
    }), Object.defineProperty(e, "cloneNode", {
      enumerable: !0,
      get: function() {
        return h.default;
      }
    }), Object.defineProperty(e, "cloneWithoutLoc", {
      enumerable: !0,
      get: function() {
        return w.default;
      }
    }), Object.defineProperty(e, "createFlowUnionType", {
      enumerable: !0,
      get: function() {
        return l.default;
      }
    }), Object.defineProperty(e, "createTSUnionType", {
      enumerable: !0,
      get: function() {
        return u.default;
      }
    }), Object.defineProperty(e, "createTypeAnnotationBasedOnTypeof", {
      enumerable: !0,
      get: function() {
        return o.default;
      }
    }), Object.defineProperty(e, "createUnionTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return l.default;
      }
    }), Object.defineProperty(e, "ensureBlock", {
      enumerable: !0,
      get: function() {
        return te.default;
      }
    }), Object.defineProperty(e, "getBindingIdentifiers", {
      enumerable: !0,
      get: function() {
        return He.default;
      }
    }), Object.defineProperty(e, "getOuterBindingIdentifiers", {
      enumerable: !0,
      get: function() {
        return We.default;
      }
    }), Object.defineProperty(e, "inheritInnerComments", {
      enumerable: !0,
      get: function() {
        return _.default;
      }
    }), Object.defineProperty(e, "inheritLeadingComments", {
      enumerable: !0,
      get: function() {
        return K.default;
      }
    }), Object.defineProperty(e, "inheritTrailingComments", {
      enumerable: !0,
      get: function() {
        return B.default;
      }
    }), Object.defineProperty(e, "inherits", {
      enumerable: !0,
      get: function() {
        return ie.default;
      }
    }), Object.defineProperty(e, "inheritsComments", {
      enumerable: !0,
      get: function() {
        return R.default;
      }
    }), Object.defineProperty(e, "is", {
      enumerable: !0,
      get: function() {
        return ee.default;
      }
    }), Object.defineProperty(e, "isBinding", {
      enumerable: !0,
      get: function() {
        return Se.default;
      }
    }), Object.defineProperty(e, "isBlockScoped", {
      enumerable: !0,
      get: function() {
        return oe.default;
      }
    }), Object.defineProperty(e, "isImmutable", {
      enumerable: !0,
      get: function() {
        return ye.default;
      }
    }), Object.defineProperty(e, "isLet", {
      enumerable: !0,
      get: function() {
        return Q.default;
      }
    }), Object.defineProperty(e, "isNode", {
      enumerable: !0,
      get: function() {
        return pe.default;
      }
    }), Object.defineProperty(e, "isNodesEquivalent", {
      enumerable: !0,
      get: function() {
        return ve.default;
      }
    }), Object.defineProperty(e, "isPlaceholderType", {
      enumerable: !0,
      get: function() {
        return De.default;
      }
    }), Object.defineProperty(e, "isReferenced", {
      enumerable: !0,
      get: function() {
        return $.default;
      }
    }), Object.defineProperty(e, "isScope", {
      enumerable: !0,
      get: function() {
        return S.default;
      }
    }), Object.defineProperty(e, "isSpecifierDefault", {
      enumerable: !0,
      get: function() {
        return I.default;
      }
    }), Object.defineProperty(e, "isType", {
      enumerable: !0,
      get: function() {
        return U.default;
      }
    }), Object.defineProperty(e, "isValidES3Identifier", {
      enumerable: !0,
      get: function() {
        return G.default;
      }
    }), Object.defineProperty(e, "isValidIdentifier", {
      enumerable: !0,
      get: function() {
        return ue.default;
      }
    }), Object.defineProperty(e, "isVar", {
      enumerable: !0,
      get: function() {
        return xe.default;
      }
    }), Object.defineProperty(e, "matchesPattern", {
      enumerable: !0,
      get: function() {
        return Ge.default;
      }
    }), Object.defineProperty(e, "prependToMemberExpression", {
      enumerable: !0,
      get: function() {
        return ge.default;
      }
    }), e.react = void 0, Object.defineProperty(e, "removeComments", {
      enumerable: !0,
      get: function() {
        return C.default;
      }
    }), Object.defineProperty(e, "removeProperties", {
      enumerable: !0,
      get: function() {
        return Ce.default;
      }
    }), Object.defineProperty(e, "removePropertiesDeep", {
      enumerable: !0,
      get: function() {
        return je.default;
      }
    }), Object.defineProperty(e, "removeTypeDuplicates", {
      enumerable: !0,
      get: function() {
        return Je.default;
      }
    }), Object.defineProperty(e, "shallowEqual", {
      enumerable: !0,
      get: function() {
        return z.default;
      }
    }), Object.defineProperty(e, "toBindingIdentifierName", {
      enumerable: !0,
      get: function() {
        return Z.default;
      }
    }), Object.defineProperty(e, "toBlock", {
      enumerable: !0,
      get: function() {
        return J.default;
      }
    }), Object.defineProperty(e, "toComputedKey", {
      enumerable: !0,
      get: function() {
        return ce.default;
      }
    }), Object.defineProperty(e, "toExpression", {
      enumerable: !0,
      get: function() {
        return me.default;
      }
    }), Object.defineProperty(e, "toIdentifier", {
      enumerable: !0,
      get: function() {
        return k.default;
      }
    }), Object.defineProperty(e, "toKeyAlias", {
      enumerable: !0,
      get: function() {
        return M.default;
      }
    }), Object.defineProperty(e, "toSequenceExpression", {
      enumerable: !0,
      get: function() {
        return D.default;
      }
    }), Object.defineProperty(e, "toStatement", {
      enumerable: !0,
      get: function() {
        return j.default;
      }
    }), Object.defineProperty(e, "traverse", {
      enumerable: !0,
      get: function() {
        return Y.default;
      }
    }), Object.defineProperty(e, "traverseFast", {
      enumerable: !0,
      get: function() {
        return V.default;
      }
    }), Object.defineProperty(e, "validate", {
      enumerable: !0,
      get: function() {
        return et.default;
      }
    }), Object.defineProperty(e, "valueToNode", {
      enumerable: !0,
      get: function() {
        return X.default;
      }
    });
    var r = Es, i = Ta, s = yx(), n = xa, a = T;
    Object.keys(a).forEach(function(re) {
      re === "default" || re === "__esModule" || Object.prototype.hasOwnProperty.call(t, re) || re in e && e[re] === a[re] || Object.defineProperty(e, re, {
        enumerable: !0,
        get: function() {
          return a[re];
        }
      });
    });
    var o = tw(), l = rw(), u = iw(), c = ht();
    Object.keys(c).forEach(function(re) {
      re === "default" || re === "__esModule" || Object.prototype.hasOwnProperty.call(t, re) || re in e && e[re] === c[re] || Object.defineProperty(e, re, {
        enumerable: !0,
        get: function() {
          return c[re];
        }
      });
    });
    var p = sw();
    Object.keys(p).forEach(function(re) {
      re === "default" || re === "__esModule" || Object.prototype.hasOwnProperty.call(t, re) || re in e && e[re] === p[re] || Object.defineProperty(e, re, {
        enumerable: !0,
        get: function() {
          return p[re];
        }
      });
    });
    var h = jt, y = Aa, P = Ca, v = Ia, w = wa, x = Oa, O = Is, _ = ws, K = Os, R = Ns, B = _s, C = Na, L = H;
    Object.keys(L).forEach(function(re) {
      re === "default" || re === "__esModule" || Object.prototype.hasOwnProperty.call(t, re) || re in e && e[re] === L[re] || Object.defineProperty(e, re, {
        enumerable: !0,
        get: function() {
          return L[re];
        }
      });
    });
    var F = Pe;
    Object.keys(F).forEach(function(re) {
      re === "default" || re === "__esModule" || Object.prototype.hasOwnProperty.call(t, re) || re in e && e[re] === F[re] || Object.defineProperty(e, re, {
        enumerable: !0,
        get: function() {
          return F[re];
        }
      });
    });
    var te = AO(), Z = _a, J = $c(), ce = _O(), me = ks, k = Ds, M = Da, D = qO(), j = WO(), X = YO(), W = Et();
    Object.keys(W).forEach(function(re) {
      re === "default" || re === "__esModule" || Object.prototype.hasOwnProperty.call(t, re) || re in e && e[re] === W[re] || Object.defineProperty(e, re, {
        enumerable: !0,
        get: function() {
          return W[re];
        }
      });
    });
    var ae = XO(), ie = La, ge = GO(), Ce = Bs, je = Ls, Je = Cs, He = Br, We = Fs, Y = Ma;
    Object.keys(Y).forEach(function(re) {
      re === "default" || re === "__esModule" || Object.prototype.hasOwnProperty.call(t, re) || re in e && e[re] === Y[re] || Object.defineProperty(e, re, {
        enumerable: !0,
        get: function() {
          return Y[re];
        }
      });
    });
    var V = Ms, z = ui, ee = fi(), Se = Ba, oe = Fa, ye = ja, Q = js, pe = As, ve = Ra, De = dc(), $ = $a, S = Ua, I = Va, U = Sa(), G = Ka, ue = hr, xe = qa, Ge = xs, et = Pa(), ot = Ps, ct = m;
    Object.keys(ct).forEach(function(re) {
      re === "default" || re === "__esModule" || Object.prototype.hasOwnProperty.call(t, re) || re in e && e[re] === ct[re] || Object.defineProperty(e, re, {
        enumerable: !0,
        get: function() {
          return ct[re];
        }
      });
    });
    var tt = Mr;
    const ft = {
      isReactComponent: r.default,
      isCompatTag: i.default,
      buildChildren: s.default
    };
    e.react = ft;
  }(hn)), hn;
}
Object.defineProperty(Ft, "__esModule", {
  value: !0
});
Ft.explode = qc;
Ft.isExplodedVisitor = Kc;
Ft.merge = vN;
Ft.verify = Wc;
var Vc = we, EN = Ae();
const {
  DEPRECATED_KEYS: Ol,
  DEPRECATED_ALIASES: Nl,
  FLIPPED_ALIAS_KEYS: _l,
  TYPES: PN,
  __internal__deprecationWarning: Dl
} = EN;
function xN(e) {
  return e in Vc;
}
function Kc(e) {
  return e == null ? void 0 : e._exploded;
}
function qc(e) {
  if (Kc(e))
    return e;
  e._exploded = !0;
  for (const t of Object.keys(e)) {
    if (lr(t))
      continue;
    const r = t.split("|");
    if (r.length === 1)
      continue;
    const i = e[t];
    delete e[t];
    for (const s of r)
      e[s] = i;
  }
  Wc(e), delete e.__esModule, AN(e), Ml(e);
  for (const t of Object.keys(e)) {
    if (lr(t) || !xN(t))
      continue;
    const r = e[t];
    for (const s of Object.keys(r))
      r[s] = CN(t, r[s]);
    delete e[t];
    const i = Vc[t];
    if (i !== null)
      for (const s of i)
        e[s] ? ni(e[s], r) : e[s] = r;
    else
      ni(e, r);
  }
  for (const t of Object.keys(e)) {
    if (lr(t))
      continue;
    let r = _l[t];
    if (t in Ol) {
      const s = Ol[t];
      Dl(t, s, "Visitor "), r = [s];
    } else if (t in Nl) {
      const s = Nl[t];
      Dl(t, s, "Visitor "), r = _l[s];
    }
    if (!r)
      continue;
    const i = e[t];
    delete e[t];
    for (const s of r) {
      const n = e[s];
      n ? ni(n, i) : e[s] = Object.assign({}, i);
    }
  }
  for (const t of Object.keys(e))
    lr(t) || Ml(e[t]);
  return e;
}
function Wc(e) {
  if (!e._verified) {
    if (typeof e == "function")
      throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?");
    for (const t of Object.keys(e)) {
      if ((t === "enter" || t === "exit") && kl(t, e[t]), lr(t))
        continue;
      if (PN.indexOf(t) < 0)
        throw new Error(`You gave us a visitor for the node type ${t} but it's not a valid type`);
      const r = e[t];
      if (typeof r == "object")
        for (const i of Object.keys(r))
          if (i === "enter" || i === "exit")
            kl(`${t}.${i}`, r[i]);
          else
            throw new Error(`You passed \`traverse()\` a visitor object with the property ${t} that has the invalid property ${i}`);
    }
    e._verified = !0;
  }
}
function kl(e, t) {
  const r = [].concat(t);
  for (const i of r)
    if (typeof i != "function")
      throw new TypeError(`Non-function found defined in ${e} with type ${typeof i}`);
}
function vN(e, t = [], r) {
  const i = {};
  for (let s = 0; s < e.length; s++) {
    const n = qc(e[s]), a = t[s];
    let o = n;
    (a || r) && (o = Ll(o, a, r)), ni(i, o);
    for (const l of Object.keys(n)) {
      if (lr(l))
        continue;
      let u = n[l];
      (a || r) && (u = Ll(u, a, r));
      const c = i[l] || (i[l] = {});
      ni(c, u);
    }
  }
  return i;
}
function Ll(e, t, r) {
  const i = {};
  for (const s of ["enter", "exit"]) {
    let n = e[s];
    Array.isArray(n) && (n = n.map(function(a) {
      let o = a;
      return t && (o = function(l) {
        a.call(t, l, t);
      }), r && (o = r(t == null ? void 0 : t.key, s, o)), o !== a && (o.toString = () => a.toString()), o;
    }), i[s] = n);
  }
  return i;
}
function AN(e) {
  for (const t of Object.keys(e)) {
    if (lr(t))
      continue;
    const r = e[t];
    typeof r == "function" && (e[t] = {
      enter: r
    });
  }
}
function Ml(e) {
  e.enter && !Array.isArray(e.enter) && (e.enter = [e.enter]), e.exit && !Array.isArray(e.exit) && (e.exit = [e.exit]);
}
function CN(e, t) {
  const r = function(i) {
    if (i[`is${e}`]())
      return t.apply(this, arguments);
  };
  return r.toString = () => t.toString(), r;
}
function lr(e) {
  return e[0] === "_" || e === "enter" || e === "exit" || e === "shouldSkip" || e === "denylist" || e === "noScope" || e === "skipKeys" || e === "blacklist";
}
function ni(e, t) {
  for (const r of ["enter", "exit"])
    t[r] && (e[r] = [].concat(e[r] || [], t[r]));
}
var Ze = {};
Object.defineProperty(Ze, "__esModule", {
  value: !0
});
Ze.clear = IN;
Ze.clearPath = Jc;
Ze.clearScope = Hc;
Ze.scope = Ze.path = void 0;
let Yc = /* @__PURE__ */ new WeakMap();
Ze.path = Yc;
let Xc = /* @__PURE__ */ new WeakMap();
Ze.scope = Xc;
function IN() {
  Jc(), Hc();
}
function Jc() {
  Ze.path = Yc = /* @__PURE__ */ new WeakMap();
}
function Hc() {
  Ze.scope = Xc = /* @__PURE__ */ new WeakMap();
}
var Xi = {}, Xr = {}, Tt = {}, Vn = { exports: {} }, Tn, Bl;
function wN() {
  if (Bl)
    return Tn;
  Bl = 1;
  var e = 1e3, t = e * 60, r = t * 60, i = r * 24, s = i * 7, n = i * 365.25;
  Tn = function(c, p) {
    p = p || {};
    var h = typeof c;
    if (h === "string" && c.length > 0)
      return a(c);
    if (h === "number" && isFinite(c))
      return p.long ? l(c) : o(c);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(c)
    );
  };
  function a(c) {
    if (c = String(c), !(c.length > 100)) {
      var p = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        c
      );
      if (p) {
        var h = parseFloat(p[1]), y = (p[2] || "ms").toLowerCase();
        switch (y) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return h * n;
          case "weeks":
          case "week":
          case "w":
            return h * s;
          case "days":
          case "day":
          case "d":
            return h * i;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return h * r;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return h * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return h * e;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return h;
          default:
            return;
        }
      }
    }
  }
  function o(c) {
    var p = Math.abs(c);
    return p >= i ? Math.round(c / i) + "d" : p >= r ? Math.round(c / r) + "h" : p >= t ? Math.round(c / t) + "m" : p >= e ? Math.round(c / e) + "s" : c + "ms";
  }
  function l(c) {
    var p = Math.abs(c);
    return p >= i ? u(c, p, i, "day") : p >= r ? u(c, p, r, "hour") : p >= t ? u(c, p, t, "minute") : p >= e ? u(c, p, e, "second") : c + " ms";
  }
  function u(c, p, h, y) {
    var P = p >= h * 1.5;
    return Math.round(c / h) + " " + y + (P ? "s" : "");
  }
  return Tn;
}
function ON(e) {
  r.debug = r, r.default = r, r.coerce = l, r.disable = n, r.enable = s, r.enabled = a, r.humanize = wN(), r.destroy = u, Object.keys(e).forEach((c) => {
    r[c] = e[c];
  }), r.names = [], r.skips = [], r.formatters = {};
  function t(c) {
    let p = 0;
    for (let h = 0; h < c.length; h++)
      p = (p << 5) - p + c.charCodeAt(h), p |= 0;
    return r.colors[Math.abs(p) % r.colors.length];
  }
  r.selectColor = t;
  function r(c) {
    let p, h = null, y, P;
    function v(...w) {
      if (!v.enabled)
        return;
      const x = v, O = Number(/* @__PURE__ */ new Date()), _ = O - (p || O);
      x.diff = _, x.prev = p, x.curr = O, p = O, w[0] = r.coerce(w[0]), typeof w[0] != "string" && w.unshift("%O");
      let K = 0;
      w[0] = w[0].replace(/%([a-zA-Z%])/g, (B, C) => {
        if (B === "%%")
          return "%";
        K++;
        const L = r.formatters[C];
        if (typeof L == "function") {
          const F = w[K];
          B = L.call(x, F), w.splice(K, 1), K--;
        }
        return B;
      }), r.formatArgs.call(x, w), (x.log || r.log).apply(x, w);
    }
    return v.namespace = c, v.useColors = r.useColors(), v.color = r.selectColor(c), v.extend = i, v.destroy = r.destroy, Object.defineProperty(v, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => h !== null ? h : (y !== r.namespaces && (y = r.namespaces, P = r.enabled(c)), P),
      set: (w) => {
        h = w;
      }
    }), typeof r.init == "function" && r.init(v), v;
  }
  function i(c, p) {
    const h = r(this.namespace + (typeof p > "u" ? ":" : p) + c);
    return h.log = this.log, h;
  }
  function s(c) {
    r.save(c), r.namespaces = c, r.names = [], r.skips = [];
    let p;
    const h = (typeof c == "string" ? c : "").split(/[\s,]+/), y = h.length;
    for (p = 0; p < y; p++)
      h[p] && (c = h[p].replace(/\*/g, ".*?"), c[0] === "-" ? r.skips.push(new RegExp("^" + c.slice(1) + "$")) : r.names.push(new RegExp("^" + c + "$")));
  }
  function n() {
    const c = [
      ...r.names.map(o),
      ...r.skips.map(o).map((p) => "-" + p)
    ].join(",");
    return r.enable(""), c;
  }
  function a(c) {
    if (c[c.length - 1] === "*")
      return !0;
    let p, h;
    for (p = 0, h = r.skips.length; p < h; p++)
      if (r.skips[p].test(c))
        return !1;
    for (p = 0, h = r.names.length; p < h; p++)
      if (r.names[p].test(c))
        return !0;
    return !1;
  }
  function o(c) {
    return c.toString().substring(2, c.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function l(c) {
    return c instanceof Error ? c.stack || c.message : c;
  }
  function u() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return r.enable(r.load()), r;
}
var NN = ON;
(function(e, t) {
  t.formatArgs = i, t.save = s, t.load = n, t.useColors = r, t.storage = a(), t.destroy = (() => {
    let l = !1;
    return () => {
      l || (l = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), t.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function r() {
    return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function i(l) {
    if (l[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + l[0] + (this.useColors ? "%c " : " ") + "+" + e.exports.humanize(this.diff), !this.useColors)
      return;
    const u = "color: " + this.color;
    l.splice(1, 0, u, "color: inherit");
    let c = 0, p = 0;
    l[0].replace(/%[a-zA-Z%]/g, (h) => {
      h !== "%%" && (c++, h === "%c" && (p = c));
    }), l.splice(p, 0, u);
  }
  t.log = console.debug || console.log || (() => {
  });
  function s(l) {
    try {
      l ? t.storage.setItem("debug", l) : t.storage.removeItem("debug");
    } catch {
    }
  }
  function n() {
    let l;
    try {
      l = t.storage.getItem("debug");
    } catch {
    }
    return !l && typeof process < "u" && "env" in process && (l = process.env.DEBUG), l;
  }
  function a() {
    try {
      return localStorage;
    } catch {
    }
  }
  e.exports = NN(t);
  const { formatters: o } = e.exports;
  o.j = function(l) {
    try {
      return JSON.stringify(l);
    } catch (u) {
      return "[UnexpectedJSONParseError]: " + u.message;
    }
  };
})(Vn, Vn.exports);
var _N = Vn.exports, Jr = {}, Hr = {}, Wa = {};
Object.defineProperty(Wa, "__esModule", {
  value: !0
});
Wa.default = MN;
var DN = Ae();
const {
  cloneNode: Sn,
  exportNamedDeclaration: Fl,
  exportSpecifier: jl,
  identifier: bn,
  variableDeclaration: kN,
  variableDeclarator: LN
} = DN;
function MN(e) {
  if (!e.isExportDeclaration() || e.isExportAllDeclaration())
    throw new Error("Only default and named export declarations can be split.");
  if (e.isExportDefaultDeclaration()) {
    const n = e.get("declaration"), a = n.isFunctionDeclaration() || n.isClassDeclaration(), o = n.isFunctionExpression() || n.isClassExpression(), l = n.isScope() ? n.scope.parent : n.scope;
    let u = n.node.id, c = !1;
    u ? o && l.hasBinding(u.name) && (c = !0, u = l.generateUidIdentifier(u.name)) : (c = !0, u = l.generateUidIdentifier("default"), (a || o) && (n.node.id = Sn(u)));
    const p = a ? n.node : kN("var", [LN(Sn(u), n.node)]), h = Fl(null, [jl(Sn(u), bn("default"))]);
    return e.insertAfter(h), e.replaceWith(p), c && l.registerDeclaration(e), e;
  } else if (e.get("specifiers").length > 0)
    throw new Error("It doesn't make sense to split exported specifiers.");
  const t = e.get("declaration"), r = t.getOuterBindingIdentifiers(), i = Object.keys(r).map((n) => jl(bn(n), bn(n))), s = Fl(null, i);
  return e.insertAfter(s), e.replaceWith(t.node), e;
}
var mr = {};
Object.defineProperty(mr, "__esModule", {
  value: !0
});
mr.default = void 0;
mr.requeueComputedKeyAndDecorators = Kn;
mr.skipAllButComputedKey = function(t) {
  t.skip(), t.node.computed && t.context.maybeQueue(t.get("key"));
};
function Kn(e) {
  const {
    context: t,
    node: r
  } = e;
  if (r.computed && t.maybeQueue(e.get("key")), r.decorators)
    for (const i of e.get("decorators"))
      t.maybeQueue(i);
}
const BN = {
  FunctionParent(e) {
    e.isArrowFunctionExpression() || (e.skip(), e.isMethod() && Kn(e));
  },
  Property(e) {
    e.isObjectProperty() || (e.skip(), Kn(e));
  }
};
var FN = BN;
mr.default = FN;
var Rl;
function jN() {
  if (Rl)
    return Hr;
  Rl = 1, Object.defineProperty(Hr, "__esModule", {
    value: !0
  }), Hr.default = void 0;
  var e = Wa, t = Ae(), r = mr, i = To(), s = Ft;
  const n = {
    ReferencedIdentifier({
      node: o
    }, l) {
      o.name === l.oldName && (o.name = l.newName);
    },
    Scope(o, l) {
      o.scope.bindingIdentifierEquals(l.oldName, l.binding.identifier) || (o.skip(), o.isMethod() && (0, r.requeueComputedKeyAndDecorators)(o));
    },
    ObjectProperty({
      node: o,
      scope: l
    }, u) {
      const {
        name: c
      } = o.key;
      if (o.shorthand && (c === u.oldName || c === u.newName) && l.getBindingIdentifier(c) === u.binding.identifier) {
        var p;
        o.shorthand = !1, (p = o.extra) != null && p.shorthand && (o.extra.shorthand = !1);
      }
    },
    "AssignmentExpression|Declaration|VariableDeclarator"(o, l) {
      if (o.isVariableDeclaration())
        return;
      const u = o.getOuterBindingIdentifiers();
      for (const c in u)
        c === l.oldName && (u[c].name = l.newName);
    }
  };
  class a {
    constructor(l, u, c) {
      this.newName = c, this.oldName = u, this.binding = l;
    }
    maybeConvertFromExportDeclaration(l) {
      const u = l.parentPath;
      if (u.isExportDeclaration()) {
        if (u.isExportDefaultDeclaration()) {
          const {
            declaration: c
          } = u.node;
          if (t.isDeclaration(c) && !c.id)
            return;
        }
        u.isExportAllDeclaration() || (0, e.default)(u);
      }
    }
    maybeConvertFromClassFunctionDeclaration(l) {
      return l;
    }
    maybeConvertFromClassFunctionExpression(l) {
      return l;
    }
    rename() {
      const {
        binding: l,
        oldName: u,
        newName: c
      } = this, {
        scope: p,
        path: h
      } = l, y = h.find((v) => v.isDeclaration() || v.isFunctionExpression() || v.isClassExpression());
      y && y.getOuterBindingIdentifiers()[u] === l.identifier && this.maybeConvertFromExportDeclaration(y);
      const P = arguments[0] || p.block;
      (0, i.traverseNode)(P, (0, s.explode)(n), p, this, p.path, {
        discriminant: !0
      }), arguments[0] || (p.removeOwnBinding(u), p.bindings[c] = l, this.binding.identifier.name = c), y && (this.maybeConvertFromClassFunctionDeclaration(h), this.maybeConvertFromClassFunctionExpression(h));
    }
  }
  return Hr.default = a, Hr;
}
var Rs = {};
Object.defineProperty(Rs, "__esModule", {
  value: !0
});
Rs.default = void 0;
class RN {
  constructor({
    identifier: t,
    scope: r,
    path: i,
    kind: s
  }) {
    this.identifier = void 0, this.scope = void 0, this.path = void 0, this.kind = void 0, this.constantViolations = [], this.constant = !0, this.referencePaths = [], this.referenced = !1, this.references = 0, this.identifier = t, this.scope = r, this.path = i, this.kind = s, (s === "var" || s === "hoisted") && $N(i || (() => {
      throw new Error("Internal Babel error: unreachable ");
    })()) && this.reassign(i), this.clearValue();
  }
  deoptValue() {
    this.clearValue(), this.hasDeoptedValue = !0;
  }
  setValue(t) {
    this.hasDeoptedValue || (this.hasValue = !0, this.value = t);
  }
  clearValue() {
    this.hasDeoptedValue = !1, this.hasValue = !1, this.value = null;
  }
  reassign(t) {
    this.constant = !1, this.constantViolations.indexOf(t) === -1 && this.constantViolations.push(t);
  }
  reference(t) {
    this.referencePaths.indexOf(t) === -1 && (this.referenced = !0, this.references++, this.referencePaths.push(t));
  }
  dereference() {
    this.references--, this.referenced = !!this.references;
  }
}
Rs.default = RN;
function $N(e) {
  for (let {
    parentPath: t,
    key: r
  } = e; t; {
    parentPath: t,
    key: r
  } = t) {
    if (t.isFunctionParent())
      return !1;
    if (t.isWhile() || t.isForXStatement() || t.isForStatement() && r === "body")
      return !0;
  }
  return !1;
}
const UN = {
  Array: !1,
  ArrayBuffer: !1,
  Atomics: !1,
  BigInt: !1,
  BigInt64Array: !1,
  BigUint64Array: !1,
  Boolean: !1,
  constructor: !1,
  DataView: !1,
  Date: !1,
  decodeURI: !1,
  decodeURIComponent: !1,
  encodeURI: !1,
  encodeURIComponent: !1,
  Error: !1,
  escape: !1,
  eval: !1,
  EvalError: !1,
  Float32Array: !1,
  Float64Array: !1,
  Function: !1,
  globalThis: !1,
  hasOwnProperty: !1,
  Infinity: !1,
  Int16Array: !1,
  Int32Array: !1,
  Int8Array: !1,
  isFinite: !1,
  isNaN: !1,
  isPrototypeOf: !1,
  JSON: !1,
  Map: !1,
  Math: !1,
  NaN: !1,
  Number: !1,
  Object: !1,
  parseFloat: !1,
  parseInt: !1,
  Promise: !1,
  propertyIsEnumerable: !1,
  Proxy: !1,
  RangeError: !1,
  ReferenceError: !1,
  Reflect: !1,
  RegExp: !1,
  Set: !1,
  SharedArrayBuffer: !1,
  String: !1,
  Symbol: !1,
  SyntaxError: !1,
  toLocaleString: !1,
  toString: !1,
  TypeError: !1,
  Uint16Array: !1,
  Uint32Array: !1,
  Uint8Array: !1,
  Uint8ClampedArray: !1,
  undefined: !1,
  unescape: !1,
  URIError: !1,
  valueOf: !1,
  WeakMap: !1,
  WeakSet: !1
}, VN = {
  Array: !1,
  Boolean: !1,
  constructor: !1,
  Date: !1,
  decodeURI: !1,
  decodeURIComponent: !1,
  encodeURI: !1,
  encodeURIComponent: !1,
  Error: !1,
  escape: !1,
  eval: !1,
  EvalError: !1,
  Function: !1,
  hasOwnProperty: !1,
  Infinity: !1,
  isFinite: !1,
  isNaN: !1,
  isPrototypeOf: !1,
  JSON: !1,
  Math: !1,
  NaN: !1,
  Number: !1,
  Object: !1,
  parseFloat: !1,
  parseInt: !1,
  propertyIsEnumerable: !1,
  RangeError: !1,
  ReferenceError: !1,
  RegExp: !1,
  String: !1,
  SyntaxError: !1,
  toLocaleString: !1,
  toString: !1,
  TypeError: !1,
  undefined: !1,
  unescape: !1,
  URIError: !1,
  valueOf: !1
}, KN = {
  Array: !1,
  ArrayBuffer: !1,
  Boolean: !1,
  constructor: !1,
  DataView: !1,
  Date: !1,
  decodeURI: !1,
  decodeURIComponent: !1,
  encodeURI: !1,
  encodeURIComponent: !1,
  Error: !1,
  escape: !1,
  eval: !1,
  EvalError: !1,
  Float32Array: !1,
  Float64Array: !1,
  Function: !1,
  hasOwnProperty: !1,
  Infinity: !1,
  Int16Array: !1,
  Int32Array: !1,
  Int8Array: !1,
  isFinite: !1,
  isNaN: !1,
  isPrototypeOf: !1,
  JSON: !1,
  Map: !1,
  Math: !1,
  NaN: !1,
  Number: !1,
  Object: !1,
  parseFloat: !1,
  parseInt: !1,
  Promise: !1,
  propertyIsEnumerable: !1,
  Proxy: !1,
  RangeError: !1,
  ReferenceError: !1,
  Reflect: !1,
  RegExp: !1,
  Set: !1,
  String: !1,
  Symbol: !1,
  SyntaxError: !1,
  toLocaleString: !1,
  toString: !1,
  TypeError: !1,
  Uint16Array: !1,
  Uint32Array: !1,
  Uint8Array: !1,
  Uint8ClampedArray: !1,
  undefined: !1,
  unescape: !1,
  URIError: !1,
  valueOf: !1,
  WeakMap: !1,
  WeakSet: !1
}, qN = {
  Array: !1,
  ArrayBuffer: !1,
  Atomics: !1,
  Boolean: !1,
  constructor: !1,
  DataView: !1,
  Date: !1,
  decodeURI: !1,
  decodeURIComponent: !1,
  encodeURI: !1,
  encodeURIComponent: !1,
  Error: !1,
  escape: !1,
  eval: !1,
  EvalError: !1,
  Float32Array: !1,
  Float64Array: !1,
  Function: !1,
  hasOwnProperty: !1,
  Infinity: !1,
  Int16Array: !1,
  Int32Array: !1,
  Int8Array: !1,
  isFinite: !1,
  isNaN: !1,
  isPrototypeOf: !1,
  JSON: !1,
  Map: !1,
  Math: !1,
  NaN: !1,
  Number: !1,
  Object: !1,
  parseFloat: !1,
  parseInt: !1,
  Promise: !1,
  propertyIsEnumerable: !1,
  Proxy: !1,
  RangeError: !1,
  ReferenceError: !1,
  Reflect: !1,
  RegExp: !1,
  Set: !1,
  SharedArrayBuffer: !1,
  String: !1,
  Symbol: !1,
  SyntaxError: !1,
  toLocaleString: !1,
  toString: !1,
  TypeError: !1,
  Uint16Array: !1,
  Uint32Array: !1,
  Uint8Array: !1,
  Uint8ClampedArray: !1,
  undefined: !1,
  unescape: !1,
  URIError: !1,
  valueOf: !1,
  WeakMap: !1,
  WeakSet: !1
}, WN = {
  AbortController: !1,
  AbortSignal: !1,
  addEventListener: !1,
  alert: !1,
  AnalyserNode: !1,
  Animation: !1,
  AnimationEffectReadOnly: !1,
  AnimationEffectTiming: !1,
  AnimationEffectTimingReadOnly: !1,
  AnimationEvent: !1,
  AnimationPlaybackEvent: !1,
  AnimationTimeline: !1,
  applicationCache: !1,
  ApplicationCache: !1,
  ApplicationCacheErrorEvent: !1,
  atob: !1,
  Attr: !1,
  Audio: !1,
  AudioBuffer: !1,
  AudioBufferSourceNode: !1,
  AudioContext: !1,
  AudioDestinationNode: !1,
  AudioListener: !1,
  AudioNode: !1,
  AudioParam: !1,
  AudioProcessingEvent: !1,
  AudioScheduledSourceNode: !1,
  "AudioWorkletGlobalScope ": !1,
  AudioWorkletNode: !1,
  AudioWorkletProcessor: !1,
  BarProp: !1,
  BaseAudioContext: !1,
  BatteryManager: !1,
  BeforeUnloadEvent: !1,
  BiquadFilterNode: !1,
  Blob: !1,
  BlobEvent: !1,
  blur: !1,
  BroadcastChannel: !1,
  btoa: !1,
  BudgetService: !1,
  ByteLengthQueuingStrategy: !1,
  Cache: !1,
  caches: !1,
  CacheStorage: !1,
  cancelAnimationFrame: !1,
  cancelIdleCallback: !1,
  CanvasCaptureMediaStreamTrack: !1,
  CanvasGradient: !1,
  CanvasPattern: !1,
  CanvasRenderingContext2D: !1,
  ChannelMergerNode: !1,
  ChannelSplitterNode: !1,
  CharacterData: !1,
  clearInterval: !1,
  clearTimeout: !1,
  clientInformation: !1,
  ClipboardEvent: !1,
  close: !1,
  closed: !1,
  CloseEvent: !1,
  Comment: !1,
  CompositionEvent: !1,
  confirm: !1,
  console: !1,
  ConstantSourceNode: !1,
  ConvolverNode: !1,
  CountQueuingStrategy: !1,
  createImageBitmap: !1,
  Credential: !1,
  CredentialsContainer: !1,
  crypto: !1,
  Crypto: !1,
  CryptoKey: !1,
  CSS: !1,
  CSSConditionRule: !1,
  CSSFontFaceRule: !1,
  CSSGroupingRule: !1,
  CSSImportRule: !1,
  CSSKeyframeRule: !1,
  CSSKeyframesRule: !1,
  CSSMediaRule: !1,
  CSSNamespaceRule: !1,
  CSSPageRule: !1,
  CSSRule: !1,
  CSSRuleList: !1,
  CSSStyleDeclaration: !1,
  CSSStyleRule: !1,
  CSSStyleSheet: !1,
  CSSSupportsRule: !1,
  CustomElementRegistry: !1,
  customElements: !1,
  CustomEvent: !1,
  DataTransfer: !1,
  DataTransferItem: !1,
  DataTransferItemList: !1,
  defaultstatus: !1,
  defaultStatus: !1,
  DelayNode: !1,
  DeviceMotionEvent: !1,
  DeviceOrientationEvent: !1,
  devicePixelRatio: !1,
  dispatchEvent: !1,
  document: !1,
  Document: !1,
  DocumentFragment: !1,
  DocumentType: !1,
  DOMError: !1,
  DOMException: !1,
  DOMImplementation: !1,
  DOMMatrix: !1,
  DOMMatrixReadOnly: !1,
  DOMParser: !1,
  DOMPoint: !1,
  DOMPointReadOnly: !1,
  DOMQuad: !1,
  DOMRect: !1,
  DOMRectReadOnly: !1,
  DOMStringList: !1,
  DOMStringMap: !1,
  DOMTokenList: !1,
  DragEvent: !1,
  DynamicsCompressorNode: !1,
  Element: !1,
  ErrorEvent: !1,
  event: !1,
  Event: !1,
  EventSource: !1,
  EventTarget: !1,
  external: !1,
  fetch: !1,
  File: !1,
  FileList: !1,
  FileReader: !1,
  find: !1,
  focus: !1,
  FocusEvent: !1,
  FontFace: !1,
  FontFaceSetLoadEvent: !1,
  FormData: !1,
  frameElement: !1,
  frames: !1,
  GainNode: !1,
  Gamepad: !1,
  GamepadButton: !1,
  GamepadEvent: !1,
  getComputedStyle: !1,
  getSelection: !1,
  HashChangeEvent: !1,
  Headers: !1,
  history: !1,
  History: !1,
  HTMLAllCollection: !1,
  HTMLAnchorElement: !1,
  HTMLAreaElement: !1,
  HTMLAudioElement: !1,
  HTMLBaseElement: !1,
  HTMLBodyElement: !1,
  HTMLBRElement: !1,
  HTMLButtonElement: !1,
  HTMLCanvasElement: !1,
  HTMLCollection: !1,
  HTMLContentElement: !1,
  HTMLDataElement: !1,
  HTMLDataListElement: !1,
  HTMLDetailsElement: !1,
  HTMLDialogElement: !1,
  HTMLDirectoryElement: !1,
  HTMLDivElement: !1,
  HTMLDListElement: !1,
  HTMLDocument: !1,
  HTMLElement: !1,
  HTMLEmbedElement: !1,
  HTMLFieldSetElement: !1,
  HTMLFontElement: !1,
  HTMLFormControlsCollection: !1,
  HTMLFormElement: !1,
  HTMLFrameElement: !1,
  HTMLFrameSetElement: !1,
  HTMLHeadElement: !1,
  HTMLHeadingElement: !1,
  HTMLHRElement: !1,
  HTMLHtmlElement: !1,
  HTMLIFrameElement: !1,
  HTMLImageElement: !1,
  HTMLInputElement: !1,
  HTMLLabelElement: !1,
  HTMLLegendElement: !1,
  HTMLLIElement: !1,
  HTMLLinkElement: !1,
  HTMLMapElement: !1,
  HTMLMarqueeElement: !1,
  HTMLMediaElement: !1,
  HTMLMenuElement: !1,
  HTMLMetaElement: !1,
  HTMLMeterElement: !1,
  HTMLModElement: !1,
  HTMLObjectElement: !1,
  HTMLOListElement: !1,
  HTMLOptGroupElement: !1,
  HTMLOptionElement: !1,
  HTMLOptionsCollection: !1,
  HTMLOutputElement: !1,
  HTMLParagraphElement: !1,
  HTMLParamElement: !1,
  HTMLPictureElement: !1,
  HTMLPreElement: !1,
  HTMLProgressElement: !1,
  HTMLQuoteElement: !1,
  HTMLScriptElement: !1,
  HTMLSelectElement: !1,
  HTMLShadowElement: !1,
  HTMLSlotElement: !1,
  HTMLSourceElement: !1,
  HTMLSpanElement: !1,
  HTMLStyleElement: !1,
  HTMLTableCaptionElement: !1,
  HTMLTableCellElement: !1,
  HTMLTableColElement: !1,
  HTMLTableElement: !1,
  HTMLTableRowElement: !1,
  HTMLTableSectionElement: !1,
  HTMLTemplateElement: !1,
  HTMLTextAreaElement: !1,
  HTMLTimeElement: !1,
  HTMLTitleElement: !1,
  HTMLTrackElement: !1,
  HTMLUListElement: !1,
  HTMLUnknownElement: !1,
  HTMLVideoElement: !1,
  IDBCursor: !1,
  IDBCursorWithValue: !1,
  IDBDatabase: !1,
  IDBFactory: !1,
  IDBIndex: !1,
  IDBKeyRange: !1,
  IDBObjectStore: !1,
  IDBOpenDBRequest: !1,
  IDBRequest: !1,
  IDBTransaction: !1,
  IDBVersionChangeEvent: !1,
  IdleDeadline: !1,
  IIRFilterNode: !1,
  Image: !1,
  ImageBitmap: !1,
  ImageBitmapRenderingContext: !1,
  ImageCapture: !1,
  ImageData: !1,
  indexedDB: !1,
  innerHeight: !1,
  innerWidth: !1,
  InputEvent: !1,
  IntersectionObserver: !1,
  IntersectionObserverEntry: !1,
  Intl: !1,
  isSecureContext: !1,
  KeyboardEvent: !1,
  KeyframeEffect: !1,
  KeyframeEffectReadOnly: !1,
  length: !1,
  localStorage: !1,
  location: !0,
  Location: !1,
  locationbar: !1,
  matchMedia: !1,
  MediaDeviceInfo: !1,
  MediaDevices: !1,
  MediaElementAudioSourceNode: !1,
  MediaEncryptedEvent: !1,
  MediaError: !1,
  MediaKeyMessageEvent: !1,
  MediaKeySession: !1,
  MediaKeyStatusMap: !1,
  MediaKeySystemAccess: !1,
  MediaList: !1,
  MediaQueryList: !1,
  MediaQueryListEvent: !1,
  MediaRecorder: !1,
  MediaSettingsRange: !1,
  MediaSource: !1,
  MediaStream: !1,
  MediaStreamAudioDestinationNode: !1,
  MediaStreamAudioSourceNode: !1,
  MediaStreamEvent: !1,
  MediaStreamTrack: !1,
  MediaStreamTrackEvent: !1,
  menubar: !1,
  MessageChannel: !1,
  MessageEvent: !1,
  MessagePort: !1,
  MIDIAccess: !1,
  MIDIConnectionEvent: !1,
  MIDIInput: !1,
  MIDIInputMap: !1,
  MIDIMessageEvent: !1,
  MIDIOutput: !1,
  MIDIOutputMap: !1,
  MIDIPort: !1,
  MimeType: !1,
  MimeTypeArray: !1,
  MouseEvent: !1,
  moveBy: !1,
  moveTo: !1,
  MutationEvent: !1,
  MutationObserver: !1,
  MutationRecord: !1,
  name: !1,
  NamedNodeMap: !1,
  NavigationPreloadManager: !1,
  navigator: !1,
  Navigator: !1,
  NetworkInformation: !1,
  Node: !1,
  NodeFilter: !1,
  NodeIterator: !1,
  NodeList: !1,
  Notification: !1,
  OfflineAudioCompletionEvent: !1,
  OfflineAudioContext: !1,
  offscreenBuffering: !1,
  OffscreenCanvas: !0,
  onabort: !0,
  onafterprint: !0,
  onanimationend: !0,
  onanimationiteration: !0,
  onanimationstart: !0,
  onappinstalled: !0,
  onauxclick: !0,
  onbeforeinstallprompt: !0,
  onbeforeprint: !0,
  onbeforeunload: !0,
  onblur: !0,
  oncancel: !0,
  oncanplay: !0,
  oncanplaythrough: !0,
  onchange: !0,
  onclick: !0,
  onclose: !0,
  oncontextmenu: !0,
  oncuechange: !0,
  ondblclick: !0,
  ondevicemotion: !0,
  ondeviceorientation: !0,
  ondeviceorientationabsolute: !0,
  ondrag: !0,
  ondragend: !0,
  ondragenter: !0,
  ondragleave: !0,
  ondragover: !0,
  ondragstart: !0,
  ondrop: !0,
  ondurationchange: !0,
  onemptied: !0,
  onended: !0,
  onerror: !0,
  onfocus: !0,
  ongotpointercapture: !0,
  onhashchange: !0,
  oninput: !0,
  oninvalid: !0,
  onkeydown: !0,
  onkeypress: !0,
  onkeyup: !0,
  onlanguagechange: !0,
  onload: !0,
  onloadeddata: !0,
  onloadedmetadata: !0,
  onloadstart: !0,
  onlostpointercapture: !0,
  onmessage: !0,
  onmessageerror: !0,
  onmousedown: !0,
  onmouseenter: !0,
  onmouseleave: !0,
  onmousemove: !0,
  onmouseout: !0,
  onmouseover: !0,
  onmouseup: !0,
  onmousewheel: !0,
  onoffline: !0,
  ononline: !0,
  onpagehide: !0,
  onpageshow: !0,
  onpause: !0,
  onplay: !0,
  onplaying: !0,
  onpointercancel: !0,
  onpointerdown: !0,
  onpointerenter: !0,
  onpointerleave: !0,
  onpointermove: !0,
  onpointerout: !0,
  onpointerover: !0,
  onpointerup: !0,
  onpopstate: !0,
  onprogress: !0,
  onratechange: !0,
  onrejectionhandled: !0,
  onreset: !0,
  onresize: !0,
  onscroll: !0,
  onsearch: !0,
  onseeked: !0,
  onseeking: !0,
  onselect: !0,
  onstalled: !0,
  onstorage: !0,
  onsubmit: !0,
  onsuspend: !0,
  ontimeupdate: !0,
  ontoggle: !0,
  ontransitionend: !0,
  onunhandledrejection: !0,
  onunload: !0,
  onvolumechange: !0,
  onwaiting: !0,
  onwheel: !0,
  open: !1,
  openDatabase: !1,
  opener: !1,
  Option: !1,
  origin: !1,
  OscillatorNode: !1,
  outerHeight: !1,
  outerWidth: !1,
  PageTransitionEvent: !1,
  pageXOffset: !1,
  pageYOffset: !1,
  PannerNode: !1,
  parent: !1,
  Path2D: !1,
  PaymentAddress: !1,
  PaymentRequest: !1,
  PaymentRequestUpdateEvent: !1,
  PaymentResponse: !1,
  performance: !1,
  Performance: !1,
  PerformanceEntry: !1,
  PerformanceLongTaskTiming: !1,
  PerformanceMark: !1,
  PerformanceMeasure: !1,
  PerformanceNavigation: !1,
  PerformanceNavigationTiming: !1,
  PerformanceObserver: !1,
  PerformanceObserverEntryList: !1,
  PerformancePaintTiming: !1,
  PerformanceResourceTiming: !1,
  PerformanceTiming: !1,
  PeriodicWave: !1,
  Permissions: !1,
  PermissionStatus: !1,
  personalbar: !1,
  PhotoCapabilities: !1,
  Plugin: !1,
  PluginArray: !1,
  PointerEvent: !1,
  PopStateEvent: !1,
  postMessage: !1,
  Presentation: !1,
  PresentationAvailability: !1,
  PresentationConnection: !1,
  PresentationConnectionAvailableEvent: !1,
  PresentationConnectionCloseEvent: !1,
  PresentationConnectionList: !1,
  PresentationReceiver: !1,
  PresentationRequest: !1,
  print: !1,
  ProcessingInstruction: !1,
  ProgressEvent: !1,
  PromiseRejectionEvent: !1,
  prompt: !1,
  PushManager: !1,
  PushSubscription: !1,
  PushSubscriptionOptions: !1,
  queueMicrotask: !1,
  RadioNodeList: !1,
  Range: !1,
  ReadableStream: !1,
  registerProcessor: !1,
  RemotePlayback: !1,
  removeEventListener: !1,
  Request: !1,
  requestAnimationFrame: !1,
  requestIdleCallback: !1,
  resizeBy: !1,
  ResizeObserver: !1,
  ResizeObserverEntry: !1,
  resizeTo: !1,
  Response: !1,
  RTCCertificate: !1,
  RTCDataChannel: !1,
  RTCDataChannelEvent: !1,
  RTCDtlsTransport: !1,
  RTCIceCandidate: !1,
  RTCIceGatherer: !1,
  RTCIceTransport: !1,
  RTCPeerConnection: !1,
  RTCPeerConnectionIceEvent: !1,
  RTCRtpContributingSource: !1,
  RTCRtpReceiver: !1,
  RTCRtpSender: !1,
  RTCSctpTransport: !1,
  RTCSessionDescription: !1,
  RTCStatsReport: !1,
  RTCTrackEvent: !1,
  screen: !1,
  Screen: !1,
  screenLeft: !1,
  ScreenOrientation: !1,
  screenTop: !1,
  screenX: !1,
  screenY: !1,
  ScriptProcessorNode: !1,
  scroll: !1,
  scrollbars: !1,
  scrollBy: !1,
  scrollTo: !1,
  scrollX: !1,
  scrollY: !1,
  SecurityPolicyViolationEvent: !1,
  Selection: !1,
  self: !1,
  ServiceWorker: !1,
  ServiceWorkerContainer: !1,
  ServiceWorkerRegistration: !1,
  sessionStorage: !1,
  setInterval: !1,
  setTimeout: !1,
  ShadowRoot: !1,
  SharedWorker: !1,
  SourceBuffer: !1,
  SourceBufferList: !1,
  speechSynthesis: !1,
  SpeechSynthesisEvent: !1,
  SpeechSynthesisUtterance: !1,
  StaticRange: !1,
  status: !1,
  statusbar: !1,
  StereoPannerNode: !1,
  stop: !1,
  Storage: !1,
  StorageEvent: !1,
  StorageManager: !1,
  styleMedia: !1,
  StyleSheet: !1,
  StyleSheetList: !1,
  SubtleCrypto: !1,
  SVGAElement: !1,
  SVGAngle: !1,
  SVGAnimatedAngle: !1,
  SVGAnimatedBoolean: !1,
  SVGAnimatedEnumeration: !1,
  SVGAnimatedInteger: !1,
  SVGAnimatedLength: !1,
  SVGAnimatedLengthList: !1,
  SVGAnimatedNumber: !1,
  SVGAnimatedNumberList: !1,
  SVGAnimatedPreserveAspectRatio: !1,
  SVGAnimatedRect: !1,
  SVGAnimatedString: !1,
  SVGAnimatedTransformList: !1,
  SVGAnimateElement: !1,
  SVGAnimateMotionElement: !1,
  SVGAnimateTransformElement: !1,
  SVGAnimationElement: !1,
  SVGCircleElement: !1,
  SVGClipPathElement: !1,
  SVGComponentTransferFunctionElement: !1,
  SVGDefsElement: !1,
  SVGDescElement: !1,
  SVGDiscardElement: !1,
  SVGElement: !1,
  SVGEllipseElement: !1,
  SVGFEBlendElement: !1,
  SVGFEColorMatrixElement: !1,
  SVGFEComponentTransferElement: !1,
  SVGFECompositeElement: !1,
  SVGFEConvolveMatrixElement: !1,
  SVGFEDiffuseLightingElement: !1,
  SVGFEDisplacementMapElement: !1,
  SVGFEDistantLightElement: !1,
  SVGFEDropShadowElement: !1,
  SVGFEFloodElement: !1,
  SVGFEFuncAElement: !1,
  SVGFEFuncBElement: !1,
  SVGFEFuncGElement: !1,
  SVGFEFuncRElement: !1,
  SVGFEGaussianBlurElement: !1,
  SVGFEImageElement: !1,
  SVGFEMergeElement: !1,
  SVGFEMergeNodeElement: !1,
  SVGFEMorphologyElement: !1,
  SVGFEOffsetElement: !1,
  SVGFEPointLightElement: !1,
  SVGFESpecularLightingElement: !1,
  SVGFESpotLightElement: !1,
  SVGFETileElement: !1,
  SVGFETurbulenceElement: !1,
  SVGFilterElement: !1,
  SVGForeignObjectElement: !1,
  SVGGElement: !1,
  SVGGeometryElement: !1,
  SVGGradientElement: !1,
  SVGGraphicsElement: !1,
  SVGImageElement: !1,
  SVGLength: !1,
  SVGLengthList: !1,
  SVGLinearGradientElement: !1,
  SVGLineElement: !1,
  SVGMarkerElement: !1,
  SVGMaskElement: !1,
  SVGMatrix: !1,
  SVGMetadataElement: !1,
  SVGMPathElement: !1,
  SVGNumber: !1,
  SVGNumberList: !1,
  SVGPathElement: !1,
  SVGPatternElement: !1,
  SVGPoint: !1,
  SVGPointList: !1,
  SVGPolygonElement: !1,
  SVGPolylineElement: !1,
  SVGPreserveAspectRatio: !1,
  SVGRadialGradientElement: !1,
  SVGRect: !1,
  SVGRectElement: !1,
  SVGScriptElement: !1,
  SVGSetElement: !1,
  SVGStopElement: !1,
  SVGStringList: !1,
  SVGStyleElement: !1,
  SVGSVGElement: !1,
  SVGSwitchElement: !1,
  SVGSymbolElement: !1,
  SVGTextContentElement: !1,
  SVGTextElement: !1,
  SVGTextPathElement: !1,
  SVGTextPositioningElement: !1,
  SVGTitleElement: !1,
  SVGTransform: !1,
  SVGTransformList: !1,
  SVGTSpanElement: !1,
  SVGUnitTypes: !1,
  SVGUseElement: !1,
  SVGViewElement: !1,
  TaskAttributionTiming: !1,
  Text: !1,
  TextDecoder: !1,
  TextEncoder: !1,
  TextEvent: !1,
  TextMetrics: !1,
  TextTrack: !1,
  TextTrackCue: !1,
  TextTrackCueList: !1,
  TextTrackList: !1,
  TimeRanges: !1,
  toolbar: !1,
  top: !1,
  Touch: !1,
  TouchEvent: !1,
  TouchList: !1,
  TrackEvent: !1,
  TransitionEvent: !1,
  TreeWalker: !1,
  UIEvent: !1,
  URL: !1,
  URLSearchParams: !1,
  ValidityState: !1,
  visualViewport: !1,
  VisualViewport: !1,
  VTTCue: !1,
  WaveShaperNode: !1,
  WebAssembly: !1,
  WebGL2RenderingContext: !1,
  WebGLActiveInfo: !1,
  WebGLBuffer: !1,
  WebGLContextEvent: !1,
  WebGLFramebuffer: !1,
  WebGLProgram: !1,
  WebGLQuery: !1,
  WebGLRenderbuffer: !1,
  WebGLRenderingContext: !1,
  WebGLSampler: !1,
  WebGLShader: !1,
  WebGLShaderPrecisionFormat: !1,
  WebGLSync: !1,
  WebGLTexture: !1,
  WebGLTransformFeedback: !1,
  WebGLUniformLocation: !1,
  WebGLVertexArrayObject: !1,
  WebSocket: !1,
  WheelEvent: !1,
  window: !1,
  Window: !1,
  Worker: !1,
  WritableStream: !1,
  XMLDocument: !1,
  XMLHttpRequest: !1,
  XMLHttpRequestEventTarget: !1,
  XMLHttpRequestUpload: !1,
  XMLSerializer: !1,
  XPathEvaluator: !1,
  XPathExpression: !1,
  XPathResult: !1,
  XSLTProcessor: !1
}, YN = {
  addEventListener: !1,
  applicationCache: !1,
  atob: !1,
  Blob: !1,
  BroadcastChannel: !1,
  btoa: !1,
  Cache: !1,
  caches: !1,
  clearInterval: !1,
  clearTimeout: !1,
  close: !0,
  console: !1,
  fetch: !1,
  FileReaderSync: !1,
  FormData: !1,
  Headers: !1,
  IDBCursor: !1,
  IDBCursorWithValue: !1,
  IDBDatabase: !1,
  IDBFactory: !1,
  IDBIndex: !1,
  IDBKeyRange: !1,
  IDBObjectStore: !1,
  IDBOpenDBRequest: !1,
  IDBRequest: !1,
  IDBTransaction: !1,
  IDBVersionChangeEvent: !1,
  ImageData: !1,
  importScripts: !0,
  indexedDB: !1,
  location: !1,
  MessageChannel: !1,
  MessagePort: !1,
  name: !1,
  navigator: !1,
  Notification: !1,
  onclose: !0,
  onconnect: !0,
  onerror: !0,
  onlanguagechange: !0,
  onmessage: !0,
  onoffline: !0,
  ononline: !0,
  onrejectionhandled: !0,
  onunhandledrejection: !0,
  performance: !1,
  Performance: !1,
  PerformanceEntry: !1,
  PerformanceMark: !1,
  PerformanceMeasure: !1,
  PerformanceNavigation: !1,
  PerformanceResourceTiming: !1,
  PerformanceTiming: !1,
  postMessage: !0,
  Promise: !1,
  queueMicrotask: !1,
  removeEventListener: !1,
  Request: !1,
  Response: !1,
  self: !0,
  ServiceWorkerRegistration: !1,
  setInterval: !1,
  setTimeout: !1,
  TextDecoder: !1,
  TextEncoder: !1,
  URL: !1,
  URLSearchParams: !1,
  WebSocket: !1,
  Worker: !1,
  WorkerGlobalScope: !1,
  XMLHttpRequest: !1
}, XN = {
  __dirname: !1,
  __filename: !1,
  Buffer: !1,
  clearImmediate: !1,
  clearInterval: !1,
  clearTimeout: !1,
  console: !1,
  exports: !0,
  global: !1,
  Intl: !1,
  module: !1,
  process: !1,
  queueMicrotask: !1,
  require: !1,
  setImmediate: !1,
  setInterval: !1,
  setTimeout: !1,
  TextDecoder: !1,
  TextEncoder: !1,
  URL: !1,
  URLSearchParams: !1
}, JN = {
  exports: !0,
  global: !1,
  module: !1,
  require: !1
}, HN = {
  define: !1,
  require: !1
}, GN = {
  after: !1,
  afterEach: !1,
  before: !1,
  beforeEach: !1,
  context: !1,
  describe: !1,
  it: !1,
  mocha: !1,
  run: !1,
  setup: !1,
  specify: !1,
  suite: !1,
  suiteSetup: !1,
  suiteTeardown: !1,
  teardown: !1,
  test: !1,
  xcontext: !1,
  xdescribe: !1,
  xit: !1,
  xspecify: !1
}, zN = {
  afterAll: !1,
  afterEach: !1,
  beforeAll: !1,
  beforeEach: !1,
  describe: !1,
  expect: !1,
  fail: !1,
  fdescribe: !1,
  fit: !1,
  it: !1,
  jasmine: !1,
  pending: !1,
  runs: !1,
  spyOn: !1,
  spyOnProperty: !1,
  waits: !1,
  waitsFor: !1,
  xdescribe: !1,
  xit: !1
}, QN = {
  afterAll: !1,
  afterEach: !1,
  beforeAll: !1,
  beforeEach: !1,
  describe: !1,
  expect: !1,
  fdescribe: !1,
  fit: !1,
  it: !1,
  jest: !1,
  pit: !1,
  require: !1,
  test: !1,
  xdescribe: !1,
  xit: !1,
  xtest: !1
}, ZN = {
  asyncTest: !1,
  deepEqual: !1,
  equal: !1,
  expect: !1,
  module: !1,
  notDeepEqual: !1,
  notEqual: !1,
  notOk: !1,
  notPropEqual: !1,
  notStrictEqual: !1,
  ok: !1,
  propEqual: !1,
  QUnit: !1,
  raises: !1,
  start: !1,
  stop: !1,
  strictEqual: !1,
  test: !1,
  throws: !1
}, e_ = {
  console: !0,
  exports: !0,
  phantom: !0,
  require: !0,
  WebPage: !0
}, t_ = {
  emit: !1,
  exports: !1,
  getRow: !1,
  log: !1,
  module: !1,
  provides: !1,
  require: !1,
  respond: !1,
  send: !1,
  start: !1,
  sum: !1
}, r_ = {
  defineClass: !1,
  deserialize: !1,
  gc: !1,
  help: !1,
  importClass: !1,
  importPackage: !1,
  java: !1,
  load: !1,
  loadClass: !1,
  Packages: !1,
  print: !1,
  quit: !1,
  readFile: !1,
  readUrl: !1,
  runCommand: !1,
  seal: !1,
  serialize: !1,
  spawn: !1,
  sync: !1,
  toint32: !1,
  version: !1
}, i_ = {
  __DIR__: !1,
  __FILE__: !1,
  __LINE__: !1,
  com: !1,
  edu: !1,
  exit: !1,
  java: !1,
  Java: !1,
  javafx: !1,
  JavaImporter: !1,
  javax: !1,
  JSAdapter: !1,
  load: !1,
  loadWithNewGlobal: !1,
  org: !1,
  Packages: !1,
  print: !1,
  quit: !1
}, s_ = {
  ActiveXObject: !0,
  Enumerator: !0,
  GetObject: !0,
  ScriptEngine: !0,
  ScriptEngineBuildVersion: !0,
  ScriptEngineMajorVersion: !0,
  ScriptEngineMinorVersion: !0,
  VBArray: !0,
  WScript: !0,
  WSH: !0,
  XDomainRequest: !0
}, n_ = {
  $: !1,
  jQuery: !1
}, a_ = {
  YAHOO: !1,
  YAHOO_config: !1,
  YUI: !1,
  YUI_config: !1
}, o_ = {
  cat: !1,
  cd: !1,
  chmod: !1,
  config: !1,
  cp: !1,
  dirs: !1,
  echo: !1,
  env: !1,
  error: !1,
  exec: !1,
  exit: !1,
  find: !1,
  grep: !1,
  ln: !1,
  ls: !1,
  mkdir: !1,
  mv: !1,
  popd: !1,
  pushd: !1,
  pwd: !1,
  rm: !1,
  sed: !1,
  set: !1,
  target: !1,
  tempdir: !1,
  test: !1,
  touch: !1,
  which: !1
}, l_ = {
  $: !1,
  $$: !1,
  $A: !1,
  $break: !1,
  $continue: !1,
  $F: !1,
  $H: !1,
  $R: !1,
  $w: !1,
  Abstract: !1,
  Ajax: !1,
  Autocompleter: !1,
  Builder: !1,
  Class: !1,
  Control: !1,
  Draggable: !1,
  Draggables: !1,
  Droppables: !1,
  Effect: !1,
  Element: !1,
  Enumerable: !1,
  Event: !1,
  Field: !1,
  Form: !1,
  Hash: !1,
  Insertion: !1,
  ObjectRange: !1,
  PeriodicalExecuter: !1,
  Position: !1,
  Prototype: !1,
  Scriptaculous: !1,
  Selector: !1,
  Sortable: !1,
  SortableObserver: !1,
  Sound: !1,
  Template: !1,
  Toggle: !1,
  Try: !1
}, u_ = {
  _: !1,
  $: !1,
  Accounts: !1,
  AccountsClient: !1,
  AccountsCommon: !1,
  AccountsServer: !1,
  App: !1,
  Assets: !1,
  Blaze: !1,
  check: !1,
  Cordova: !1,
  DDP: !1,
  DDPRateLimiter: !1,
  DDPServer: !1,
  Deps: !1,
  EJSON: !1,
  Email: !1,
  HTTP: !1,
  Log: !1,
  Match: !1,
  Meteor: !1,
  Mongo: !1,
  MongoInternals: !1,
  Npm: !1,
  Package: !1,
  Plugin: !1,
  process: !1,
  Random: !1,
  ReactiveDict: !1,
  ReactiveVar: !1,
  Router: !1,
  ServiceConfiguration: !1,
  Session: !1,
  share: !1,
  Spacebars: !1,
  Template: !1,
  Tinytest: !1,
  Tracker: !1,
  UI: !1,
  Utils: !1,
  WebApp: !1,
  WebAppInternals: !1
}, c_ = {
  _isWindows: !1,
  _rand: !1,
  BulkWriteResult: !1,
  cat: !1,
  cd: !1,
  connect: !1,
  db: !1,
  getHostName: !1,
  getMemInfo: !1,
  hostname: !1,
  ISODate: !1,
  listFiles: !1,
  load: !1,
  ls: !1,
  md5sumFile: !1,
  mkdir: !1,
  Mongo: !1,
  NumberInt: !1,
  NumberLong: !1,
  ObjectId: !1,
  PlanCache: !1,
  print: !1,
  printjson: !1,
  pwd: !1,
  quit: !1,
  removeFile: !1,
  rs: !1,
  sh: !1,
  UUID: !1,
  version: !1,
  WriteResult: !1
}, f_ = {
  $: !1,
  Application: !1,
  Automation: !1,
  console: !1,
  delay: !1,
  Library: !1,
  ObjC: !1,
  ObjectSpecifier: !1,
  Path: !1,
  Progress: !1,
  Ref: !1
}, p_ = {
  addEventListener: !1,
  applicationCache: !1,
  atob: !1,
  Blob: !1,
  BroadcastChannel: !1,
  btoa: !1,
  Cache: !1,
  caches: !1,
  CacheStorage: !1,
  clearInterval: !1,
  clearTimeout: !1,
  Client: !1,
  clients: !1,
  Clients: !1,
  close: !0,
  console: !1,
  ExtendableEvent: !1,
  ExtendableMessageEvent: !1,
  fetch: !1,
  FetchEvent: !1,
  FileReaderSync: !1,
  FormData: !1,
  Headers: !1,
  IDBCursor: !1,
  IDBCursorWithValue: !1,
  IDBDatabase: !1,
  IDBFactory: !1,
  IDBIndex: !1,
  IDBKeyRange: !1,
  IDBObjectStore: !1,
  IDBOpenDBRequest: !1,
  IDBRequest: !1,
  IDBTransaction: !1,
  IDBVersionChangeEvent: !1,
  ImageData: !1,
  importScripts: !1,
  indexedDB: !1,
  location: !1,
  MessageChannel: !1,
  MessagePort: !1,
  name: !1,
  navigator: !1,
  Notification: !1,
  onclose: !0,
  onconnect: !0,
  onerror: !0,
  onfetch: !0,
  oninstall: !0,
  onlanguagechange: !0,
  onmessage: !0,
  onmessageerror: !0,
  onnotificationclick: !0,
  onnotificationclose: !0,
  onoffline: !0,
  ononline: !0,
  onpush: !0,
  onpushsubscriptionchange: !0,
  onrejectionhandled: !0,
  onsync: !0,
  onunhandledrejection: !0,
  performance: !1,
  Performance: !1,
  PerformanceEntry: !1,
  PerformanceMark: !1,
  PerformanceMeasure: !1,
  PerformanceNavigation: !1,
  PerformanceResourceTiming: !1,
  PerformanceTiming: !1,
  postMessage: !0,
  Promise: !1,
  queueMicrotask: !1,
  registration: !1,
  removeEventListener: !1,
  Request: !1,
  Response: !1,
  self: !1,
  ServiceWorker: !1,
  ServiceWorkerContainer: !1,
  ServiceWorkerGlobalScope: !1,
  ServiceWorkerMessageEvent: !1,
  ServiceWorkerRegistration: !1,
  setInterval: !1,
  setTimeout: !1,
  skipWaiting: !1,
  TextDecoder: !1,
  TextEncoder: !1,
  URL: !1,
  URLSearchParams: !1,
  WebSocket: !1,
  WindowClient: !1,
  Worker: !1,
  WorkerGlobalScope: !1,
  XMLHttpRequest: !1
}, h_ = {
  advanceClock: !1,
  fakeClearInterval: !1,
  fakeClearTimeout: !1,
  fakeSetInterval: !1,
  fakeSetTimeout: !1,
  resetTimeouts: !1,
  waitsForPromise: !1
}, d_ = {
  andThen: !1,
  click: !1,
  currentPath: !1,
  currentRouteName: !1,
  currentURL: !1,
  fillIn: !1,
  find: !1,
  findAll: !1,
  findWithAssert: !1,
  keyEvent: !1,
  pauseTest: !1,
  resumeTest: !1,
  triggerEvent: !1,
  visit: !1,
  wait: !1
}, m_ = {
  $: !1,
  $$: !1,
  browser: !1,
  by: !1,
  By: !1,
  DartObject: !1,
  element: !1,
  protractor: !1
}, y_ = {
  browser: !1,
  chrome: !1,
  opr: !1
}, T_ = {
  cloneInto: !1,
  createObjectIn: !1,
  exportFunction: !1,
  GM: !1,
  GM_addStyle: !1,
  GM_deleteValue: !1,
  GM_getResourceText: !1,
  GM_getResourceURL: !1,
  GM_getValue: !1,
  GM_info: !1,
  GM_listValues: !1,
  GM_log: !1,
  GM_openInTab: !1,
  GM_registerMenuCommand: !1,
  GM_setClipboard: !1,
  GM_setValue: !1,
  GM_xmlhttpRequest: !1,
  unsafeWindow: !1
}, S_ = {
  $: !1,
  $_: !1,
  $$: !1,
  $0: !1,
  $1: !1,
  $2: !1,
  $3: !1,
  $4: !1,
  $x: !1,
  chrome: !1,
  clear: !1,
  copy: !1,
  debug: !1,
  dir: !1,
  dirxml: !1,
  getEventListeners: !1,
  inspect: !1,
  keys: !1,
  monitor: !1,
  monitorEvents: !1,
  profile: !1,
  profileEnd: !1,
  queryObjects: !1,
  table: !1,
  undebug: !1,
  unmonitor: !1,
  unmonitorEvents: !1,
  values: !1
}, b_ = {
  builtin: UN,
  es5: VN,
  es2015: KN,
  es2017: qN,
  browser: WN,
  worker: YN,
  node: XN,
  commonjs: JN,
  amd: HN,
  mocha: GN,
  jasmine: zN,
  jest: QN,
  qunit: ZN,
  phantomjs: e_,
  couch: t_,
  rhino: r_,
  nashorn: i_,
  wsh: s_,
  jquery: n_,
  yui: a_,
  shelljs: o_,
  prototypejs: l_,
  meteor: u_,
  mongo: c_,
  applescript: f_,
  serviceworker: p_,
  atomtest: h_,
  embertest: d_,
  protractor: m_,
  "shared-node-browser": {
    clearInterval: !1,
    clearTimeout: !1,
    console: !1,
    setInterval: !1,
    setTimeout: !1,
    URL: !1,
    URLSearchParams: !1
  },
  webextensions: y_,
  greasemonkey: T_,
  devtools: S_
};
var g_ = b_, $l;
function Gc() {
  if ($l)
    return Jr;
  $l = 1, Object.defineProperty(Jr, "__esModule", {
    value: !0
  }), Jr.default = void 0;
  var e = jN(), t = tn(), r = Rs, i = g_, s = Ae(), n = s, a = Ze, o = Ft;
  const {
    NOT_LOCAL_BINDING: l,
    callExpression: u,
    cloneNode: c,
    getBindingIdentifiers: p,
    identifier: h,
    isArrayExpression: y,
    isBinary: P,
    isClass: v,
    isClassBody: w,
    isClassDeclaration: x,
    isExportAllDeclaration: O,
    isExportDefaultDeclaration: _,
    isExportNamedDeclaration: K,
    isFunctionDeclaration: R,
    isIdentifier: B,
    isImportDeclaration: C,
    isLiteral: L,
    isMethod: F,
    isModuleSpecifier: te,
    isNullLiteral: Z,
    isObjectExpression: J,
    isProperty: ce,
    isPureish: me,
    isRegExpLiteral: k,
    isSuper: M,
    isTaggedTemplateExpression: D,
    isTemplateLiteral: j,
    isThisExpression: X,
    isUnaryExpression: W,
    isVariableDeclaration: ae,
    matchesPattern: ie,
    memberExpression: ge,
    numericLiteral: Ce,
    toIdentifier: je,
    unaryExpression: Je,
    variableDeclaration: He,
    variableDeclarator: We,
    isRecordExpression: Y,
    isTupleExpression: V,
    isObjectProperty: z,
    isTopicReference: ee,
    isMetaProperty: Se,
    isPrivateName: oe,
    isExportDeclaration: ye
  } = s;
  function Q($, S) {
    switch ($ == null ? void 0 : $.type) {
      default:
        if (C($) || ye($))
          if ((O($) || K($) || C($)) && $.source)
            Q($.source, S);
          else if ((K($) || C($)) && $.specifiers && $.specifiers.length)
            for (const I of $.specifiers)
              Q(I, S);
          else
            (_($) || K($)) && $.declaration && Q($.declaration, S);
        else
          te($) ? Q($.local, S) : L($) && !Z($) && !k($) && !j($) && S.push($.value);
        break;
      case "MemberExpression":
      case "OptionalMemberExpression":
      case "JSXMemberExpression":
        Q($.object, S), Q($.property, S);
        break;
      case "Identifier":
      case "JSXIdentifier":
        S.push($.name);
        break;
      case "CallExpression":
      case "OptionalCallExpression":
      case "NewExpression":
        Q($.callee, S);
        break;
      case "ObjectExpression":
      case "ObjectPattern":
        for (const I of $.properties)
          Q(I, S);
        break;
      case "SpreadElement":
      case "RestElement":
        Q($.argument, S);
        break;
      case "ObjectProperty":
      case "ObjectMethod":
      case "ClassProperty":
      case "ClassMethod":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
        Q($.key, S);
        break;
      case "ThisExpression":
        S.push("this");
        break;
      case "Super":
        S.push("super");
        break;
      case "Import":
        S.push("import");
        break;
      case "DoExpression":
        S.push("do");
        break;
      case "YieldExpression":
        S.push("yield"), Q($.argument, S);
        break;
      case "AwaitExpression":
        S.push("await"), Q($.argument, S);
        break;
      case "AssignmentExpression":
        Q($.left, S);
        break;
      case "VariableDeclarator":
        Q($.id, S);
        break;
      case "FunctionExpression":
      case "FunctionDeclaration":
      case "ClassExpression":
      case "ClassDeclaration":
        Q($.id, S);
        break;
      case "PrivateName":
        Q($.id, S);
        break;
      case "ParenthesizedExpression":
        Q($.expression, S);
        break;
      case "UnaryExpression":
      case "UpdateExpression":
        Q($.argument, S);
        break;
      case "MetaProperty":
        Q($.meta, S), Q($.property, S);
        break;
      case "JSXElement":
        Q($.openingElement, S);
        break;
      case "JSXOpeningElement":
        Q($.name, S);
        break;
      case "JSXFragment":
        Q($.openingFragment, S);
        break;
      case "JSXOpeningFragment":
        S.push("Fragment");
        break;
      case "JSXNamespacedName":
        Q($.namespace, S), Q($.name, S);
        break;
    }
  }
  const pe = {
    ForStatement($) {
      const S = $.get("init");
      if (S.isVar()) {
        const {
          scope: I
        } = $;
        (I.getFunctionParent() || I.getProgramParent()).registerBinding("var", S);
      }
    },
    Declaration($) {
      if ($.isBlockScoped() || $.isImportDeclaration() || $.isExportDeclaration())
        return;
      ($.scope.getFunctionParent() || $.scope.getProgramParent()).registerDeclaration($);
    },
    ImportDeclaration($) {
      $.scope.getBlockParent().registerDeclaration($);
    },
    ReferencedIdentifier($, S) {
      S.references.push($);
    },
    ForXStatement($, S) {
      const I = $.get("left");
      if (I.isPattern() || I.isIdentifier())
        S.constantViolations.push($);
      else if (I.isVar()) {
        const {
          scope: U
        } = $;
        (U.getFunctionParent() || U.getProgramParent()).registerBinding("var", I);
      }
    },
    ExportDeclaration: {
      exit($) {
        const {
          node: S,
          scope: I
        } = $;
        if (O(S))
          return;
        const U = S.declaration;
        if (x(U) || R(U)) {
          const G = U.id;
          if (!G)
            return;
          const ue = I.getBinding(G.name);
          ue == null || ue.reference($);
        } else if (ae(U))
          for (const G of U.declarations)
            for (const ue of Object.keys(p(G))) {
              const xe = I.getBinding(ue);
              xe == null || xe.reference($);
            }
      }
    },
    LabeledStatement($) {
      $.scope.getBlockParent().registerDeclaration($);
    },
    AssignmentExpression($, S) {
      S.assignments.push($);
    },
    UpdateExpression($, S) {
      S.constantViolations.push($);
    },
    UnaryExpression($, S) {
      $.node.operator === "delete" && S.constantViolations.push($);
    },
    BlockScoped($) {
      let S = $.scope;
      if (S.path === $ && (S = S.parent), S.getBlockParent().registerDeclaration($), $.isClassDeclaration() && $.node.id) {
        const G = $.node.id.name;
        $.scope.bindings[G] = $.scope.parent.getBinding(G);
      }
    },
    CatchClause($) {
      $.scope.registerBinding("let", $);
    },
    Function($) {
      const S = $.get("params");
      for (const I of S)
        $.scope.registerBinding("param", I);
      $.isFunctionExpression() && $.has("id") && !$.get("id").node[l] && $.scope.registerBinding("local", $.get("id"), $);
    },
    ClassExpression($) {
      $.has("id") && !$.get("id").node[l] && $.scope.registerBinding("local", $);
    }
  };
  let ve = 0;
  class De {
    constructor(S) {
      this.uid = void 0, this.path = void 0, this.block = void 0, this.labels = void 0, this.inited = void 0, this.bindings = void 0, this.references = void 0, this.globals = void 0, this.uids = void 0, this.data = void 0, this.crawling = void 0;
      const {
        node: I
      } = S, U = a.scope.get(I);
      if ((U == null ? void 0 : U.path) === S)
        return U;
      a.scope.set(I, this), this.uid = ve++, this.block = I, this.path = S, this.labels = /* @__PURE__ */ new Map(), this.inited = !1;
    }
    get parent() {
      var S;
      let I, U = this.path;
      do {
        const G = U.key === "key" || U.listKey === "decorators";
        U = U.parentPath, G && U.isMethod() && (U = U.parentPath), U && U.isScope() && (I = U);
      } while (U && !I);
      return (S = I) == null ? void 0 : S.scope;
    }
    get parentBlock() {
      return this.path.parent;
    }
    get hub() {
      return this.path.hub;
    }
    traverse(S, I, U) {
      (0, t.default)(S, I, this, U, this.path);
    }
    generateDeclaredUidIdentifier(S) {
      const I = this.generateUidIdentifier(S);
      return this.push({
        id: I
      }), c(I);
    }
    generateUidIdentifier(S) {
      return h(this.generateUid(S));
    }
    generateUid(S = "temp") {
      S = je(S).replace(/^_+/, "").replace(/[0-9]+$/g, "");
      let I, U = 1;
      do
        I = this._generateUid(S, U), U++;
      while (this.hasLabel(I) || this.hasBinding(I) || this.hasGlobal(I) || this.hasReference(I));
      const G = this.getProgramParent();
      return G.references[I] = !0, G.uids[I] = !0, I;
    }
    _generateUid(S, I) {
      let U = S;
      return I > 1 && (U += I), `_${U}`;
    }
    generateUidBasedOnNode(S, I) {
      const U = [];
      Q(S, U);
      let G = U.join("$");
      return G = G.replace(/^_/, "") || I || "ref", this.generateUid(G.slice(0, 20));
    }
    generateUidIdentifierBasedOnNode(S, I) {
      return h(this.generateUidBasedOnNode(S, I));
    }
    isStatic(S) {
      if (X(S) || M(S) || ee(S))
        return !0;
      if (B(S)) {
        const I = this.getBinding(S.name);
        return I ? I.constant : this.hasBinding(S.name);
      }
      return !1;
    }
    maybeGenerateMemoised(S, I) {
      if (this.isStatic(S))
        return null;
      {
        const U = this.generateUidIdentifierBasedOnNode(S);
        return I ? U : (this.push({
          id: U
        }), c(U));
      }
    }
    checkBlockScopedCollisions(S, I, U, G) {
      if (I === "param" || S.kind === "local")
        return;
      if (I === "let" || S.kind === "let" || S.kind === "const" || S.kind === "module" || S.kind === "param" && I === "const")
        throw this.hub.buildError(G, `Duplicate declaration "${U}"`, TypeError);
    }
    rename(S, I) {
      const U = this.getBinding(S);
      U && (I || (I = this.generateUidIdentifier(S).name), new e.default(U, S, I).rename(arguments[2]));
    }
    _renameFromMap(S, I, U, G) {
      S[I] && (S[U] = G, S[I] = null);
    }
    dump() {
      const S = "-".repeat(60);
      console.log(S);
      let I = this;
      do {
        console.log("#", I.block.type);
        for (const U of Object.keys(I.bindings)) {
          const G = I.bindings[U];
          console.log(" -", U, {
            constant: G.constant,
            references: G.references,
            violations: G.constantViolations.length,
            kind: G.kind
          });
        }
      } while (I = I.parent);
      console.log(S);
    }
    toArray(S, I, U) {
      if (B(S)) {
        const xe = this.getBinding(S.name);
        if (xe != null && xe.constant && xe.path.isGenericType("Array"))
          return S;
      }
      if (y(S))
        return S;
      if (B(S, {
        name: "arguments"
      }))
        return u(ge(ge(ge(h("Array"), h("prototype")), h("slice")), h("call")), [S]);
      let G;
      const ue = [S];
      return I === !0 ? G = "toConsumableArray" : typeof I == "number" ? (ue.push(Ce(I)), G = "slicedToArray") : G = "toArray", U && (ue.unshift(this.hub.addHelper(G)), G = "maybeArrayLike"), u(this.hub.addHelper(G), ue);
    }
    hasLabel(S) {
      return !!this.getLabel(S);
    }
    getLabel(S) {
      return this.labels.get(S);
    }
    registerLabel(S) {
      this.labels.set(S.node.label.name, S);
    }
    registerDeclaration(S) {
      if (S.isLabeledStatement())
        this.registerLabel(S);
      else if (S.isFunctionDeclaration())
        this.registerBinding("hoisted", S.get("id"), S);
      else if (S.isVariableDeclaration()) {
        const I = S.get("declarations"), {
          kind: U
        } = S.node;
        for (const G of I)
          this.registerBinding(U === "using" || U === "await using" ? "const" : U, G);
      } else if (S.isClassDeclaration()) {
        if (S.node.declare)
          return;
        this.registerBinding("let", S);
      } else if (S.isImportDeclaration()) {
        const I = S.node.importKind === "type" || S.node.importKind === "typeof", U = S.get("specifiers");
        for (const G of U) {
          const ue = I || G.isImportSpecifier() && (G.node.importKind === "type" || G.node.importKind === "typeof");
          this.registerBinding(ue ? "unknown" : "module", G);
        }
      } else if (S.isExportDeclaration()) {
        const I = S.get("declaration");
        (I.isClassDeclaration() || I.isFunctionDeclaration() || I.isVariableDeclaration()) && this.registerDeclaration(I);
      } else
        this.registerBinding("unknown", S);
    }
    buildUndefinedNode() {
      return Je("void", Ce(0), !0);
    }
    registerConstantViolation(S) {
      const I = S.getBindingIdentifiers();
      for (const G of Object.keys(I)) {
        var U;
        (U = this.getBinding(G)) == null || U.reassign(S);
      }
    }
    registerBinding(S, I, U = I) {
      if (!S)
        throw new ReferenceError("no `kind`");
      if (I.isVariableDeclaration()) {
        const xe = I.get("declarations");
        for (const Ge of xe)
          this.registerBinding(S, Ge);
        return;
      }
      const G = this.getProgramParent(), ue = I.getOuterBindingIdentifiers(!0);
      for (const xe of Object.keys(ue)) {
        G.references[xe] = !0;
        for (const Ge of ue[xe]) {
          const et = this.getOwnBinding(xe);
          if (et) {
            if (et.identifier === Ge)
              continue;
            this.checkBlockScopedCollisions(et, S, xe, Ge);
          }
          et ? this.registerConstantViolation(U) : this.bindings[xe] = new r.default({
            identifier: Ge,
            scope: this,
            path: U,
            kind: S
          });
        }
      }
    }
    addGlobal(S) {
      this.globals[S.name] = S;
    }
    hasUid(S) {
      let I = this;
      do
        if (I.uids[S])
          return !0;
      while (I = I.parent);
      return !1;
    }
    hasGlobal(S) {
      let I = this;
      do
        if (I.globals[S])
          return !0;
      while (I = I.parent);
      return !1;
    }
    hasReference(S) {
      return !!this.getProgramParent().references[S];
    }
    isPure(S, I) {
      if (B(S)) {
        const xe = this.getBinding(S.name);
        return xe ? I ? xe.constant : !0 : !1;
      } else {
        if (X(S) || Se(S) || ee(S) || oe(S))
          return !0;
        if (v(S)) {
          var U;
          return S.superClass && !this.isPure(S.superClass, I) || ((U = S.decorators) == null ? void 0 : U.length) > 0 ? !1 : this.isPure(S.body, I);
        } else if (w(S)) {
          for (const xe of S.body)
            if (!this.isPure(xe, I))
              return !1;
          return !0;
        } else {
          if (P(S))
            return this.isPure(S.left, I) && this.isPure(S.right, I);
          if (y(S) || V(S)) {
            for (const xe of S.elements)
              if (xe !== null && !this.isPure(xe, I))
                return !1;
            return !0;
          } else if (J(S) || Y(S)) {
            for (const xe of S.properties)
              if (!this.isPure(xe, I))
                return !1;
            return !0;
          } else if (F(S)) {
            var G;
            return !(S.computed && !this.isPure(S.key, I) || ((G = S.decorators) == null ? void 0 : G.length) > 0);
          } else if (ce(S)) {
            var ue;
            return !(S.computed && !this.isPure(S.key, I) || ((ue = S.decorators) == null ? void 0 : ue.length) > 0 || (z(S) || S.static) && S.value !== null && !this.isPure(S.value, I));
          } else {
            if (W(S))
              return this.isPure(S.argument, I);
            if (D(S))
              return ie(S.tag, "String.raw") && !this.hasBinding("String", !0) && this.isPure(S.quasi, I);
            if (j(S)) {
              for (const xe of S.expressions)
                if (!this.isPure(xe, I))
                  return !1;
              return !0;
            } else
              return me(S);
          }
        }
      }
    }
    setData(S, I) {
      return this.data[S] = I;
    }
    getData(S) {
      let I = this;
      do {
        const U = I.data[S];
        if (U != null)
          return U;
      } while (I = I.parent);
    }
    removeData(S) {
      let I = this;
      do
        I.data[S] != null && (I.data[S] = null);
      while (I = I.parent);
    }
    init() {
      this.inited || (this.inited = !0, this.crawl());
    }
    crawl() {
      const S = this.path;
      this.references = /* @__PURE__ */ Object.create(null), this.bindings = /* @__PURE__ */ Object.create(null), this.globals = /* @__PURE__ */ Object.create(null), this.uids = /* @__PURE__ */ Object.create(null), this.data = /* @__PURE__ */ Object.create(null);
      const I = this.getProgramParent();
      if (I.crawling)
        return;
      const U = {
        references: [],
        constantViolations: [],
        assignments: []
      };
      if (this.crawling = !0, S.type !== "Program" && (0, o.isExplodedVisitor)(pe)) {
        for (const ue of pe.enter)
          ue.call(U, S, U);
        const G = pe[S.type];
        if (G)
          for (const ue of G.enter)
            ue.call(U, S, U);
      }
      S.traverse(pe, U), this.crawling = !1;
      for (const G of U.assignments) {
        const ue = G.getBindingIdentifiers();
        for (const xe of Object.keys(ue))
          G.scope.getBinding(xe) || I.addGlobal(ue[xe]);
        G.scope.registerConstantViolation(G);
      }
      for (const G of U.references) {
        const ue = G.scope.getBinding(G.node.name);
        ue ? ue.reference(G) : I.addGlobal(G.node);
      }
      for (const G of U.constantViolations)
        G.scope.registerConstantViolation(G);
    }
    push(S) {
      let I = this.path;
      I.isPattern() ? I = this.getPatternParent().path : !I.isBlockStatement() && !I.isProgram() && (I = this.getBlockParent().path), I.isSwitchStatement() && (I = (this.getFunctionParent() || this.getProgramParent()).path);
      const {
        init: U,
        unique: G,
        kind: ue = "var",
        id: xe
      } = S;
      if (!U && !G && (ue === "var" || ue === "let") && I.isFunction() && !I.node.name && n.isCallExpression(I.parent, {
        callee: I.node
      }) && I.parent.arguments.length <= I.node.params.length && n.isIdentifier(xe)) {
        I.pushContainer("params", xe), I.scope.registerBinding("param", I.get("params")[I.node.params.length - 1]);
        return;
      }
      (I.isLoop() || I.isCatchClause() || I.isFunction()) && (I.ensureBlock(), I = I.get("body"));
      const Ge = S._blockHoist == null ? 2 : S._blockHoist, et = `declaration:${ue}:${Ge}`;
      let ot = !G && I.getData(et);
      if (!ot) {
        const ft = He(ue, []);
        ft._blockHoist = Ge, [ot] = I.unshiftContainer("body", [ft]), G || I.setData(et, ot);
      }
      const ct = We(xe, U), tt = ot.node.declarations.push(ct);
      I.scope.registerBinding(ue, ot.get("declarations")[tt - 1]);
    }
    getProgramParent() {
      let S = this;
      do
        if (S.path.isProgram())
          return S;
      while (S = S.parent);
      throw new Error("Couldn't find a Program");
    }
    getFunctionParent() {
      let S = this;
      do
        if (S.path.isFunctionParent())
          return S;
      while (S = S.parent);
      return null;
    }
    getBlockParent() {
      let S = this;
      do
        if (S.path.isBlockParent())
          return S;
      while (S = S.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getPatternParent() {
      let S = this;
      do
        if (!S.path.isPattern())
          return S.getBlockParent();
      while (S = S.parent.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getAllBindings() {
      const S = /* @__PURE__ */ Object.create(null);
      let I = this;
      do {
        for (const U of Object.keys(I.bindings))
          U in S || (S[U] = I.bindings[U]);
        I = I.parent;
      } while (I);
      return S;
    }
    getAllBindingsOfKind(...S) {
      const I = /* @__PURE__ */ Object.create(null);
      for (const U of S) {
        let G = this;
        do {
          for (const ue of Object.keys(G.bindings)) {
            const xe = G.bindings[ue];
            xe.kind === U && (I[ue] = xe);
          }
          G = G.parent;
        } while (G);
      }
      return I;
    }
    bindingIdentifierEquals(S, I) {
      return this.getBindingIdentifier(S) === I;
    }
    getBinding(S) {
      let I = this, U;
      do {
        const ue = I.getOwnBinding(S);
        if (ue) {
          var G;
          if (!((G = U) != null && G.isPattern() && ue.kind !== "param" && ue.kind !== "local"))
            return ue;
        } else if (!ue && S === "arguments" && I.path.isFunction() && !I.path.isArrowFunctionExpression())
          break;
        U = I.path;
      } while (I = I.parent);
    }
    getOwnBinding(S) {
      return this.bindings[S];
    }
    getBindingIdentifier(S) {
      var I;
      return (I = this.getBinding(S)) == null ? void 0 : I.identifier;
    }
    getOwnBindingIdentifier(S) {
      const I = this.bindings[S];
      return I == null ? void 0 : I.identifier;
    }
    hasOwnBinding(S) {
      return !!this.getOwnBinding(S);
    }
    hasBinding(S, I) {
      var U, G, ue;
      return S ? !!(this.hasOwnBinding(S) || (typeof I == "boolean" && (I = {
        noGlobals: I
      }), this.parentHasBinding(S, I)) || !((U = I) != null && U.noUids) && this.hasUid(S) || !((G = I) != null && G.noGlobals) && De.globals.includes(S) || !((ue = I) != null && ue.noGlobals) && De.contextVariables.includes(S)) : !1;
    }
    parentHasBinding(S, I) {
      var U;
      return (U = this.parent) == null ? void 0 : U.hasBinding(S, I);
    }
    moveBindingTo(S, I) {
      const U = this.getBinding(S);
      U && (U.scope.removeOwnBinding(S), U.scope = I, I.bindings[S] = U);
    }
    removeOwnBinding(S) {
      delete this.bindings[S];
    }
    removeBinding(S) {
      var I;
      (I = this.getBinding(S)) == null || I.scope.removeOwnBinding(S);
      let U = this;
      do
        U.uids[S] && (U.uids[S] = !1);
      while (U = U.parent);
    }
  }
  return Jr.default = De, De.globals = Object.keys(i.builtin), De.contextVariables = ["arguments", "undefined", "Infinity", "NaN"], Jr;
}
var Ti = {}, $s = {}, qn = { exports: {} }, Ji = { exports: {} }, Ul;
function E_() {
  return Ul || (Ul = 1, function(e, t) {
    (function(r, i) {
      i(t);
    })(zt, function(r) {
      r.get = void 0, r.put = void 0, r.pop = void 0;
      class i {
        constructor() {
          this._indexes = { __proto__: null }, this.array = [];
        }
      }
      r.get = (s, n) => s._indexes[n], r.put = (s, n) => {
        const a = r.get(s, n);
        if (a !== void 0)
          return a;
        const { array: o, _indexes: l } = s;
        return l[n] = o.push(n) - 1;
      }, r.pop = (s) => {
        const { array: n, _indexes: a } = s;
        if (n.length === 0)
          return;
        const o = n.pop();
        a[o] = void 0;
      }, r.SetArray = i, Object.defineProperty(r, "__esModule", { value: !0 });
    });
  }(Ji, Ji.exports)), Ji.exports;
}
var Hi = { exports: {} }, Vl;
function P_() {
  return Vl || (Vl = 1, function(e, t) {
    (function(r, i) {
      i(t);
    })(zt, function(r) {
      const i = ",".charCodeAt(0), s = ";".charCodeAt(0), n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a = new Uint8Array(64), o = new Uint8Array(128);
      for (let x = 0; x < n.length; x++) {
        const O = n.charCodeAt(x);
        a[x] = O, o[O] = x;
      }
      const l = typeof TextDecoder < "u" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer < "u" ? {
        decode(x) {
          return Buffer.from(x.buffer, x.byteOffset, x.byteLength).toString();
        }
      } : {
        decode(x) {
          let O = "";
          for (let _ = 0; _ < x.length; _++)
            O += String.fromCharCode(x[_]);
          return O;
        }
      };
      function u(x) {
        const O = new Int32Array(5), _ = [];
        let K = 0;
        do {
          const R = c(x, K), B = [];
          let C = !0, L = 0;
          O[0] = 0;
          for (let F = K; F < R; F++) {
            let te;
            F = p(x, F, O, 0);
            const Z = O[0];
            Z < L && (C = !1), L = Z, h(x, F, R) ? (F = p(x, F, O, 1), F = p(x, F, O, 2), F = p(x, F, O, 3), h(x, F, R) ? (F = p(x, F, O, 4), te = [Z, O[1], O[2], O[3], O[4]]) : te = [Z, O[1], O[2], O[3]]) : te = [Z], B.push(te);
          }
          C || y(B), _.push(B), K = R + 1;
        } while (K <= x.length);
        return _;
      }
      function c(x, O) {
        const _ = x.indexOf(";", O);
        return _ === -1 ? x.length : _;
      }
      function p(x, O, _, K) {
        let R = 0, B = 0, C = 0;
        do {
          const F = x.charCodeAt(O++);
          C = o[F], R |= (C & 31) << B, B += 5;
        } while (C & 32);
        const L = R & 1;
        return R >>>= 1, L && (R = -2147483648 | -R), _[K] += R, O;
      }
      function h(x, O, _) {
        return O >= _ ? !1 : x.charCodeAt(O) !== i;
      }
      function y(x) {
        x.sort(P);
      }
      function P(x, O) {
        return x[0] - O[0];
      }
      function v(x) {
        const O = new Int32Array(5), _ = 1024 * 16, K = _ - 36, R = new Uint8Array(_), B = R.subarray(0, K);
        let C = 0, L = "";
        for (let F = 0; F < x.length; F++) {
          const te = x[F];
          if (F > 0 && (C === _ && (L += l.decode(R), C = 0), R[C++] = s), te.length !== 0) {
            O[0] = 0;
            for (let Z = 0; Z < te.length; Z++) {
              const J = te[Z];
              C > K && (L += l.decode(B), R.copyWithin(0, K, C), C -= K), Z > 0 && (R[C++] = i), C = w(R, C, O, J, 0), J.length !== 1 && (C = w(R, C, O, J, 1), C = w(R, C, O, J, 2), C = w(R, C, O, J, 3), J.length !== 4 && (C = w(R, C, O, J, 4)));
            }
          }
        }
        return L + l.decode(R.subarray(0, C));
      }
      function w(x, O, _, K, R) {
        const B = K[R];
        let C = B - _[R];
        _[R] = B, C = C < 0 ? -C << 1 | 1 : C << 1;
        do {
          let L = C & 31;
          C >>>= 5, C > 0 && (L |= 32), x[O++] = a[L];
        } while (C > 0);
        return O;
      }
      r.decode = u, r.encode = v, Object.defineProperty(r, "__esModule", { value: !0 });
    });
  }(Hi, Hi.exports)), Hi.exports;
}
var Wn = { exports: {} }, Gi = { exports: {} }, Kl;
function x_() {
  return Kl || (Kl = 1, function(e, t) {
    (function(r, i) {
      i(t);
    })(zt, function(r) {
      const i = ",".charCodeAt(0), s = ";".charCodeAt(0), n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a = new Uint8Array(64), o = new Uint8Array(128);
      for (let x = 0; x < n.length; x++) {
        const O = n.charCodeAt(x);
        a[x] = O, o[O] = x;
      }
      const l = typeof TextDecoder < "u" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer < "u" ? {
        decode(x) {
          return Buffer.from(x.buffer, x.byteOffset, x.byteLength).toString();
        }
      } : {
        decode(x) {
          let O = "";
          for (let _ = 0; _ < x.length; _++)
            O += String.fromCharCode(x[_]);
          return O;
        }
      };
      function u(x) {
        const O = new Int32Array(5), _ = [];
        let K = 0;
        do {
          const R = c(x, K), B = [];
          let C = !0, L = 0;
          O[0] = 0;
          for (let F = K; F < R; F++) {
            let te;
            F = p(x, F, O, 0);
            const Z = O[0];
            Z < L && (C = !1), L = Z, h(x, F, R) ? (F = p(x, F, O, 1), F = p(x, F, O, 2), F = p(x, F, O, 3), h(x, F, R) ? (F = p(x, F, O, 4), te = [Z, O[1], O[2], O[3], O[4]]) : te = [Z, O[1], O[2], O[3]]) : te = [Z], B.push(te);
          }
          C || y(B), _.push(B), K = R + 1;
        } while (K <= x.length);
        return _;
      }
      function c(x, O) {
        const _ = x.indexOf(";", O);
        return _ === -1 ? x.length : _;
      }
      function p(x, O, _, K) {
        let R = 0, B = 0, C = 0;
        do {
          const F = x.charCodeAt(O++);
          C = o[F], R |= (C & 31) << B, B += 5;
        } while (C & 32);
        const L = R & 1;
        return R >>>= 1, L && (R = -2147483648 | -R), _[K] += R, O;
      }
      function h(x, O, _) {
        return O >= _ ? !1 : x.charCodeAt(O) !== i;
      }
      function y(x) {
        x.sort(P);
      }
      function P(x, O) {
        return x[0] - O[0];
      }
      function v(x) {
        const O = new Int32Array(5), _ = 1024 * 16, K = _ - 36, R = new Uint8Array(_), B = R.subarray(0, K);
        let C = 0, L = "";
        for (let F = 0; F < x.length; F++) {
          const te = x[F];
          if (F > 0 && (C === _ && (L += l.decode(R), C = 0), R[C++] = s), te.length !== 0) {
            O[0] = 0;
            for (let Z = 0; Z < te.length; Z++) {
              const J = te[Z];
              C > K && (L += l.decode(B), R.copyWithin(0, K, C), C -= K), Z > 0 && (R[C++] = i), C = w(R, C, O, J, 0), J.length !== 1 && (C = w(R, C, O, J, 1), C = w(R, C, O, J, 2), C = w(R, C, O, J, 3), J.length !== 4 && (C = w(R, C, O, J, 4)));
            }
          }
        }
        return L + l.decode(R.subarray(0, C));
      }
      function w(x, O, _, K, R) {
        const B = K[R];
        let C = B - _[R];
        _[R] = B, C = C < 0 ? -C << 1 | 1 : C << 1;
        do {
          let L = C & 31;
          C >>>= 5, C > 0 && (L |= 32), x[O++] = a[L];
        } while (C > 0);
        return O;
      }
      r.decode = u, r.encode = v, Object.defineProperty(r, "__esModule", { value: !0 });
    });
  }(Gi, Gi.exports)), Gi.exports;
}
var gn = { exports: {} }, ql;
function v_() {
  return ql || (ql = 1, function(e, t) {
    (function(r, i) {
      e.exports = i();
    })(zt, function() {
      const r = /^[\w+.-]+:\/\//, i = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/, s = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
      var n;
      (function(_) {
        _[_.Empty = 1] = "Empty", _[_.Hash = 2] = "Hash", _[_.Query = 3] = "Query", _[_.RelativePath = 4] = "RelativePath", _[_.AbsolutePath = 5] = "AbsolutePath", _[_.SchemeRelative = 6] = "SchemeRelative", _[_.Absolute = 7] = "Absolute";
      })(n || (n = {}));
      function a(_) {
        return r.test(_);
      }
      function o(_) {
        return _.startsWith("//");
      }
      function l(_) {
        return _.startsWith("/");
      }
      function u(_) {
        return _.startsWith("file:");
      }
      function c(_) {
        return /^[.?#]/.test(_);
      }
      function p(_) {
        const K = i.exec(_);
        return y(K[1], K[2] || "", K[3], K[4] || "", K[5] || "/", K[6] || "", K[7] || "");
      }
      function h(_) {
        const K = s.exec(_), R = K[2];
        return y("file:", "", K[1] || "", "", l(R) ? R : "/" + R, K[3] || "", K[4] || "");
      }
      function y(_, K, R, B, C, L, F) {
        return {
          scheme: _,
          user: K,
          host: R,
          port: B,
          path: C,
          query: L,
          hash: F,
          type: n.Absolute
        };
      }
      function P(_) {
        if (o(_)) {
          const R = p("http:" + _);
          return R.scheme = "", R.type = n.SchemeRelative, R;
        }
        if (l(_)) {
          const R = p("http://foo.com" + _);
          return R.scheme = "", R.host = "", R.type = n.AbsolutePath, R;
        }
        if (u(_))
          return h(_);
        if (a(_))
          return p(_);
        const K = p("http://foo.com/" + _);
        return K.scheme = "", K.host = "", K.type = _ ? _.startsWith("?") ? n.Query : _.startsWith("#") ? n.Hash : n.RelativePath : n.Empty, K;
      }
      function v(_) {
        if (_.endsWith("/.."))
          return _;
        const K = _.lastIndexOf("/");
        return _.slice(0, K + 1);
      }
      function w(_, K) {
        x(K, K.type), _.path === "/" ? _.path = K.path : _.path = v(K.path) + _.path;
      }
      function x(_, K) {
        const R = K <= n.RelativePath, B = _.path.split("/");
        let C = 1, L = 0, F = !1;
        for (let Z = 1; Z < B.length; Z++) {
          const J = B[Z];
          if (!J) {
            F = !0;
            continue;
          }
          if (F = !1, J !== ".") {
            if (J === "..") {
              L ? (F = !0, L--, C--) : R && (B[C++] = J);
              continue;
            }
            B[C++] = J, L++;
          }
        }
        let te = "";
        for (let Z = 1; Z < C; Z++)
          te += "/" + B[Z];
        (!te || F && !te.endsWith("/..")) && (te += "/"), _.path = te;
      }
      function O(_, K) {
        if (!_ && !K)
          return "";
        const R = P(_);
        let B = R.type;
        if (K && B !== n.Absolute) {
          const L = P(K), F = L.type;
          switch (B) {
            case n.Empty:
              R.hash = L.hash;
            case n.Hash:
              R.query = L.query;
            case n.Query:
            case n.RelativePath:
              w(R, L);
            case n.AbsolutePath:
              R.user = L.user, R.host = L.host, R.port = L.port;
            case n.SchemeRelative:
              R.scheme = L.scheme;
          }
          F > B && (B = F);
        }
        x(R, B);
        const C = R.query + R.hash;
        switch (B) {
          case n.Hash:
          case n.Query:
            return C;
          case n.RelativePath: {
            const L = R.path.slice(1);
            return L ? c(K || _) && !c(L) ? "./" + L + C : L + C : C || ".";
          }
          case n.AbsolutePath:
            return R.path + C;
          default:
            return R.scheme + "//" + R.user + R.host + R.port + R.path + C;
        }
      }
      return O;
    });
  }(gn)), gn.exports;
}
(function(e, t) {
  (function(r, i) {
    i(t, x_(), v_());
  })(zt, function(r, i, s) {
    function n(Y) {
      return Y && typeof Y == "object" && "default" in Y ? Y : { default: Y };
    }
    var a = /* @__PURE__ */ n(s);
    function o(Y, V) {
      return V && !V.endsWith("/") && (V += "/"), a.default(Y, V);
    }
    function l(Y) {
      if (!Y)
        return "";
      const V = Y.lastIndexOf("/");
      return Y.slice(0, V + 1);
    }
    const u = 0, c = 1, p = 2, h = 3, y = 4, P = 1, v = 2;
    function w(Y, V) {
      const z = x(Y, 0);
      if (z === Y.length)
        return Y;
      V || (Y = Y.slice());
      for (let ee = z; ee < Y.length; ee = x(Y, ee + 1))
        Y[ee] = _(Y[ee], V);
      return Y;
    }
    function x(Y, V) {
      for (let z = V; z < Y.length; z++)
        if (!O(Y[z]))
          return z;
      return Y.length;
    }
    function O(Y) {
      for (let V = 1; V < Y.length; V++)
        if (Y[V][u] < Y[V - 1][u])
          return !1;
      return !0;
    }
    function _(Y, V) {
      return V || (Y = Y.slice()), Y.sort(K);
    }
    function K(Y, V) {
      return Y[u] - V[u];
    }
    let R = !1;
    function B(Y, V, z, ee) {
      for (; z <= ee; ) {
        const Se = z + (ee - z >> 1), oe = Y[Se][u] - V;
        if (oe === 0)
          return R = !0, Se;
        oe < 0 ? z = Se + 1 : ee = Se - 1;
      }
      return R = !1, z - 1;
    }
    function C(Y, V, z) {
      for (let ee = z + 1; ee < Y.length && Y[ee][u] === V; z = ee++)
        ;
      return z;
    }
    function L(Y, V, z) {
      for (let ee = z - 1; ee >= 0 && Y[ee][u] === V; z = ee--)
        ;
      return z;
    }
    function F() {
      return {
        lastKey: -1,
        lastNeedle: -1,
        lastIndex: -1
      };
    }
    function te(Y, V, z, ee) {
      const { lastKey: Se, lastNeedle: oe, lastIndex: ye } = z;
      let Q = 0, pe = Y.length - 1;
      if (ee === Se) {
        if (V === oe)
          return R = ye !== -1 && Y[ye][u] === V, ye;
        V >= oe ? Q = ye === -1 ? 0 : ye : pe = ye;
      }
      return z.lastKey = ee, z.lastNeedle = V, z.lastIndex = B(Y, V, Q, pe);
    }
    function Z(Y, V) {
      const z = V.map(ce);
      for (let ee = 0; ee < Y.length; ee++) {
        const Se = Y[ee];
        for (let oe = 0; oe < Se.length; oe++) {
          const ye = Se[oe];
          if (ye.length === 1)
            continue;
          const Q = ye[c], pe = ye[p], ve = ye[h], De = z[Q], $ = De[pe] || (De[pe] = []), S = V[Q], I = C($, ve, te($, ve, S, pe));
          J($, S.lastIndex = I + 1, [ve, ee, ye[u]]);
        }
      }
      return z;
    }
    function J(Y, V, z) {
      for (let ee = Y.length; ee > V; ee--)
        Y[ee] = Y[ee - 1];
      Y[V] = z;
    }
    function ce() {
      return { __proto__: null };
    }
    const me = function(Y, V) {
      const z = typeof Y == "string" ? JSON.parse(Y) : Y;
      if (!("sections" in z))
        return new ge(z, V);
      const ee = [], Se = [], oe = [], ye = [];
      k(z, V, ee, Se, oe, ye, 0, 0, 1 / 0, 1 / 0);
      const Q = {
        version: 3,
        file: z.file,
        names: ye,
        sources: Se,
        sourcesContent: oe,
        mappings: ee
      };
      return r.presortedDecodedMap(Q);
    };
    function k(Y, V, z, ee, Se, oe, ye, Q, pe, ve) {
      const { sections: De } = Y;
      for (let $ = 0; $ < De.length; $++) {
        const { map: S, offset: I } = De[$];
        let U = pe, G = ve;
        if ($ + 1 < De.length) {
          const ue = De[$ + 1].offset;
          U = Math.min(pe, ye + ue.line), U === pe ? G = Math.min(ve, Q + ue.column) : U < pe && (G = Q + ue.column);
        }
        M(S, V, z, ee, Se, oe, ye + I.line, Q + I.column, U, G);
      }
    }
    function M(Y, V, z, ee, Se, oe, ye, Q, pe, ve) {
      if ("sections" in Y)
        return k(...arguments);
      const De = new ge(Y, V), $ = ee.length, S = oe.length, I = r.decodedMappings(De), { resolvedSources: U, sourcesContent: G } = De;
      if (D(ee, U), D(oe, De.names), G)
        D(Se, G);
      else
        for (let ue = 0; ue < U.length; ue++)
          Se.push(null);
      for (let ue = 0; ue < I.length; ue++) {
        const xe = ye + ue;
        if (xe > pe)
          return;
        const Ge = j(z, xe), et = ue === 0 ? Q : 0, ot = I[ue];
        for (let ct = 0; ct < ot.length; ct++) {
          const tt = ot[ct], ft = et + tt[u];
          if (xe === pe && ft >= ve)
            return;
          if (tt.length === 1) {
            Ge.push([ft]);
            continue;
          }
          const re = $ + tt[c], gr = tt[p], er = tt[h];
          Ge.push(tt.length === 4 ? [ft, re, gr, er] : [ft, re, gr, er, S + tt[y]]);
        }
      }
    }
    function D(Y, V) {
      for (let z = 0; z < V.length; z++)
        Y.push(V[z]);
    }
    function j(Y, V) {
      for (let z = Y.length; z <= V; z++)
        Y[z] = [];
      return Y[V];
    }
    const X = "`line` must be greater than 0 (lines start at line 1)", W = "`column` must be greater than or equal to 0 (columns start at column 0)", ae = -1, ie = 1;
    r.encodedMappings = void 0, r.decodedMappings = void 0, r.traceSegment = void 0, r.originalPositionFor = void 0, r.generatedPositionFor = void 0, r.allGeneratedPositionsFor = void 0, r.eachMapping = void 0, r.sourceContentFor = void 0, r.presortedDecodedMap = void 0, r.decodedMap = void 0, r.encodedMap = void 0;
    class ge {
      constructor(V, z) {
        const ee = typeof V == "string";
        if (!ee && V._decodedMemo)
          return V;
        const Se = ee ? JSON.parse(V) : V, { version: oe, file: ye, names: Q, sourceRoot: pe, sources: ve, sourcesContent: De } = Se;
        this.version = oe, this.file = ye, this.names = Q, this.sourceRoot = pe, this.sources = ve, this.sourcesContent = De;
        const $ = o(pe || "", l(z));
        this.resolvedSources = ve.map((I) => o(I || "", $));
        const { mappings: S } = Se;
        typeof S == "string" ? (this._encoded = S, this._decoded = void 0) : (this._encoded = void 0, this._decoded = w(S, ee)), this._decodedMemo = F(), this._bySources = void 0, this._bySourceMemos = void 0;
      }
    }
    (() => {
      r.encodedMappings = (V) => {
        var z;
        return (z = V._encoded) !== null && z !== void 0 ? z : V._encoded = i.encode(V._decoded);
      }, r.decodedMappings = (V) => V._decoded || (V._decoded = i.decode(V._encoded)), r.traceSegment = (V, z, ee) => {
        const Se = r.decodedMappings(V);
        if (z >= Se.length)
          return null;
        const oe = Se[z], ye = He(oe, V._decodedMemo, z, ee, ie);
        return ye === -1 ? null : oe[ye];
      }, r.originalPositionFor = (V, { line: z, column: ee, bias: Se }) => {
        if (z--, z < 0)
          throw new Error(X);
        if (ee < 0)
          throw new Error(W);
        const oe = r.decodedMappings(V);
        if (z >= oe.length)
          return je(null, null, null, null);
        const ye = oe[z], Q = He(ye, V._decodedMemo, z, ee, Se || ie);
        if (Q === -1)
          return je(null, null, null, null);
        const pe = ye[Q];
        if (pe.length === 1)
          return je(null, null, null, null);
        const { names: ve, resolvedSources: De } = V;
        return je(De[pe[c]], pe[p] + 1, pe[h], pe.length === 5 ? ve[pe[y]] : null);
      }, r.allGeneratedPositionsFor = (V, { source: z, line: ee, column: Se, bias: oe }) => Y(V, z, ee, Se, oe || ae, !0), r.generatedPositionFor = (V, { source: z, line: ee, column: Se, bias: oe }) => Y(V, z, ee, Se, oe || ie, !1), r.eachMapping = (V, z) => {
        const ee = r.decodedMappings(V), { names: Se, resolvedSources: oe } = V;
        for (let ye = 0; ye < ee.length; ye++) {
          const Q = ee[ye];
          for (let pe = 0; pe < Q.length; pe++) {
            const ve = Q[pe], De = ye + 1, $ = ve[0];
            let S = null, I = null, U = null, G = null;
            ve.length !== 1 && (S = oe[ve[1]], I = ve[2] + 1, U = ve[3]), ve.length === 5 && (G = Se[ve[4]]), z({
              generatedLine: De,
              generatedColumn: $,
              source: S,
              originalLine: I,
              originalColumn: U,
              name: G
            });
          }
        }
      }, r.sourceContentFor = (V, z) => {
        const { sources: ee, resolvedSources: Se, sourcesContent: oe } = V;
        if (oe == null)
          return null;
        let ye = ee.indexOf(z);
        return ye === -1 && (ye = Se.indexOf(z)), ye === -1 ? null : oe[ye];
      }, r.presortedDecodedMap = (V, z) => {
        const ee = new ge(Ce(V, []), z);
        return ee._decoded = V.mappings, ee;
      }, r.decodedMap = (V) => Ce(V, r.decodedMappings(V)), r.encodedMap = (V) => Ce(V, r.encodedMappings(V));
      function Y(V, z, ee, Se, oe, ye) {
        if (ee--, ee < 0)
          throw new Error(X);
        if (Se < 0)
          throw new Error(W);
        const { sources: Q, resolvedSources: pe } = V;
        let ve = Q.indexOf(z);
        if (ve === -1 && (ve = pe.indexOf(z)), ve === -1)
          return ye ? [] : Je(null, null);
        const $ = (V._bySources || (V._bySources = Z(r.decodedMappings(V), V._bySourceMemos = Q.map(F))))[ve][ee];
        if ($ == null)
          return ye ? [] : Je(null, null);
        const S = V._bySourceMemos[ve];
        if (ye)
          return We($, S, ee, Se, oe);
        const I = He($, S, ee, Se, oe);
        if (I === -1)
          return Je(null, null);
        const U = $[I];
        return Je(U[P] + 1, U[v]);
      }
    })();
    function Ce(Y, V) {
      return {
        version: Y.version,
        file: Y.file,
        names: Y.names,
        sourceRoot: Y.sourceRoot,
        sources: Y.sources,
        sourcesContent: Y.sourcesContent,
        mappings: V
      };
    }
    function je(Y, V, z, ee) {
      return { source: Y, line: V, column: z, name: ee };
    }
    function Je(Y, V) {
      return { line: Y, column: V };
    }
    function He(Y, V, z, ee, Se) {
      let oe = te(Y, ee, V, z);
      return R ? oe = (Se === ae ? C : L)(Y, ee, oe) : Se === ae && oe++, oe === -1 || oe === Y.length ? -1 : oe;
    }
    function We(Y, V, z, ee, Se) {
      let oe = He(Y, V, z, ee, ie);
      if (!R && Se === ae && oe++, oe === -1 || oe === Y.length)
        return [];
      const ye = R ? ee : Y[oe][u];
      R || (oe = L(Y, ye, oe));
      const Q = C(Y, ye, oe), pe = [];
      for (; oe <= Q; oe++) {
        const ve = Y[oe];
        pe.push(Je(ve[P] + 1, ve[v]));
      }
      return pe;
    }
    r.AnyMap = me, r.GREATEST_LOWER_BOUND = ie, r.LEAST_UPPER_BOUND = ae, r.TraceMap = ge, Object.defineProperty(r, "__esModule", { value: !0 });
  });
})(Wn, Wn.exports);
var zc = Wn.exports;
(function(e, t) {
  (function(r, i) {
    i(t, E_(), P_(), zc);
  })(zt, function(r, i, s, n) {
    r.addSegment = void 0, r.addMapping = void 0, r.maybeAddSegment = void 0, r.maybeAddMapping = void 0, r.setSourceContent = void 0, r.toDecodedMap = void 0, r.toEncodedMap = void 0, r.fromMap = void 0, r.allMappings = void 0;
    let h;
    class y {
      constructor({ file: C, sourceRoot: L } = {}) {
        this._names = new i.SetArray(), this._sources = new i.SetArray(), this._sourcesContent = [], this._mappings = [], this.file = C, this.sourceRoot = L;
      }
    }
    r.addSegment = (B, C, L, F, te, Z, J, ce) => h(!1, B, C, L, F, te, Z, J, ce), r.maybeAddSegment = (B, C, L, F, te, Z, J, ce) => h(!0, B, C, L, F, te, Z, J, ce), r.addMapping = (B, C) => R(!1, B, C), r.maybeAddMapping = (B, C) => R(!0, B, C), r.setSourceContent = (B, C, L) => {
      const { _sources: F, _sourcesContent: te } = B;
      te[i.put(F, C)] = L;
    }, r.toDecodedMap = (B) => {
      const { file: C, sourceRoot: L, _mappings: F, _sources: te, _sourcesContent: Z, _names: J } = B;
      return x(F), {
        version: 3,
        file: C || void 0,
        names: J.array,
        sourceRoot: L || void 0,
        sources: te.array,
        sourcesContent: Z,
        mappings: F
      };
    }, r.toEncodedMap = (B) => {
      const C = r.toDecodedMap(B);
      return Object.assign(Object.assign({}, C), { mappings: s.encode(C.mappings) });
    }, r.allMappings = (B) => {
      const C = [], { _mappings: L, _sources: F, _names: te } = B;
      for (let Z = 0; Z < L.length; Z++) {
        const J = L[Z];
        for (let ce = 0; ce < J.length; ce++) {
          const me = J[ce], k = { line: Z + 1, column: me[0] };
          let M, D, j;
          me.length !== 1 && (M = F.array[me[1]], D = { line: me[2] + 1, column: me[3] }, me.length === 5 && (j = te.array[me[4]])), C.push({ generated: k, source: M, original: D, name: j });
        }
      }
      return C;
    }, r.fromMap = (B) => {
      const C = new n.TraceMap(B), L = new y({ file: C.file, sourceRoot: C.sourceRoot });
      return O(L._names, C.names), O(L._sources, C.sources), L._sourcesContent = C.sourcesContent || C.sources.map(() => null), L._mappings = n.decodedMappings(C), L;
    }, h = (B, C, L, F, te, Z, J, ce, me) => {
      const { _mappings: k, _sources: M, _sourcesContent: D, _names: j } = C, X = P(k, L), W = v(X, F);
      if (!te)
        return B && _(X, W) ? void 0 : w(X, W, [F]);
      const ae = i.put(M, te), ie = ce ? i.put(j, ce) : -1;
      if (ae === D.length && (D[ae] = me ?? null), !(B && K(X, W, ae, Z, J, ie)))
        return w(X, W, ce ? [F, ae, Z, J, ie] : [F, ae, Z, J]);
    };
    function P(B, C) {
      for (let L = B.length; L <= C; L++)
        B[L] = [];
      return B[C];
    }
    function v(B, C) {
      let L = B.length;
      for (let F = L - 1; F >= 0; L = F--) {
        const te = B[F];
        if (C >= te[0])
          break;
      }
      return L;
    }
    function w(B, C, L) {
      for (let F = B.length; F > C; F--)
        B[F] = B[F - 1];
      B[C] = L;
    }
    function x(B) {
      const { length: C } = B;
      let L = C;
      for (let F = L - 1; F >= 0 && !(B[F].length > 0); L = F, F--)
        ;
      L < C && (B.length = L);
    }
    function O(B, C) {
      for (let L = 0; L < C.length; L++)
        i.put(B, C[L]);
    }
    function _(B, C) {
      return C === 0 ? !0 : B[C - 1].length === 1;
    }
    function K(B, C, L, F, te, Z) {
      if (C === 0)
        return !1;
      const J = B[C - 1];
      return J.length === 1 ? !1 : L === J[1] && F === J[2] && te === J[3] && Z === (J.length === 5 ? J[4] : -1);
    }
    function R(B, C, L) {
      const { generated: F, source: te, original: Z, name: J, content: ce } = L;
      if (!te)
        return h(B, C, F.line - 1, F.column, null, null, null, null, null);
      const me = te;
      return h(B, C, F.line - 1, F.column, me, Z.line - 1, Z.column, J, ce);
    }
    r.GenMapping = y, Object.defineProperty(r, "__esModule", { value: !0 });
  });
})(qn, qn.exports);
var A_ = qn.exports;
Object.defineProperty($s, "__esModule", {
  value: !0
});
$s.default = void 0;
var Kt = A_, En = zc;
class C_ {
  constructor(t, r) {
    var i;
    this._map = void 0, this._rawMappings = void 0, this._sourceFileName = void 0, this._lastGenLine = 0, this._lastSourceLine = 0, this._lastSourceColumn = 0, this._inputMap = void 0;
    const s = this._map = new Kt.GenMapping({
      sourceRoot: t.sourceRoot
    });
    if (this._sourceFileName = (i = t.sourceFileName) == null ? void 0 : i.replace(/\\/g, "/"), this._rawMappings = void 0, t.inputSourceMap) {
      this._inputMap = new En.TraceMap(t.inputSourceMap);
      const a = this._inputMap.resolvedSources;
      if (a.length)
        for (let o = 0; o < a.length; o++) {
          var n;
          (0, Kt.setSourceContent)(s, a[o], (n = this._inputMap.sourcesContent) == null ? void 0 : n[o]);
        }
    }
    if (typeof r == "string" && !t.inputSourceMap)
      (0, Kt.setSourceContent)(s, this._sourceFileName, r);
    else if (typeof r == "object")
      for (const a of Object.keys(r))
        (0, Kt.setSourceContent)(s, a.replace(/\\/g, "/"), r[a]);
  }
  get() {
    return (0, Kt.toEncodedMap)(this._map);
  }
  getDecoded() {
    return (0, Kt.toDecodedMap)(this._map);
  }
  getRawMappings() {
    return this._rawMappings || (this._rawMappings = (0, Kt.allMappings)(this._map));
  }
  mark(t, r, i, s, n, a) {
    var o;
    this._rawMappings = void 0;
    let l;
    if (r != null)
      if (this._inputMap) {
        if (l = (0, En.originalPositionFor)(this._inputMap, {
          line: r,
          column: i
        }), !l.name && n) {
          const u = (0, En.originalPositionFor)(this._inputMap, n);
          u.name && (s = u.name);
        }
      } else
        l = {
          source: (a == null ? void 0 : a.replace(/\\/g, "/")) || this._sourceFileName,
          line: r,
          column: i
        };
    (0, Kt.maybeAddMapping)(this._map, {
      name: s,
      generated: t,
      source: (o = l) == null ? void 0 : o.source,
      original: l
    });
  }
}
$s.default = C_;
var Us = {}, Vs = {};
Object.defineProperty(Vs, "__esModule", {
  value: !0
});
Vs.default = void 0;
let I_ = class {
  constructor(t) {
    this._map = null, this._buf = "", this._str = "", this._appendCount = 0, this._last = 0, this._queue = [], this._queueCursor = 0, this._canMarkIdName = !0, this._position = {
      line: 1,
      column: 0
    }, this._sourcePosition = {
      identifierName: void 0,
      identifierNamePos: void 0,
      line: void 0,
      column: void 0,
      filename: void 0
    }, this._map = t, this._allocQueue();
  }
  _allocQueue() {
    const t = this._queue;
    for (let r = 0; r < 16; r++)
      t.push({
        char: 0,
        repeat: 1,
        line: void 0,
        column: void 0,
        identifierName: void 0,
        identifierNamePos: void 0,
        filename: ""
      });
  }
  _pushQueue(t, r, i, s, n) {
    const a = this._queueCursor;
    a === this._queue.length && this._allocQueue();
    const o = this._queue[a];
    o.char = t, o.repeat = r, o.line = i, o.column = s, o.filename = n, this._queueCursor++;
  }
  _popQueue() {
    if (this._queueCursor === 0)
      throw new Error("Cannot pop from empty queue");
    return this._queue[--this._queueCursor];
  }
  get() {
    this._flush();
    const t = this._map, r = {
      code: (this._buf + this._str).trimRight(),
      decodedMap: t == null ? void 0 : t.getDecoded(),
      get __mergedMap() {
        return this.map;
      },
      get map() {
        const i = t ? t.get() : null;
        return r.map = i, i;
      },
      set map(i) {
        Object.defineProperty(r, "map", {
          value: i,
          writable: !0
        });
      },
      get rawMappings() {
        const i = t == null ? void 0 : t.getRawMappings();
        return r.rawMappings = i, i;
      },
      set rawMappings(i) {
        Object.defineProperty(r, "rawMappings", {
          value: i,
          writable: !0
        });
      }
    };
    return r;
  }
  append(t, r) {
    this._flush(), this._append(t, this._sourcePosition, r);
  }
  appendChar(t) {
    this._flush(), this._appendChar(t, 1, this._sourcePosition);
  }
  queue(t) {
    if (t === 10)
      for (; this._queueCursor !== 0; ) {
        const i = this._queue[this._queueCursor - 1].char;
        if (i !== 32 && i !== 9)
          break;
        this._queueCursor--;
      }
    const r = this._sourcePosition;
    this._pushQueue(t, 1, r.line, r.column, r.filename);
  }
  queueIndentation(t, r) {
    this._pushQueue(t, r, void 0, void 0, void 0);
  }
  _flush() {
    const t = this._queueCursor, r = this._queue;
    for (let i = 0; i < t; i++) {
      const s = r[i];
      this._appendChar(s.char, s.repeat, s);
    }
    this._queueCursor = 0;
  }
  _appendChar(t, r, i) {
    this._last = t, this._str += r > 1 ? String.fromCharCode(t).repeat(r) : String.fromCharCode(t), t !== 10 ? (this._mark(i.line, i.column, i.identifierName, i.identifierNamePos, i.filename), this._position.column += r) : (this._position.line++, this._position.column = 0), this._canMarkIdName && (i.identifierName = void 0, i.identifierNamePos = void 0);
  }
  _append(t, r, i) {
    const s = t.length, n = this._position;
    if (this._last = t.charCodeAt(s - 1), ++this._appendCount > 4096 ? (+this._str, this._buf += this._str, this._str = t, this._appendCount = 0) : this._str += t, !i && !this._map) {
      n.column += s;
      return;
    }
    const {
      column: a,
      identifierName: o,
      identifierNamePos: l,
      filename: u
    } = r;
    let c = r.line;
    (o != null || l != null) && this._canMarkIdName && (r.identifierName = void 0, r.identifierNamePos = void 0);
    let p = t.indexOf(`
`), h = 0;
    for (p !== 0 && this._mark(c, a, o, l, u); p !== -1; )
      n.line++, n.column = 0, h = p + 1, h < s && c !== void 0 && this._mark(++c, 0, null, null, u), p = t.indexOf(`
`, h);
    n.column += s - h;
  }
  _mark(t, r, i, s, n) {
    var a;
    (a = this._map) == null || a.mark(this._position, t, r, i, s, n);
  }
  removeTrailingNewline() {
    const t = this._queueCursor;
    t !== 0 && this._queue[t - 1].char === 10 && this._queueCursor--;
  }
  removeLastSemicolon() {
    const t = this._queueCursor;
    t !== 0 && this._queue[t - 1].char === 59 && this._queueCursor--;
  }
  getLastChar() {
    const t = this._queueCursor;
    return t !== 0 ? this._queue[t - 1].char : this._last;
  }
  getNewlineCount() {
    const t = this._queueCursor;
    let r = 0;
    if (t === 0)
      return this._last === 10 ? 1 : 0;
    for (let i = t - 1; i >= 0 && this._queue[i].char === 10; i--)
      r++;
    return r === t && this._last === 10 ? r + 1 : r;
  }
  endsWithCharAndNewline() {
    const t = this._queue, r = this._queueCursor;
    if (r !== 0)
      return t[r - 1].char !== 10 ? void 0 : r > 1 ? t[r - 2].char : this._last;
  }
  hasContent() {
    return this._queueCursor !== 0 || !!this._last;
  }
  exactSource(t, r) {
    if (!this._map) {
      r();
      return;
    }
    this.source("start", t);
    const i = t.identifierName, s = this._sourcePosition;
    i && (this._canMarkIdName = !1, s.identifierName = i), r(), i && (this._canMarkIdName = !0, s.identifierName = void 0, s.identifierNamePos = void 0), this.source("end", t);
  }
  source(t, r) {
    this._map && this._normalizePosition(t, r, 0);
  }
  sourceWithOffset(t, r, i) {
    this._map && this._normalizePosition(t, r, i);
  }
  withSource(t, r, i) {
    this._map && this.source(t, r), i();
  }
  _normalizePosition(t, r, i) {
    const s = r[t], n = this._sourcePosition;
    s && (n.line = s.line, n.column = Math.max(s.column + i, 0), n.filename = r.filename);
  }
  getCurrentColumn() {
    const t = this._queue, r = this._queueCursor;
    let i = -1, s = 0;
    for (let n = 0; n < r; n++) {
      const a = t[n];
      a.char === 10 && (i = s), s += a.repeat;
    }
    return i === -1 ? this._position.column + s : s - 1 - i;
  }
  getCurrentLine() {
    let t = 0;
    const r = this._queue;
    for (let i = 0; i < this._queueCursor; i++)
      r[i].char === 10 && t++;
    return this._position.line + t;
  }
};
Vs.default = I_;
var yr = {}, Ks = {};
Object.defineProperty(Ks, "__esModule", {
  value: !0
});
Ks.nodes = void 0;
var w_ = Ae();
const {
  FLIPPED_ALIAS_KEYS: O_,
  isArrayExpression: N_,
  isAssignmentExpression: Qc,
  isBinary: Zc,
  isBlockStatement: __,
  isCallExpression: ef,
  isFunction: ei,
  isIdentifier: ms,
  isLiteral: D_,
  isMemberExpression: Ya,
  isObjectExpression: k_,
  isOptionalCallExpression: L_,
  isOptionalMemberExpression: M_,
  isStringLiteral: B_
} = w_;
function vr(e, t) {
  return e && (Ya(e) || M_(e) ? (vr(e.object, t), e.computed && vr(e.property, t)) : Zc(e) || Qc(e) ? (vr(e.left, t), vr(e.right, t)) : ef(e) || L_(e) ? (t.hasCall = !0, vr(e.callee, t)) : ei(e) ? t.hasFunction = !0 : ms(e) && (t.hasHelper = t.hasHelper || e.callee && kt(e.callee))), t;
}
function Wl(e) {
  return vr(e, {
    hasCall: !1,
    hasFunction: !1,
    hasHelper: !1
  });
}
function kt(e) {
  return e ? Ya(e) ? kt(e.object) || kt(e.property) : ms(e) ? e.name === "require" || e.name.charCodeAt(0) === 95 : ef(e) ? kt(e.callee) : Zc(e) || Qc(e) ? ms(e.left) && kt(e.left) || kt(e.right) : !1 : !1;
}
function F_(e) {
  return D_(e) || k_(e) || N_(e) || ms(e) || Ya(e);
}
const Gt = {
  AssignmentExpression(e) {
    const t = Wl(e.right);
    if (t.hasCall && t.hasHelper || t.hasFunction)
      return t.hasFunction ? 3 : 2;
  },
  SwitchCase(e, t) {
    return (e.consequent.length || t.cases[0] === e ? 1 : 0) | (!e.consequent.length && t.cases[t.cases.length - 1] === e ? 2 : 0);
  },
  LogicalExpression(e) {
    if (ei(e.left) || ei(e.right))
      return 2;
  },
  Literal(e) {
    if (B_(e) && e.value === "use strict")
      return 2;
  },
  CallExpression(e) {
    if (ei(e.callee) || kt(e))
      return 3;
  },
  OptionalCallExpression(e) {
    if (ei(e.callee))
      return 3;
  },
  VariableDeclaration(e) {
    for (let t = 0; t < e.declarations.length; t++) {
      const r = e.declarations[t];
      let i = kt(r.id) && !F_(r.init);
      if (!i && r.init) {
        const s = Wl(r.init);
        i = kt(r.init) && s.hasCall || s.hasFunction;
      }
      if (i)
        return 3;
    }
  },
  IfStatement(e) {
    if (__(e.consequent))
      return 3;
  }
};
Ks.nodes = Gt;
Gt.ObjectProperty = Gt.ObjectTypeProperty = Gt.ObjectMethod = function(e, t) {
  if (t.properties[0] === e)
    return 1;
};
Gt.ObjectTypeCallProperty = function(e, t) {
  var r;
  if (t.callProperties[0] === e && !((r = t.properties) != null && r.length))
    return 1;
};
Gt.ObjectTypeIndexer = function(e, t) {
  var r, i;
  if (t.indexers[0] === e && !((r = t.properties) != null && r.length) && !((i = t.callProperties) != null && i.length))
    return 1;
};
Gt.ObjectTypeInternalSlot = function(e, t) {
  var r, i, s;
  if (t.internalSlots[0] === e && !((r = t.properties) != null && r.length) && !((i = t.callProperties) != null && i.length) && !((s = t.indexers) != null && s.length))
    return 1;
};
[["Function", !0], ["Class", !0], ["Loop", !0], ["LabeledStatement", !0], ["SwitchStatement", !0], ["TryStatement", !0]].forEach(function([e, t]) {
  [e].concat(O_[e] || []).forEach(function(r) {
    const i = t ? 3 : 0;
    Gt[r] = () => i;
  });
});
var Le = {};
Object.defineProperty(Le, "__esModule", {
  value: !0
});
Le.ArrowFunctionExpression = _2;
Le.AssignmentExpression = k2;
Le.Binary = b2;
Le.BinaryExpression = C2;
Le.ClassExpression = O2;
Le.ConditionalExpression = Za;
Le.DoExpression = S2;
Le.FunctionExpression = N2;
Le.FunctionTypeAnnotation = m2;
Le.Identifier = M2;
Le.LogicalExpression = L2;
Le.NullableTypeAnnotation = d2;
Le.ObjectExpression = T2;
Le.OptionalIndexedAccessType = E2;
Le.OptionalCallExpression = Le.OptionalMemberExpression = D2;
Le.SequenceExpression = I2;
Le.TSTypeAssertion = Le.TSSatisfiesExpression = Le.TSAsExpression = P2;
Le.TSInferType = v2;
Le.TSInstantiationExpression = A2;
Le.TSIntersectionType = Le.TSUnionType = x2;
Le.UnaryLike = Tf;
Le.IntersectionTypeAnnotation = Le.UnionTypeAnnotation = g2;
Le.UpdateExpression = y2;
Le.AwaitExpression = Le.YieldExpression = w2;
var j_ = Ae();
const {
  isArrayTypeAnnotation: Xa,
  isArrowFunctionExpression: tf,
  isAssignmentExpression: rf,
  isAwaitExpression: Ja,
  isBinary: qs,
  isBinaryExpression: sf,
  isUpdateExpression: R_,
  isCallExpression: Ha,
  isClass: $_,
  isClassExpression: U_,
  isConditional: V_,
  isConditionalExpression: nf,
  isExportDeclaration: K_,
  isExportDefaultDeclaration: q_,
  isExpressionStatement: af,
  isFor: W_,
  isForInStatement: of,
  isForOfStatement: lf,
  isForStatement: uf,
  isFunctionExpression: Y_,
  isIfStatement: X_,
  isIndexedAccessType: J_,
  isIntersectionTypeAnnotation: cf,
  isLogicalExpression: ss,
  isMemberExpression: Ga,
  isNewExpression: za,
  isNullableTypeAnnotation: H_,
  isObjectPattern: G_,
  isOptionalCallExpression: ff,
  isOptionalMemberExpression: pf,
  isReturnStatement: z_,
  isSequenceExpression: Q_,
  isSwitchStatement: Z_,
  isTSArrayType: hf,
  isTSAsExpression: e2,
  isTSInstantiationExpression: t2,
  isTSIntersectionType: r2,
  isTSNonNullExpression: i2,
  isTSOptionalType: df,
  isTSRestType: s2,
  isTSTypeAssertion: n2,
  isTSUnionType: a2,
  isTaggedTemplateExpression: o2,
  isThrowStatement: l2,
  isTypeAnnotation: u2,
  isUnaryLike: Qa,
  isUnionTypeAnnotation: mf,
  isVariableDeclarator: c2,
  isWhileStatement: f2,
  isYieldExpression: p2,
  isTSSatisfiesExpression: h2
} = j_, Yl = {
  "||": 0,
  "??": 0,
  "|>": 0,
  "&&": 1,
  "|": 2,
  "^": 3,
  "&": 4,
  "==": 5,
  "===": 5,
  "!=": 5,
  "!==": 5,
  "<": 6,
  ">": 6,
  "<=": 6,
  ">=": 6,
  in: 6,
  instanceof: 6,
  ">>": 7,
  "<<": 7,
  ">>>": 7,
  "+": 8,
  "-": 8,
  "*": 9,
  "/": 9,
  "%": 9,
  "**": 10
};
function yf(e) {
  return e2(e) || h2(e) || n2(e);
}
const Ws = (e, t) => $_(t, {
  superClass: e
}), Si = (e, t) => (Ga(t) || pf(t)) && t.object === e || (Ha(t) || ff(t) || za(t)) && t.callee === e || o2(t) && t.tag === e || i2(t);
function d2(e, t) {
  return Xa(t);
}
function m2(e, t, r) {
  if (!(r.length < 3))
    return mf(t) || cf(t) || Xa(t) || u2(t) && tf(r[r.length - 3]);
}
function y2(e, t) {
  return Si(e, t) || Ws(e, t);
}
function T2(e, t, r) {
  return bi(r, 3);
}
function S2(e, t, r) {
  return !e.async && bi(r, 1);
}
function b2(e, t) {
  if (e.operator === "**" && sf(t, {
    operator: "**"
  }))
    return t.left === e;
  if (Ws(e, t) || Si(e, t) || Qa(t) || Ja(t))
    return !0;
  if (qs(t)) {
    const r = t.operator, i = Yl[r], s = e.operator, n = Yl[s];
    if (i === n && t.right === e && !ss(t) || i > n)
      return !0;
  }
}
function g2(e, t) {
  return Xa(t) || H_(t) || cf(t) || mf(t);
}
function E2(e, t) {
  return J_(t, {
    objectType: e
  });
}
function P2() {
  return !0;
}
function x2(e, t) {
  return hf(t) || df(t) || r2(t) || a2(t) || s2(t);
}
function v2(e, t) {
  return hf(t) || df(t);
}
function A2(e, t) {
  return (Ha(t) || ff(t) || za(t) || t2(t)) && !!t.typeParameters;
}
function C2(e, t) {
  return e.operator === "in" && (c2(t) || W_(t));
}
function I2(e, t) {
  return !(uf(t) || l2(t) || z_(t) || X_(t) && t.test === e || f2(t) && t.test === e || of(t) && t.right === e || Z_(t) && t.discriminant === e || af(t) && t.expression === e);
}
function w2(e, t) {
  return qs(t) || Qa(t) || Si(e, t) || Ja(t) && p2(e) || nf(t) && e === t.test || Ws(e, t);
}
function O2(e, t, r) {
  return bi(r, 5);
}
function Tf(e, t) {
  return Si(e, t) || sf(t, {
    operator: "**",
    left: e
  }) || Ws(e, t);
}
function N2(e, t, r) {
  return bi(r, 5);
}
function _2(e, t) {
  return K_(t) || Za(e, t);
}
function Za(e, t) {
  return Qa(t) || qs(t) || nf(t, {
    test: e
  }) || Ja(t) || yf(t) ? !0 : Tf(e, t);
}
function D2(e, t) {
  return Ha(t, {
    callee: e
  }) || Ga(t, {
    object: e
  });
}
function k2(e, t) {
  return G_(e.left) ? !0 : Za(e, t);
}
function L2(e, t) {
  if (yf(t))
    return !0;
  switch (e.operator) {
    case "||":
      return ss(t) ? t.operator === "??" || t.operator === "&&" : !1;
    case "&&":
      return ss(t, {
        operator: "??"
      });
    case "??":
      return ss(t) && t.operator !== "??";
  }
}
function M2(e, t, r) {
  var i;
  if ((i = e.extra) != null && i.parenthesized && rf(t, {
    left: e
  }) && (Y_(t.right) || U_(t.right)) && t.right.id == null)
    return !0;
  if (e.name === "let") {
    const s = Ga(t, {
      object: e,
      computed: !0
    }) || pf(t, {
      object: e,
      computed: !0,
      optional: !1
    });
    return bi(r, s ? 57 : 32);
  }
  return e.name === "async" && lf(t) && e === t.left;
}
function bi(e, t) {
  const r = t & 1, i = t & 2, s = t & 4, n = t & 8, a = t & 16, o = t & 32;
  let l = e.length - 1;
  if (l <= 0)
    return;
  let u = e[l];
  l--;
  let c = e[l];
  for (; l >= 0; ) {
    if (r && af(c, {
      expression: u
    }) || s && q_(c, {
      declaration: u
    }) || i && tf(c, {
      body: u
    }) || n && uf(c, {
      init: u
    }) || a && of(c, {
      left: u
    }) || o && lf(c, {
      left: u
    }))
      return !0;
    if (l > 0 && (Si(u, c) && !za(c) || Q_(c) && c.expressions[0] === u || R_(c) && !c.prefix || V_(c, {
      test: u
    }) || qs(c, {
      left: u
    }) || rf(c, {
      left: u
    })))
      u = c, l--, c = e[l];
    else
      return !1;
  }
  return !1;
}
Object.defineProperty(yr, "__esModule", {
  value: !0
});
yr.needsParens = J2;
yr.needsWhitespace = eo;
yr.needsWhitespaceAfter = X2;
yr.needsWhitespaceBefore = Y2;
var B2 = Ks, F2 = Le, j2 = Ae();
const {
  FLIPPED_ALIAS_KEYS: R2,
  isCallExpression: $2,
  isExpressionStatement: U2,
  isMemberExpression: V2,
  isNewExpression: K2
} = j2;
function Sf(e) {
  const t = {};
  function r(i, s) {
    const n = t[i];
    t[i] = n ? function(a, o, l) {
      const u = n(a, o, l);
      return u ?? s(a, o, l);
    } : s;
  }
  for (const i of Object.keys(e)) {
    const s = R2[i];
    if (s)
      for (const n of s)
        r(n, e[i]);
    else
      r(i, e[i]);
  }
  return t;
}
const q2 = Sf(F2), W2 = Sf(B2.nodes);
function bf(e, t, r, i) {
  const s = e[t.type];
  return s ? s(t, r, i) : null;
}
function gf(e) {
  return $2(e) ? !0 : V2(e) && gf(e.object);
}
function eo(e, t, r) {
  if (!e)
    return !1;
  U2(e) && (e = e.expression);
  const i = bf(W2, e, t);
  return typeof i == "number" ? (i & r) !== 0 : !1;
}
function Y2(e, t) {
  return eo(e, t, 1);
}
function X2(e, t) {
  return eo(e, t, 2);
}
function J2(e, t, r) {
  return t ? K2(t) && t.callee === e && gf(e) ? !0 : bf(q2, e, t, r) : !1;
}
var Ef = {}, gi = {};
Object.defineProperty(gi, "__esModule", {
  value: !0
});
gi.TaggedTemplateExpression = H2;
gi.TemplateElement = G2;
gi.TemplateLiteral = z2;
function H2(e) {
  this.print(e.tag, e), this.print(e.typeParameters, e), this.print(e.quasi, e);
}
function G2(e, t) {
  const r = t.quasis[0] === e, i = t.quasis[t.quasis.length - 1] === e, s = (r ? "`" : "}") + e.value.raw + (i ? "`" : "${");
  this.token(s, !0);
}
function z2(e) {
  const t = e.quasis;
  for (let r = 0; r < t.length; r++)
    this.print(t[r], e), r + 1 < t.length && this.print(e.expressions[r], e);
}
var Me = {};
Object.defineProperty(Me, "__esModule", {
  value: !0
});
Me.LogicalExpression = Me.BinaryExpression = Me.AssignmentExpression = xD;
Me.AssignmentPattern = PD;
Me.AwaitExpression = SD;
Me.BindExpression = vD;
Me.CallExpression = yD;
Me.ConditionalExpression = aD;
Me.Decorator = hD;
Me.DoExpression = iD;
Me.EmptyStatement = gD;
Me.ExpressionStatement = ED;
Me.Import = TD;
Me.MemberExpression = AD;
Me.MetaProperty = CD;
Me.ModuleExpression = OD;
Me.NewExpression = oD;
Me.OptionalCallExpression = mD;
Me.OptionalMemberExpression = dD;
Me.ParenthesizedExpression = sD;
Me.PrivateName = ID;
Me.SequenceExpression = lD;
Me.Super = cD;
Me.ThisExpression = uD;
Me.UnaryExpression = rD;
Me.UpdateExpression = nD;
Me.V8IntrinsicIdentifier = wD;
Me.YieldExpression = bD;
Me._shouldPrintDecoratorsBeforeExport = pD;
var Q2 = Ae(), Z2 = yr;
const {
  isCallExpression: eD,
  isLiteral: Pf,
  isMemberExpression: to,
  isNewExpression: tD
} = Q2;
function rD(e) {
  const {
    operator: t
  } = e;
  t === "void" || t === "delete" || t === "typeof" || t === "throw" ? (this.word(t), this.space()) : this.token(t), this.print(e.argument, e);
}
function iD(e) {
  e.async && (this.word("async", !0), this.space()), this.word("do"), this.space(), this.print(e.body, e);
}
function sD(e) {
  this.tokenChar(40), this.print(e.expression, e), this.rightParens(e);
}
function nD(e) {
  e.prefix ? (this.token(e.operator), this.print(e.argument, e)) : (this.printTerminatorless(e.argument, e, !0), this.token(e.operator));
}
function aD(e) {
  this.print(e.test, e), this.space(), this.tokenChar(63), this.space(), this.print(e.consequent, e), this.space(), this.tokenChar(58), this.space(), this.print(e.alternate, e);
}
function oD(e, t) {
  this.word("new"), this.space(), this.print(e.callee, e), !(this.format.minified && e.arguments.length === 0 && !e.optional && !eD(t, {
    callee: e
  }) && !to(t) && !tD(t)) && (this.print(e.typeArguments, e), this.print(e.typeParameters, e), e.optional && this.token("?."), this.tokenChar(40), this.printList(e.arguments, e), this.rightParens(e));
}
function lD(e) {
  this.printList(e.expressions, e);
}
function uD() {
  this.word("this");
}
function cD() {
  this.word("super");
}
function xf(e) {
  switch (e.type) {
    case "Identifier":
      return !0;
    case "MemberExpression":
      return !e.computed && e.property.type === "Identifier" && xf(e.object);
    default:
      return !1;
  }
}
function fD(e) {
  return e.type === "ParenthesizedExpression" ? !1 : !xf(e.type === "CallExpression" ? e.callee : e);
}
function pD(e) {
  return typeof this.format.decoratorsBeforeExport == "boolean" ? this.format.decoratorsBeforeExport : typeof e.start == "number" && e.start === e.declaration.start;
}
function hD(e) {
  this.tokenChar(64);
  const {
    expression: t
  } = e;
  fD(t) ? (this.tokenChar(40), this.print(t, e), this.tokenChar(41)) : this.print(t, e), this.newline();
}
function dD(e) {
  let {
    computed: t
  } = e;
  const {
    optional: r,
    property: i
  } = e;
  if (this.print(e.object, e), !t && to(i))
    throw new TypeError("Got a MemberExpression for MemberExpression property");
  Pf(i) && typeof i.value == "number" && (t = !0), r && this.token("?."), t ? (this.tokenChar(91), this.print(i, e), this.tokenChar(93)) : (r || this.tokenChar(46), this.print(i, e));
}
function mD(e) {
  this.print(e.callee, e), this.print(e.typeParameters, e), e.optional && this.token("?."), this.print(e.typeArguments, e), this.tokenChar(40), this.printList(e.arguments, e), this.rightParens(e);
}
function yD(e) {
  this.print(e.callee, e), this.print(e.typeArguments, e), this.print(e.typeParameters, e), this.tokenChar(40), this.printList(e.arguments, e), this.rightParens(e);
}
function TD() {
  this.word("import");
}
function SD(e) {
  this.word("await"), e.argument && (this.space(), this.printTerminatorless(e.argument, e, !1));
}
function bD(e) {
  this.word("yield", !0), e.delegate ? (this.tokenChar(42), e.argument && (this.space(), this.print(e.argument, e))) : e.argument && (this.space(), this.printTerminatorless(e.argument, e, !1));
}
function gD() {
  this.semicolon(!0);
}
function ED(e) {
  this.print(e.expression, e), this.semicolon();
}
function PD(e) {
  this.print(e.left, e), e.left.optional && this.tokenChar(63), this.print(e.left.typeAnnotation, e), this.space(), this.tokenChar(61), this.space(), this.print(e.right, e);
}
function xD(e, t) {
  const r = this.inForStatementInitCounter && e.operator === "in" && !Z2.needsParens(e, t);
  r && this.tokenChar(40), this.print(e.left, e), this.space(), e.operator === "in" || e.operator === "instanceof" ? this.word(e.operator) : this.token(e.operator), this.space(), this.print(e.right, e), r && this.tokenChar(41);
}
function vD(e) {
  this.print(e.object, e), this.token("::"), this.print(e.callee, e);
}
function AD(e) {
  if (this.print(e.object, e), !e.computed && to(e.property))
    throw new TypeError("Got a MemberExpression for MemberExpression property");
  let t = e.computed;
  Pf(e.property) && typeof e.property.value == "number" && (t = !0), t ? (this.tokenChar(91), this.print(e.property, e), this.tokenChar(93)) : (this.tokenChar(46), this.print(e.property, e));
}
function CD(e) {
  this.print(e.meta, e), this.tokenChar(46), this.print(e.property, e);
}
function ID(e) {
  this.tokenChar(35), this.print(e.id, e);
}
function wD(e) {
  this.tokenChar(37), this.word(e.name);
}
function OD(e) {
  this.word("module", !0), this.space(), this.tokenChar(123), this.indent();
  const {
    body: t
  } = e;
  (t.body.length || t.directives.length) && this.newline(), this.print(t, e), this.dedent(), this.rightBrace(e);
}
var Ve = {};
Object.defineProperty(Ve, "__esModule", {
  value: !0
});
Ve.BreakStatement = UD;
Ve.CatchClause = XD;
Ve.ContinueStatement = VD;
Ve.DebuggerStatement = GD;
Ve.DoWhileStatement = $D;
Ve.ForOfStatement = Ve.ForInStatement = void 0;
Ve.ForStatement = BD;
Ve.IfStatement = MD;
Ve.LabeledStatement = WD;
Ve.ReturnStatement = KD;
Ve.SwitchCase = HD;
Ve.SwitchStatement = JD;
Ve.ThrowStatement = qD;
Ve.TryStatement = YD;
Ve.VariableDeclaration = zD;
Ve.VariableDeclarator = QD;
Ve.WhileStatement = FD;
Ve.WithStatement = LD;
var ND = Ae();
const {
  isFor: Xl,
  isForStatement: _D,
  isIfStatement: DD,
  isStatement: kD
} = ND;
function LD(e) {
  this.word("with"), this.space(), this.tokenChar(40), this.print(e.object, e), this.tokenChar(41), this.printBlock(e);
}
function MD(e) {
  this.word("if"), this.space(), this.tokenChar(40), this.print(e.test, e), this.tokenChar(41), this.space();
  const t = e.alternate && DD(vf(e.consequent));
  t && (this.tokenChar(123), this.newline(), this.indent()), this.printAndIndentOnComments(e.consequent, e), t && (this.dedent(), this.newline(), this.tokenChar(125)), e.alternate && (this.endsWith(125) && this.space(), this.word("else"), this.space(), this.printAndIndentOnComments(e.alternate, e));
}
function vf(e) {
  const {
    body: t
  } = e;
  return kD(t) === !1 ? e : vf(t);
}
function BD(e) {
  this.word("for"), this.space(), this.tokenChar(40), this.inForStatementInitCounter++, this.print(e.init, e), this.inForStatementInitCounter--, this.tokenChar(59), e.test && (this.space(), this.print(e.test, e)), this.tokenChar(59), e.update && (this.space(), this.print(e.update, e)), this.tokenChar(41), this.printBlock(e);
}
function FD(e) {
  this.word("while"), this.space(), this.tokenChar(40), this.print(e.test, e), this.tokenChar(41), this.printBlock(e);
}
function Af(e) {
  this.word("for"), this.space();
  const t = e.type === "ForOfStatement";
  t && e.await && (this.word("await"), this.space()), this.noIndentInnerCommentsHere(), this.tokenChar(40), this.print(e.left, e), this.space(), this.word(t ? "of" : "in"), this.space(), this.print(e.right, e), this.tokenChar(41), this.printBlock(e);
}
const jD = Af;
Ve.ForInStatement = jD;
const RD = Af;
Ve.ForOfStatement = RD;
function $D(e) {
  this.word("do"), this.space(), this.print(e.body, e), this.space(), this.word("while"), this.space(), this.tokenChar(40), this.print(e.test, e), this.tokenChar(41), this.semicolon();
}
function Ys(e, t, r, i) {
  t && (e.space(), e.printTerminatorless(t, r, i)), e.semicolon();
}
function UD(e) {
  this.word("break"), Ys(this, e.label, e, !0);
}
function VD(e) {
  this.word("continue"), Ys(this, e.label, e, !0);
}
function KD(e) {
  this.word("return"), Ys(this, e.argument, e, !1);
}
function qD(e) {
  this.word("throw"), Ys(this, e.argument, e, !1);
}
function WD(e) {
  this.print(e.label, e), this.tokenChar(58), this.space(), this.print(e.body, e);
}
function YD(e) {
  this.word("try"), this.space(), this.print(e.block, e), this.space(), e.handlers ? this.print(e.handlers[0], e) : this.print(e.handler, e), e.finalizer && (this.space(), this.word("finally"), this.space(), this.print(e.finalizer, e));
}
function XD(e) {
  this.word("catch"), this.space(), e.param && (this.tokenChar(40), this.print(e.param, e), this.print(e.param.typeAnnotation, e), this.tokenChar(41), this.space()), this.print(e.body, e);
}
function JD(e) {
  this.word("switch"), this.space(), this.tokenChar(40), this.print(e.discriminant, e), this.tokenChar(41), this.space(), this.tokenChar(123), this.printSequence(e.cases, e, {
    indent: !0,
    addNewlines(t, r) {
      if (!t && e.cases[e.cases.length - 1] === r)
        return -1;
    }
  }), this.rightBrace(e);
}
function HD(e) {
  e.test ? (this.word("case"), this.space(), this.print(e.test, e), this.tokenChar(58)) : (this.word("default"), this.tokenChar(58)), e.consequent.length && (this.newline(), this.printSequence(e.consequent, e, {
    indent: !0
  }));
}
function GD() {
  this.word("debugger"), this.semicolon();
}
function zD(e, t) {
  e.declare && (this.word("declare"), this.space());
  const {
    kind: r
  } = e;
  this.word(r, r === "using" || r === "await using"), this.space();
  let i = !1;
  if (!Xl(t))
    for (const s of e.declarations)
      s.init && (i = !0);
  if (this.printList(e.declarations, e, {
    separator: i ? function() {
      this.tokenChar(44), this.newline();
    } : void 0,
    indent: e.declarations.length > 1
  }), Xl(t)) {
    if (_D(t)) {
      if (t.init === e)
        return;
    } else if (t.left === e)
      return;
  }
  this.semicolon();
}
function QD(e) {
  this.print(e.id, e), e.definite && this.tokenChar(33), this.print(e.id.typeAnnotation, e), e.init && (this.space(), this.tokenChar(61), this.space(), this.print(e.init, e));
}
var mt = {};
Object.defineProperty(mt, "__esModule", {
  value: !0
});
mt.ClassAccessorProperty = nk;
mt.ClassBody = ik;
mt.ClassExpression = mt.ClassDeclaration = rk;
mt.ClassMethod = ok;
mt.ClassPrivateMethod = lk;
mt.ClassPrivateProperty = ak;
mt.ClassProperty = sk;
mt.StaticBlock = ck;
mt._classMethodHead = uk;
var ZD = Ae();
const {
  isExportDefaultDeclaration: ek,
  isExportNamedDeclaration: tk
} = ZD;
function rk(e, t) {
  (!(ek(t) || tk(t)) || !this._shouldPrintDecoratorsBeforeExport(t)) && this.printJoin(e.decorators, e), e.declare && (this.word("declare"), this.space()), e.abstract && (this.word("abstract"), this.space()), this.word("class"), e.id && (this.space(), this.print(e.id, e)), this.print(e.typeParameters, e), e.superClass && (this.space(), this.word("extends"), this.space(), this.print(e.superClass, e), this.print(e.superTypeParameters, e)), e.implements && (this.space(), this.word("implements"), this.space(), this.printList(e.implements, e)), this.space(), this.print(e.body, e);
}
function ik(e) {
  this.tokenChar(123), e.body.length === 0 ? this.tokenChar(125) : (this.newline(), this.printSequence(e.body, e, {
    indent: !0
  }), this.endsWith(10) || this.newline(), this.rightBrace(e));
}
function sk(e) {
  var t, r;
  this.printJoin(e.decorators, e);
  const i = (t = e.key.loc) == null || (r = t.end) == null ? void 0 : r.line;
  i && this.catchUp(i), this.tsPrintClassMemberModifiers(e), e.computed ? (this.tokenChar(91), this.print(e.key, e), this.tokenChar(93)) : (this._variance(e), this.print(e.key, e)), e.optional && this.tokenChar(63), e.definite && this.tokenChar(33), this.print(e.typeAnnotation, e), e.value && (this.space(), this.tokenChar(61), this.space(), this.print(e.value, e)), this.semicolon();
}
function nk(e) {
  var t, r;
  this.printJoin(e.decorators, e);
  const i = (t = e.key.loc) == null || (r = t.end) == null ? void 0 : r.line;
  i && this.catchUp(i), this.tsPrintClassMemberModifiers(e), this.word("accessor", !0), this.space(), e.computed ? (this.tokenChar(91), this.print(e.key, e), this.tokenChar(93)) : (this._variance(e), this.print(e.key, e)), e.optional && this.tokenChar(63), e.definite && this.tokenChar(33), this.print(e.typeAnnotation, e), e.value && (this.space(), this.tokenChar(61), this.space(), this.print(e.value, e)), this.semicolon();
}
function ak(e) {
  this.printJoin(e.decorators, e), e.static && (this.word("static"), this.space()), this.print(e.key, e), this.print(e.typeAnnotation, e), e.value && (this.space(), this.tokenChar(61), this.space(), this.print(e.value, e)), this.semicolon();
}
function ok(e) {
  this._classMethodHead(e), this.space(), this.print(e.body, e);
}
function lk(e) {
  this._classMethodHead(e), this.space(), this.print(e.body, e);
}
function uk(e) {
  var t, r;
  this.printJoin(e.decorators, e);
  const i = (t = e.key.loc) == null || (r = t.end) == null ? void 0 : r.line;
  i && this.catchUp(i), this.tsPrintClassMemberModifiers(e), this._methodHead(e);
}
function ck(e) {
  this.word("static"), this.space(), this.tokenChar(123), e.body.length === 0 ? this.tokenChar(125) : (this.newline(), this.printSequence(e.body, e, {
    indent: !0
  }), this.rightBrace(e));
}
var gt = {};
Object.defineProperty(gt, "__esModule", {
  value: !0
});
gt.ArrowFunctionExpression = gk;
gt.FunctionDeclaration = gt.FunctionExpression = bk;
gt._functionHead = Sk;
gt._methodHead = yk;
gt._param = mk;
gt._parameters = dk;
gt._params = hk;
gt._predicate = Tk;
var fk = Ae();
const {
  isIdentifier: pk
} = fk;
function hk(e, t, r) {
  this.print(e.typeParameters, e);
  const i = Pk.call(this, t, r);
  i && this.sourceIdentifierName(i.name, i.pos), this.tokenChar(40), this._parameters(e.params, e), this.tokenChar(41);
  const s = e.type === "ArrowFunctionExpression";
  this.print(e.returnType, e, s), this._noLineTerminator = s;
}
function dk(e, t) {
  const r = e.length;
  for (let i = 0; i < r; i++)
    this._param(e[i], t), i < e.length - 1 && (this.tokenChar(44), this.space());
}
function mk(e, t) {
  this.printJoin(e.decorators, e), this.print(e, t), e.optional && this.tokenChar(63), this.print(e.typeAnnotation, e);
}
function yk(e) {
  const t = e.kind, r = e.key;
  (t === "get" || t === "set") && (this.word(t), this.space()), e.async && (this.word("async", !0), this.space()), (t === "method" || t === "init") && e.generator && this.tokenChar(42), e.computed ? (this.tokenChar(91), this.print(r, e), this.tokenChar(93)) : this.print(r, e), e.optional && this.tokenChar(63), this._params(e, e.computed && e.key.type !== "StringLiteral" ? void 0 : e.key, void 0);
}
function Tk(e, t) {
  e.predicate && (e.returnType || this.tokenChar(58), this.space(), this.print(e.predicate, e, t));
}
function Sk(e, t) {
  e.async && (this.word("async"), this._endsWithInnerRaw = !1, this.space()), this.word("function"), e.generator && (this._endsWithInnerRaw = !1, this.tokenChar(42)), this.space(), e.id && this.print(e.id, e), this._params(e, e.id, t), e.type !== "TSDeclareFunction" && this._predicate(e);
}
function bk(e, t) {
  this._functionHead(e, t), this.space(), this.print(e.body, e);
}
function gk(e, t) {
  e.async && (this.word("async", !0), this.space());
  let r;
  !this.format.retainLines && e.params.length === 1 && pk(r = e.params[0]) && !Ek(e, r) ? this.print(r, e, !0) : this._params(e, void 0, t), this._predicate(e, !0), this.space(), this.printInnerComments(), this.token("=>"), this.space(), this.print(e.body, e);
}
function Ek(e, t) {
  var r, i;
  return !!(e.typeParameters || e.returnType || e.predicate || t.typeAnnotation || t.optional || (r = t.leadingComments) != null && r.length || (i = t.trailingComments) != null && i.length);
}
function Pk(e, t) {
  let r = e;
  if (!r && t) {
    const l = t.type;
    l === "VariableDeclarator" ? r = t.id : l === "AssignmentExpression" || l === "AssignmentPattern" ? r = t.left : l === "ObjectProperty" || l === "ClassProperty" ? (!t.computed || t.key.type === "StringLiteral") && (r = t.key) : (l === "ClassPrivateProperty" || l === "ClassAccessorProperty") && (r = t.key);
  }
  if (!r)
    return;
  let i;
  if (r.type === "Identifier") {
    var s, n;
    i = {
      pos: (s = r.loc) == null ? void 0 : s.start,
      name: ((n = r.loc) == null ? void 0 : n.identifierName) || r.name
    };
  } else if (r.type === "PrivateName") {
    var a;
    i = {
      pos: (a = r.loc) == null ? void 0 : a.start,
      name: "#" + r.id.name
    };
  } else if (r.type === "StringLiteral") {
    var o;
    i = {
      pos: (o = r.loc) == null ? void 0 : o.start,
      name: r.value
    };
  }
  return i;
}
var at = {};
Object.defineProperty(at, "__esModule", {
  value: !0
});
at.ExportAllDeclaration = Mk;
at.ExportDefaultDeclaration = Fk;
at.ExportDefaultSpecifier = _k;
at.ExportNamedDeclaration = Bk;
at.ExportNamespaceSpecifier = kk;
at.ExportSpecifier = Dk;
at.ImportAttribute = Rk;
at.ImportDeclaration = jk;
at.ImportDefaultSpecifier = Nk;
at.ImportNamespaceSpecifier = $k;
at.ImportSpecifier = Ok;
at._printAttributes = Lk;
var xk = Ae();
const {
  isClassDeclaration: vk,
  isExportDefaultSpecifier: Ak,
  isExportNamespaceSpecifier: Ck,
  isImportDefaultSpecifier: Ik,
  isImportNamespaceSpecifier: wk,
  isStatement: Cf
} = xk;
function Ok(e) {
  (e.importKind === "type" || e.importKind === "typeof") && (this.word(e.importKind), this.space()), this.print(e.imported, e), e.local && e.local.name !== e.imported.name && (this.space(), this.word("as"), this.space(), this.print(e.local, e));
}
function Nk(e) {
  this.print(e.local, e);
}
function _k(e) {
  this.print(e.exported, e);
}
function Dk(e) {
  e.exportKind === "type" && (this.word("type"), this.space()), this.print(e.local, e), e.exported && e.local.name !== e.exported.name && (this.space(), this.word("as"), this.space(), this.print(e.exported, e));
}
function kk(e) {
  this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(e.exported, e);
}
let Jl = !1;
function Lk(e) {
  const {
    importAttributesKeyword: t
  } = this.format, {
    attributes: r,
    assertions: i
  } = e;
  r && !t && !Jl && (Jl = !0, console.warn('You are using import attributes, without specifying the desired output syntax.\nPlease specify the "importAttributesKeyword" generator option, whose value can be one of:\n - "with"        : `import { a } from "b" with { type: "json" };`\n - "assert"      : `import { a } from "b" assert { type: "json" };`\n - "with-legacy" : `import { a } from "b" with type: "json";`\n'));
  const s = t === "assert" || !t && i;
  if (this.word(s ? "assert" : "with"), this.space(), !s && t !== "with") {
    this.printList(r || i, e);
    return;
  }
  this.tokenChar(123), this.space(), this.printList(r || i, e), this.space(), this.tokenChar(125);
}
function Mk(e) {
  var t, r;
  this.word("export"), this.space(), e.exportKind === "type" && (this.word("type"), this.space()), this.tokenChar(42), this.space(), this.word("from"), this.space(), (t = e.attributes) != null && t.length || (r = e.assertions) != null && r.length ? (this.print(e.source, e, !0), this.space(), this._printAttributes(e)) : this.print(e.source, e), this.semicolon();
}
function If(e, t) {
  vk(t.declaration) && e._shouldPrintDecoratorsBeforeExport(t) && e.printJoin(t.declaration.decorators, t);
}
function Bk(e) {
  if (If(this, e), this.word("export"), this.space(), e.declaration) {
    const i = e.declaration;
    this.print(i, e), Cf(i) || this.semicolon();
  } else {
    e.exportKind === "type" && (this.word("type"), this.space());
    const i = e.specifiers.slice(0);
    let s = !1;
    for (; ; ) {
      const n = i[0];
      if (Ak(n) || Ck(n))
        s = !0, this.print(i.shift(), e), i.length && (this.tokenChar(44), this.space());
      else
        break;
    }
    if ((i.length || !i.length && !s) && (this.tokenChar(123), i.length && (this.space(), this.printList(i, e), this.space()), this.tokenChar(125)), e.source) {
      var t, r;
      this.space(), this.word("from"), this.space(), (t = e.attributes) != null && t.length || (r = e.assertions) != null && r.length ? (this.print(e.source, e, !0), this.space(), this._printAttributes(e)) : this.print(e.source, e);
    }
    this.semicolon();
  }
}
function Fk(e) {
  If(this, e), this.word("export"), this.noIndentInnerCommentsHere(), this.space(), this.word("default"), this.space();
  const t = e.declaration;
  this.print(t, e), Cf(t) || this.semicolon();
}
function jk(e) {
  var t, r;
  this.word("import"), this.space();
  const i = e.importKind === "type" || e.importKind === "typeof";
  i ? (this.noIndentInnerCommentsHere(), this.word(e.importKind), this.space()) : e.module && (this.noIndentInnerCommentsHere(), this.word("module"), this.space());
  const s = e.specifiers.slice(0), n = !!s.length;
  for (; n; ) {
    const a = s[0];
    if (Ik(a) || wk(a))
      this.print(s.shift(), e), s.length && (this.tokenChar(44), this.space());
    else
      break;
  }
  s.length ? (this.tokenChar(123), this.space(), this.printList(s, e), this.space(), this.tokenChar(125)) : i && !n && (this.tokenChar(123), this.tokenChar(125)), (n || i) && (this.space(), this.word("from"), this.space()), (t = e.attributes) != null && t.length || (r = e.assertions) != null && r.length ? (this.print(e.source, e, !0), this.space(), this._printAttributes(e)) : this.print(e.source, e), this.semicolon();
}
function Rk(e) {
  this.print(e.key), this.tokenChar(58), this.space(), this.print(e.value);
}
function $k(e) {
  this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(e.local, e);
}
var Fe = {};
const wf = {}, Uk = wf.hasOwnProperty, Of = (e, t) => {
  for (const r in e)
    Uk.call(e, r) && t(r, e[r]);
}, Vk = (e, t) => (t && Of(t, (r, i) => {
  e[r] = i;
}), e), Kk = (e, t) => {
  const r = e.length;
  let i = -1;
  for (; ++i < r; )
    t(e[i]);
}, Ei = wf.toString, qk = Array.isArray, Wk = Buffer.isBuffer, Yk = (e) => Ei.call(e) == "[object Object]", Xk = (e) => typeof e == "string" || Ei.call(e) == "[object String]", Jk = (e) => typeof e == "number" || Ei.call(e) == "[object Number]", Hk = (e) => typeof e == "function", Gk = (e) => Ei.call(e) == "[object Map]", zk = (e) => Ei.call(e) == "[object Set]", Qk = {
  '"': '\\"',
  "'": "\\'",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t"
  // `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.
  // '\v': '\\x0B'
}, Zk = /["'\\\b\f\n\r\t]/, eL = /[0-9]/, tL = /[ !#-&\(-\[\]-_a-~]/, Wt = (e, t) => {
  const r = () => {
    u = l, ++t.indentLevel, l = t.indent.repeat(t.indentLevel);
  }, i = {
    escapeEverything: !1,
    minimal: !1,
    isScriptContext: !1,
    quotes: "single",
    wrap: !1,
    es6: !1,
    json: !1,
    compact: !0,
    lowercaseHex: !1,
    numbers: "decimal",
    indent: "	",
    indentLevel: 0,
    __inline1__: !1,
    __inline2__: !1
  }, s = t && t.json;
  s && (i.quotes = "double", i.wrap = !0), t = Vk(i, t), t.quotes != "single" && t.quotes != "double" && t.quotes != "backtick" && (t.quotes = "single");
  const n = t.quotes == "double" ? '"' : t.quotes == "backtick" ? "`" : "'", a = t.compact, o = t.lowercaseHex;
  let l = t.indent.repeat(t.indentLevel), u = "";
  const c = t.__inline1__, p = t.__inline2__, h = a ? "" : `
`;
  let y, P = !0;
  const v = t.numbers == "binary", w = t.numbers == "octal", x = t.numbers == "decimal", O = t.numbers == "hexadecimal";
  if (s && e && Hk(e.toJSON) && (e = e.toJSON()), !Xk(e)) {
    if (Gk(e))
      return e.size == 0 ? "new Map()" : (a || (t.__inline1__ = !0, t.__inline2__ = !1), "new Map(" + Wt(Array.from(e), t) + ")");
    if (zk(e))
      return e.size == 0 ? "new Set()" : "new Set(" + Wt(Array.from(e), t) + ")";
    if (Wk(e))
      return e.length == 0 ? "Buffer.from([])" : "Buffer.from(" + Wt(Array.from(e), t) + ")";
    if (qk(e))
      return y = [], t.wrap = !0, c && (t.__inline1__ = !1, t.__inline2__ = !0), p || r(), Kk(e, (B) => {
        P = !1, p && (t.__inline2__ = !1), y.push(
          (a || p ? "" : l) + Wt(B, t)
        );
      }), P ? "[]" : p ? "[" + y.join(", ") + "]" : "[" + h + y.join("," + h) + h + (a ? "" : u) + "]";
    if (Jk(e)) {
      if (s)
        return JSON.stringify(e);
      if (x)
        return String(e);
      if (O) {
        let B = e.toString(16);
        return o || (B = B.toUpperCase()), "0x" + B;
      }
      if (v)
        return "0b" + e.toString(2);
      if (w)
        return "0o" + e.toString(8);
    } else
      return Yk(e) ? (y = [], t.wrap = !0, r(), Of(e, (B, C) => {
        P = !1, y.push(
          (a ? "" : l) + Wt(B, t) + ":" + (a ? "" : " ") + Wt(C, t)
        );
      }), P ? "{}" : "{" + h + y.join("," + h) + h + (a ? "" : u) + "}") : s ? JSON.stringify(e) || "null" : String(e);
  }
  const _ = e;
  let K = -1;
  const R = _.length;
  for (y = ""; ++K < R; ) {
    const B = _.charAt(K);
    if (t.es6) {
      const Z = _.charCodeAt(K);
      if (
        // check if it’s the start of a surrogate pair
        Z >= 55296 && Z <= 56319 && // high surrogate
        R > K + 1
      ) {
        const J = _.charCodeAt(K + 1);
        if (J >= 56320 && J <= 57343) {
          let me = ((Z - 55296) * 1024 + J - 56320 + 65536).toString(16);
          o || (me = me.toUpperCase()), y += "\\u{" + me + "}", ++K;
          continue;
        }
      }
    }
    if (!t.escapeEverything) {
      if (tL.test(B)) {
        y += B;
        continue;
      }
      if (B == '"') {
        y += n == B ? '\\"' : B;
        continue;
      }
      if (B == "`") {
        y += n == B ? "\\`" : B;
        continue;
      }
      if (B == "'") {
        y += n == B ? "\\'" : B;
        continue;
      }
    }
    if (B == "\0" && !s && !eL.test(_.charAt(K + 1))) {
      y += "\\0";
      continue;
    }
    if (Zk.test(B)) {
      y += Qk[B];
      continue;
    }
    const C = B.charCodeAt(0);
    if (t.minimal && C != 8232 && C != 8233) {
      y += B;
      continue;
    }
    let L = C.toString(16);
    o || (L = L.toUpperCase());
    const F = L.length > 2 || s, te = "\\" + (F ? "u" : "x") + ("0000" + L).slice(F ? -4 : -2);
    y += te;
  }
  return t.wrap && (y = n + y + n), n == "`" && (y = y.replace(/\$\{/g, "\\${")), t.isScriptContext ? y.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, s ? "\\u003C!--" : "\\x3C!--") : y;
};
Wt.version = "2.5.2";
var rL = Wt;
Object.defineProperty(Fe, "__esModule", {
  value: !0
});
Fe.ArgumentPlaceholder = aL;
Fe.ArrayPattern = Fe.ArrayExpression = fL;
Fe.BigIntLiteral = bL;
Fe.BooleanLiteral = mL;
Fe.DecimalLiteral = gL;
Fe.Identifier = nL;
Fe.NullLiteral = yL;
Fe.NumericLiteral = TL;
Fe.ObjectPattern = Fe.ObjectExpression = lL;
Fe.ObjectMethod = uL;
Fe.ObjectProperty = cL;
Fe.PipelineBareFunction = xL;
Fe.PipelinePrimaryTopicReference = vL;
Fe.PipelineTopicExpression = PL;
Fe.RecordExpression = pL;
Fe.RegExpLiteral = dL;
Fe.SpreadElement = Fe.RestElement = oL;
Fe.StringLiteral = SL;
Fe.TopicReference = EL;
Fe.TupleExpression = hL;
var iL = Ae(), Nf = rL;
const {
  isAssignmentPattern: sL,
  isIdentifier: Pn
} = iL;
function nL(e) {
  var t;
  this.sourceIdentifierName(((t = e.loc) == null ? void 0 : t.identifierName) || e.name), this.word(e.name);
}
function aL() {
  this.tokenChar(63);
}
function oL(e) {
  this.token("..."), this.print(e.argument, e);
}
function lL(e) {
  const t = e.properties;
  this.tokenChar(123), t.length && (this.space(), this.printList(t, e, {
    indent: !0,
    statement: !0
  }), this.space()), this.sourceWithOffset("end", e.loc, -1), this.tokenChar(125);
}
function uL(e) {
  this.printJoin(e.decorators, e), this._methodHead(e), this.space(), this.print(e.body, e);
}
function cL(e) {
  if (this.printJoin(e.decorators, e), e.computed)
    this.tokenChar(91), this.print(e.key, e), this.tokenChar(93);
  else {
    if (sL(e.value) && Pn(e.key) && e.key.name === e.value.left.name) {
      this.print(e.value, e);
      return;
    }
    if (this.print(e.key, e), e.shorthand && Pn(e.key) && Pn(e.value) && e.key.name === e.value.name)
      return;
  }
  this.tokenChar(58), this.space(), this.print(e.value, e);
}
function fL(e) {
  const t = e.elements, r = t.length;
  this.tokenChar(91);
  for (let i = 0; i < t.length; i++) {
    const s = t[i];
    s ? (i > 0 && this.space(), this.print(s, e), i < r - 1 && this.tokenChar(44)) : this.tokenChar(44);
  }
  this.tokenChar(93);
}
function pL(e) {
  const t = e.properties;
  let r, i;
  if (this.format.recordAndTupleSyntaxType === "bar")
    r = "{|", i = "|}";
  else {
    if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null)
      throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);
    r = "#{", i = "}";
  }
  this.token(r), t.length && (this.space(), this.printList(t, e, {
    indent: !0,
    statement: !0
  }), this.space()), this.token(i);
}
function hL(e) {
  const t = e.elements, r = t.length;
  let i, s;
  if (this.format.recordAndTupleSyntaxType === "bar")
    i = "[|", s = "|]";
  else if (this.format.recordAndTupleSyntaxType === "hash")
    i = "#[", s = "]";
  else
    throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
  this.token(i);
  for (let n = 0; n < t.length; n++) {
    const a = t[n];
    a && (n > 0 && this.space(), this.print(a, e), n < r - 1 && this.tokenChar(44));
  }
  this.token(s);
}
function dL(e) {
  this.word(`/${e.pattern}/${e.flags}`);
}
function mL(e) {
  this.word(e.value ? "true" : "false");
}
function yL() {
  this.word("null");
}
function TL(e) {
  const t = this.getPossibleRaw(e), r = this.format.jsescOption, i = e.value + "";
  r.numbers ? this.number(Nf(e.value, r)) : t == null ? this.number(i) : this.format.minified ? this.number(t.length < i.length ? t : i) : this.number(t);
}
function SL(e) {
  const t = this.getPossibleRaw(e);
  if (!this.format.minified && t !== void 0) {
    this.token(t);
    return;
  }
  const r = Nf(e.value, this.format.jsescOption);
  this.token(r);
}
function bL(e) {
  const t = this.getPossibleRaw(e);
  if (!this.format.minified && t !== void 0) {
    this.word(t);
    return;
  }
  this.word(e.value + "n");
}
function gL(e) {
  const t = this.getPossibleRaw(e);
  if (!this.format.minified && t !== void 0) {
    this.word(t);
    return;
  }
  this.word(e.value + "m");
}
const Hl = /* @__PURE__ */ new Set(["^^", "@@", "^", "%", "#"]);
function EL() {
  const {
    topicToken: e
  } = this.format;
  if (Hl.has(e))
    this.token(e);
  else {
    const t = JSON.stringify(e), r = Array.from(Hl, (i) => JSON.stringify(i));
    throw new Error(`The "topicToken" generator option must be one of ${r.join(", ")} (${t} received instead).`);
  }
}
function PL(e) {
  this.print(e.expression, e);
}
function xL(e) {
  this.print(e.callee, e);
}
function vL() {
  this.tokenChar(35);
}
var _f = {};
(function(e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), e.AnyTypeAnnotation = a, e.ArrayTypeAnnotation = o, e.BooleanLiteralTypeAnnotation = u, e.BooleanTypeAnnotation = l, e.DeclareClass = p, e.DeclareExportAllDeclaration = B, e.DeclareExportDeclaration = R, e.DeclareFunction = h, e.DeclareInterface = v, e.DeclareModule = w, e.DeclareModuleExports = x, e.DeclareOpaqueType = _, e.DeclareTypeAlias = O, e.DeclareVariable = K, e.DeclaredPredicate = P, e.EmptyTypeAnnotation = z, e.EnumBooleanBody = te, e.EnumBooleanMember = M, e.EnumDeclaration = C, e.EnumDefaultedMember = me, e.EnumNumberBody = Z, e.EnumNumberMember = D, e.EnumStringBody = J, e.EnumStringMember = j, e.EnumSymbolBody = ce, e.ExistsTypeAnnotation = W, e.FunctionTypeAnnotation = ae, e.FunctionTypeParam = ie, e.IndexedAccessType = rn, e.InferredPredicate = y, e.InterfaceDeclaration = Je, e.GenericTypeAnnotation = e.ClassImplements = e.InterfaceExtends = ge, e.InterfaceTypeAnnotation = We, e.IntersectionTypeAnnotation = Y, e.MixedTypeAnnotation = V, e.NullLiteralTypeAnnotation = c, e.NullableTypeAnnotation = ee, Object.defineProperty(e, "NumberLiteralTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return i.NumericLiteral;
    }
  }), e.NumberTypeAnnotation = Se, e.ObjectTypeAnnotation = U, e.ObjectTypeCallProperty = ue, e.ObjectTypeIndexer = xe, e.ObjectTypeInternalSlot = G, e.ObjectTypeProperty = Ge, e.ObjectTypeSpreadProperty = et, e.OpaqueType = I, e.OptionalIndexedAccessType = sn, e.QualifiedTypeIdentifier = ot, Object.defineProperty(e, "StringLiteralTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return i.StringLiteral;
    }
  }), e.StringTypeAnnotation = oe, e.SymbolTypeAnnotation = ct, e.ThisTypeAnnotation = ye, e.TupleTypeAnnotation = Q, e.TypeAlias = ve, e.TypeAnnotation = De, e.TypeCastExpression = re, e.TypeParameter = S, e.TypeParameterDeclaration = e.TypeParameterInstantiation = $, e.TypeofTypeAnnotation = pe, e.UnionTypeAnnotation = ft, e.Variance = gr, e.VoidTypeAnnotation = er, e._interfaceish = Ce, e._variance = je;
  var t = Ae(), r = at, i = Fe;
  const {
    isDeclareExportDeclaration: s,
    isStatement: n
  } = t;
  function a() {
    this.word("any");
  }
  function o(E) {
    this.print(E.elementType, E, !0), this.tokenChar(91), this.tokenChar(93);
  }
  function l() {
    this.word("boolean");
  }
  function u(E) {
    this.word(E.value ? "true" : "false");
  }
  function c() {
    this.word("null");
  }
  function p(E, be) {
    s(be) || (this.word("declare"), this.space()), this.word("class"), this.space(), this._interfaceish(E);
  }
  function h(E, be) {
    s(be) || (this.word("declare"), this.space()), this.word("function"), this.space(), this.print(E.id, E), this.print(E.id.typeAnnotation.typeAnnotation, E), E.predicate && (this.space(), this.print(E.predicate, E)), this.semicolon();
  }
  function y() {
    this.tokenChar(37), this.word("checks");
  }
  function P(E) {
    this.tokenChar(37), this.word("checks"), this.tokenChar(40), this.print(E.value, E), this.tokenChar(41);
  }
  function v(E) {
    this.word("declare"), this.space(), this.InterfaceDeclaration(E);
  }
  function w(E) {
    this.word("declare"), this.space(), this.word("module"), this.space(), this.print(E.id, E), this.space(), this.print(E.body, E);
  }
  function x(E) {
    this.word("declare"), this.space(), this.word("module"), this.tokenChar(46), this.word("exports"), this.print(E.typeAnnotation, E);
  }
  function O(E) {
    this.word("declare"), this.space(), this.TypeAlias(E);
  }
  function _(E, be) {
    s(be) || (this.word("declare"), this.space()), this.OpaqueType(E);
  }
  function K(E, be) {
    s(be) || (this.word("declare"), this.space()), this.word("var"), this.space(), this.print(E.id, E), this.print(E.id.typeAnnotation, E), this.semicolon();
  }
  function R(E) {
    this.word("declare"), this.space(), this.word("export"), this.space(), E.default && (this.word("default"), this.space()), X.call(this, E);
  }
  function B(E) {
    this.word("declare"), this.space(), r.ExportAllDeclaration.call(this, E);
  }
  function C(E) {
    const {
      id: be,
      body: $e
    } = E;
    this.word("enum"), this.space(), this.print(be, E), this.print($e, E);
  }
  function L(E, be, $e) {
    $e && (E.space(), E.word("of"), E.space(), E.word(be)), E.space();
  }
  function F(E, be) {
    const {
      members: $e
    } = be;
    E.token("{"), E.indent(), E.newline();
    for (const $t of $e)
      E.print($t, be), E.newline();
    be.hasUnknownMembers && (E.token("..."), E.newline()), E.dedent(), E.token("}");
  }
  function te(E) {
    const {
      explicitType: be
    } = E;
    L(this, "boolean", be), F(this, E);
  }
  function Z(E) {
    const {
      explicitType: be
    } = E;
    L(this, "number", be), F(this, E);
  }
  function J(E) {
    const {
      explicitType: be
    } = E;
    L(this, "string", be), F(this, E);
  }
  function ce(E) {
    L(this, "symbol", !0), F(this, E);
  }
  function me(E) {
    const {
      id: be
    } = E;
    this.print(be, E), this.tokenChar(44);
  }
  function k(E, be) {
    const {
      id: $e,
      init: $t
    } = be;
    E.print($e, be), E.space(), E.token("="), E.space(), E.print($t, be), E.token(",");
  }
  function M(E) {
    k(this, E);
  }
  function D(E) {
    k(this, E);
  }
  function j(E) {
    k(this, E);
  }
  function X(E) {
    if (E.declaration) {
      const be = E.declaration;
      this.print(be, E), n(be) || this.semicolon();
    } else
      this.tokenChar(123), E.specifiers.length && (this.space(), this.printList(E.specifiers, E), this.space()), this.tokenChar(125), E.source && (this.space(), this.word("from"), this.space(), this.print(E.source, E)), this.semicolon();
  }
  function W() {
    this.tokenChar(42);
  }
  function ae(E, be) {
    this.print(E.typeParameters, E), this.tokenChar(40), E.this && (this.word("this"), this.tokenChar(58), this.space(), this.print(E.this.typeAnnotation, E), (E.params.length || E.rest) && (this.tokenChar(44), this.space())), this.printList(E.params, E), E.rest && (E.params.length && (this.tokenChar(44), this.space()), this.token("..."), this.print(E.rest, E)), this.tokenChar(41);
    const $e = be == null ? void 0 : be.type;
    $e != null && ($e === "ObjectTypeCallProperty" || $e === "ObjectTypeInternalSlot" || $e === "DeclareFunction" || $e === "ObjectTypeProperty" && be.method) ? this.tokenChar(58) : (this.space(), this.token("=>")), this.space(), this.print(E.returnType, E);
  }
  function ie(E) {
    this.print(E.name, E), E.optional && this.tokenChar(63), E.name && (this.tokenChar(58), this.space()), this.print(E.typeAnnotation, E);
  }
  function ge(E) {
    this.print(E.id, E), this.print(E.typeParameters, E, !0);
  }
  function Ce(E) {
    var be;
    if (this.print(E.id, E), this.print(E.typeParameters, E), (be = E.extends) != null && be.length && (this.space(), this.word("extends"), this.space(), this.printList(E.extends, E)), E.type === "DeclareClass") {
      var $e, $t;
      ($e = E.mixins) != null && $e.length && (this.space(), this.word("mixins"), this.space(), this.printList(E.mixins, E)), ($t = E.implements) != null && $t.length && (this.space(), this.word("implements"), this.space(), this.printList(E.implements, E));
    }
    this.space(), this.print(E.body, E);
  }
  function je(E) {
    var be;
    const $e = (be = E.variance) == null ? void 0 : be.kind;
    $e != null && ($e === "plus" ? this.tokenChar(43) : $e === "minus" && this.tokenChar(45));
  }
  function Je(E) {
    this.word("interface"), this.space(), this._interfaceish(E);
  }
  function He() {
    this.space(), this.tokenChar(38), this.space();
  }
  function We(E) {
    var be;
    this.word("interface"), (be = E.extends) != null && be.length && (this.space(), this.word("extends"), this.space(), this.printList(E.extends, E)), this.space(), this.print(E.body, E);
  }
  function Y(E) {
    this.printJoin(E.types, E, {
      separator: He
    });
  }
  function V() {
    this.word("mixed");
  }
  function z() {
    this.word("empty");
  }
  function ee(E) {
    this.tokenChar(63), this.print(E.typeAnnotation, E);
  }
  function Se() {
    this.word("number");
  }
  function oe() {
    this.word("string");
  }
  function ye() {
    this.word("this");
  }
  function Q(E) {
    this.tokenChar(91), this.printList(E.types, E), this.tokenChar(93);
  }
  function pe(E) {
    this.word("typeof"), this.space(), this.print(E.argument, E);
  }
  function ve(E) {
    this.word("type"), this.space(), this.print(E.id, E), this.print(E.typeParameters, E), this.space(), this.tokenChar(61), this.space(), this.print(E.right, E), this.semicolon();
  }
  function De(E) {
    this.tokenChar(58), this.space(), E.optional && this.tokenChar(63), this.print(E.typeAnnotation, E);
  }
  function $(E) {
    this.tokenChar(60), this.printList(E.params, E, {}), this.tokenChar(62);
  }
  function S(E) {
    this._variance(E), this.word(E.name), E.bound && this.print(E.bound, E), E.default && (this.space(), this.tokenChar(61), this.space(), this.print(E.default, E));
  }
  function I(E) {
    this.word("opaque"), this.space(), this.word("type"), this.space(), this.print(E.id, E), this.print(E.typeParameters, E), E.supertype && (this.tokenChar(58), this.space(), this.print(E.supertype, E)), E.impltype && (this.space(), this.tokenChar(61), this.space(), this.print(E.impltype, E)), this.semicolon();
  }
  function U(E) {
    E.exact ? this.token("{|") : this.tokenChar(123);
    const be = [...E.properties, ...E.callProperties || [], ...E.indexers || [], ...E.internalSlots || []];
    be.length && (this.newline(), this.space(), this.printJoin(be, E, {
      addNewlines($e) {
        if ($e && !be[0])
          return 1;
      },
      indent: !0,
      statement: !0,
      iterator: () => {
        (be.length !== 1 || E.inexact) && (this.tokenChar(44), this.space());
      }
    }), this.space()), E.inexact && (this.indent(), this.token("..."), be.length && this.newline(), this.dedent()), E.exact ? this.token("|}") : this.tokenChar(125);
  }
  function G(E) {
    E.static && (this.word("static"), this.space()), this.tokenChar(91), this.tokenChar(91), this.print(E.id, E), this.tokenChar(93), this.tokenChar(93), E.optional && this.tokenChar(63), E.method || (this.tokenChar(58), this.space()), this.print(E.value, E);
  }
  function ue(E) {
    E.static && (this.word("static"), this.space()), this.print(E.value, E);
  }
  function xe(E) {
    E.static && (this.word("static"), this.space()), this._variance(E), this.tokenChar(91), E.id && (this.print(E.id, E), this.tokenChar(58), this.space()), this.print(E.key, E), this.tokenChar(93), this.tokenChar(58), this.space(), this.print(E.value, E);
  }
  function Ge(E) {
    E.proto && (this.word("proto"), this.space()), E.static && (this.word("static"), this.space()), (E.kind === "get" || E.kind === "set") && (this.word(E.kind), this.space()), this._variance(E), this.print(E.key, E), E.optional && this.tokenChar(63), E.method || (this.tokenChar(58), this.space()), this.print(E.value, E);
  }
  function et(E) {
    this.token("..."), this.print(E.argument, E);
  }
  function ot(E) {
    this.print(E.qualification, E), this.tokenChar(46), this.print(E.id, E);
  }
  function ct() {
    this.word("symbol");
  }
  function tt() {
    this.space(), this.tokenChar(124), this.space();
  }
  function ft(E) {
    this.printJoin(E.types, E, {
      separator: tt
    });
  }
  function re(E) {
    this.tokenChar(40), this.print(E.expression, E), this.print(E.typeAnnotation, E), this.tokenChar(41);
  }
  function gr(E) {
    E.kind === "plus" ? this.tokenChar(43) : this.tokenChar(45);
  }
  function er() {
    this.word("void");
  }
  function rn(E) {
    this.print(E.objectType, E, !0), this.tokenChar(91), this.print(E.indexType, E), this.tokenChar(93);
  }
  function sn(E) {
    this.print(E.objectType, E), E.optional && this.token("?."), this.tokenChar(91), this.print(E.indexType, E), this.tokenChar(93);
  }
})(_f);
var Rt = {};
Object.defineProperty(Rt, "__esModule", {
  value: !0
});
Rt.BlockStatement = IL;
Rt.Directive = wL;
Rt.DirectiveLiteral = _L;
Rt.File = AL;
Rt.InterpreterDirective = DL;
Rt.Placeholder = kL;
Rt.Program = CL;
function AL(e) {
  e.program && this.print(e.program.interpreter, e), this.print(e.program, e);
}
function CL(e) {
  var t;
  this.noIndentInnerCommentsHere(), this.printInnerComments();
  const r = (t = e.directives) == null ? void 0 : t.length;
  if (r) {
    var i;
    const s = e.body.length ? 2 : 1;
    this.printSequence(e.directives, e, {
      trailingCommentsLineOffset: s
    }), (i = e.directives[r - 1].trailingComments) != null && i.length || this.newline(s);
  }
  this.printSequence(e.body, e);
}
function IL(e) {
  var t;
  this.tokenChar(123);
  const r = (t = e.directives) == null ? void 0 : t.length;
  if (r) {
    var i;
    const s = e.body.length ? 2 : 1;
    this.printSequence(e.directives, e, {
      indent: !0,
      trailingCommentsLineOffset: s
    }), (i = e.directives[r - 1].trailingComments) != null && i.length || this.newline(s);
  }
  this.printSequence(e.body, e, {
    indent: !0
  }), this.rightBrace(e);
}
function wL(e) {
  this.print(e.value, e), this.semicolon();
}
const OL = /(?:^|[^\\])(?:\\\\)*'/, NL = /(?:^|[^\\])(?:\\\\)*"/;
function _L(e) {
  const t = this.getPossibleRaw(e);
  if (!this.format.minified && t !== void 0) {
    this.token(t);
    return;
  }
  const {
    value: r
  } = e;
  if (!NL.test(r))
    this.token(`"${r}"`);
  else if (!OL.test(r))
    this.token(`'${r}'`);
  else
    throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
}
function DL(e) {
  this.token(`#!${e.value}`), this.newline(1, !0);
}
function kL(e) {
  this.token("%%"), this.print(e.name), this.token("%%"), e.expectedNode === "Statement" && this.semicolon();
}
var Qe = {};
Object.defineProperty(Qe, "__esModule", {
  value: !0
});
Qe.JSXAttribute = LL;
Qe.JSXClosingElement = WL;
Qe.JSXClosingFragment = HL;
Qe.JSXElement = VL;
Qe.JSXEmptyExpression = YL;
Qe.JSXExpressionContainer = RL;
Qe.JSXFragment = XL;
Qe.JSXIdentifier = ML;
Qe.JSXMemberExpression = FL;
Qe.JSXNamespacedName = BL;
Qe.JSXOpeningElement = qL;
Qe.JSXOpeningFragment = JL;
Qe.JSXSpreadAttribute = jL;
Qe.JSXSpreadChild = $L;
Qe.JSXText = UL;
function LL(e) {
  this.print(e.name, e), e.value && (this.tokenChar(61), this.print(e.value, e));
}
function ML(e) {
  this.word(e.name);
}
function BL(e) {
  this.print(e.namespace, e), this.tokenChar(58), this.print(e.name, e);
}
function FL(e) {
  this.print(e.object, e), this.tokenChar(46), this.print(e.property, e);
}
function jL(e) {
  this.tokenChar(123), this.token("..."), this.print(e.argument, e), this.tokenChar(125);
}
function RL(e) {
  this.tokenChar(123), this.print(e.expression, e), this.tokenChar(125);
}
function $L(e) {
  this.tokenChar(123), this.token("..."), this.print(e.expression, e), this.tokenChar(125);
}
function UL(e) {
  const t = this.getPossibleRaw(e);
  t !== void 0 ? this.token(t, !0) : this.token(e.value, !0);
}
function VL(e) {
  const t = e.openingElement;
  if (this.print(t, e), !t.selfClosing) {
    this.indent();
    for (const r of e.children)
      this.print(r, e);
    this.dedent(), this.print(e.closingElement, e);
  }
}
function KL() {
  this.space();
}
function qL(e) {
  this.tokenChar(60), this.print(e.name, e), this.print(e.typeParameters, e), e.attributes.length > 0 && (this.space(), this.printJoin(e.attributes, e, {
    separator: KL
  })), e.selfClosing ? (this.space(), this.token("/>")) : this.tokenChar(62);
}
function WL(e) {
  this.token("</"), this.print(e.name, e), this.tokenChar(62);
}
function YL() {
  this.printInnerComments();
}
function XL(e) {
  this.print(e.openingFragment, e), this.indent();
  for (const t of e.children)
    this.print(t, e);
  this.dedent(), this.print(e.closingFragment, e);
}
function JL() {
  this.tokenChar(60), this.tokenChar(62);
}
function HL() {
  this.token("</"), this.tokenChar(62);
}
var ne = {};
Object.defineProperty(ne, "__esModule", {
  value: !0
});
ne.TSAnyKeyword = uM;
ne.TSArrayType = _M;
ne.TSSatisfiesExpression = ne.TSAsExpression = HM;
ne.TSBigIntKeyword = cM;
ne.TSBooleanKeyword = dM;
ne.TSCallSignatureDeclaration = iM;
ne.TSConditionalType = jM;
ne.TSConstructSignatureDeclaration = sM;
ne.TSConstructorType = vM;
ne.TSDeclareFunction = eM;
ne.TSDeclareMethod = tM;
ne.TSEnumDeclaration = QM;
ne.TSEnumMember = ZM;
ne.TSExportAssignment = aB;
ne.TSExpressionWithTypeArguments = WM;
ne.TSExternalModuleReference = sB;
ne.TSFunctionType = xM;
ne.TSImportEqualsDeclaration = iB;
ne.TSImportType = rB;
ne.TSIndexSignature = lM;
ne.TSIndexedAccessType = VM;
ne.TSInferType = RM;
ne.TSInstantiationExpression = zM;
ne.TSInterfaceBody = XM;
ne.TSInterfaceDeclaration = YM;
ne.TSIntersectionType = FM;
ne.TSIntrinsicKeyword = EM;
ne.TSLiteralType = qM;
ne.TSMappedType = KM;
ne.TSMethodSignature = oM;
ne.TSModuleBlock = tB;
ne.TSModuleDeclaration = eB;
ne.TSNamedTupleMember = MM;
ne.TSNamespaceExportDeclaration = oB;
ne.TSNeverKeyword = gM;
ne.TSNonNullExpression = nB;
ne.TSNullKeyword = bM;
ne.TSNumberKeyword = pM;
ne.TSObjectKeyword = hM;
ne.TSOptionalType = kM;
ne.TSParameterProperty = ZL;
ne.TSParenthesizedType = $M;
ne.TSPropertySignature = nM;
ne.TSQualifiedName = rM;
ne.TSRestType = LM;
ne.TSStringKeyword = mM;
ne.TSSymbolKeyword = yM;
ne.TSThisType = PM;
ne.TSTupleType = DM;
ne.TSTypeAliasDeclaration = JM;
ne.TSTypeAnnotation = GL;
ne.TSTypeAssertion = GM;
ne.TSTypeLiteral = OM;
ne.TSTypeOperator = UM;
ne.TSTypeParameter = QL;
ne.TSTypeParameterDeclaration = ne.TSTypeParameterInstantiation = zL;
ne.TSTypePredicate = IM;
ne.TSTypeQuery = wM;
ne.TSTypeReference = CM;
ne.TSUndefinedKeyword = SM;
ne.TSUnionType = BM;
ne.TSUnknownKeyword = fM;
ne.TSVoidKeyword = TM;
ne.tsPrintClassMemberModifiers = uB;
ne.tsPrintFunctionOrConstructorType = AM;
ne.tsPrintPropertyOrMethodName = aM;
ne.tsPrintSignatureDeclarationBase = lB;
ne.tsPrintTypeLiteralOrInterfaceBody = NM;
function GL(e) {
  this.tokenChar(58), this.space(), e.optional && this.tokenChar(63), this.print(e.typeAnnotation, e);
}
function zL(e, t) {
  this.tokenChar(60), this.printList(e.params, e, {}), t.type === "ArrowFunctionExpression" && e.params.length === 1 && this.tokenChar(44), this.tokenChar(62);
}
function QL(e) {
  e.in && (this.word("in"), this.space()), e.out && (this.word("out"), this.space()), this.word(e.name), e.constraint && (this.space(), this.word("extends"), this.space(), this.print(e.constraint, e)), e.default && (this.space(), this.tokenChar(61), this.space(), this.print(e.default, e));
}
function ZL(e) {
  e.accessibility && (this.word(e.accessibility), this.space()), e.readonly && (this.word("readonly"), this.space()), this._param(e.parameter);
}
function eM(e, t) {
  e.declare && (this.word("declare"), this.space()), this._functionHead(e, t), this.tokenChar(59);
}
function tM(e) {
  this._classMethodHead(e), this.tokenChar(59);
}
function rM(e) {
  this.print(e.left, e), this.tokenChar(46), this.print(e.right, e);
}
function iM(e) {
  this.tsPrintSignatureDeclarationBase(e), this.tokenChar(59);
}
function sM(e) {
  this.word("new"), this.space(), this.tsPrintSignatureDeclarationBase(e), this.tokenChar(59);
}
function nM(e) {
  const {
    readonly: t,
    initializer: r
  } = e;
  t && (this.word("readonly"), this.space()), this.tsPrintPropertyOrMethodName(e), this.print(e.typeAnnotation, e), r && (this.space(), this.tokenChar(61), this.space(), this.print(r, e)), this.tokenChar(59);
}
function aM(e) {
  e.computed && this.tokenChar(91), this.print(e.key, e), e.computed && this.tokenChar(93), e.optional && this.tokenChar(63);
}
function oM(e) {
  const {
    kind: t
  } = e;
  (t === "set" || t === "get") && (this.word(t), this.space()), this.tsPrintPropertyOrMethodName(e), this.tsPrintSignatureDeclarationBase(e), this.tokenChar(59);
}
function lM(e) {
  const {
    readonly: t,
    static: r
  } = e;
  r && (this.word("static"), this.space()), t && (this.word("readonly"), this.space()), this.tokenChar(91), this._parameters(e.parameters, e), this.tokenChar(93), this.print(e.typeAnnotation, e), this.tokenChar(59);
}
function uM() {
  this.word("any");
}
function cM() {
  this.word("bigint");
}
function fM() {
  this.word("unknown");
}
function pM() {
  this.word("number");
}
function hM() {
  this.word("object");
}
function dM() {
  this.word("boolean");
}
function mM() {
  this.word("string");
}
function yM() {
  this.word("symbol");
}
function TM() {
  this.word("void");
}
function SM() {
  this.word("undefined");
}
function bM() {
  this.word("null");
}
function gM() {
  this.word("never");
}
function EM() {
  this.word("intrinsic");
}
function PM() {
  this.word("this");
}
function xM(e) {
  this.tsPrintFunctionOrConstructorType(e);
}
function vM(e) {
  e.abstract && (this.word("abstract"), this.space()), this.word("new"), this.space(), this.tsPrintFunctionOrConstructorType(e);
}
function AM(e) {
  const {
    typeParameters: t
  } = e, r = e.parameters;
  this.print(t, e), this.tokenChar(40), this._parameters(r, e), this.tokenChar(41), this.space(), this.token("=>"), this.space();
  const i = e.typeAnnotation;
  this.print(i.typeAnnotation, e);
}
function CM(e) {
  this.print(e.typeName, e, !0), this.print(e.typeParameters, e, !0);
}
function IM(e) {
  e.asserts && (this.word("asserts"), this.space()), this.print(e.parameterName), e.typeAnnotation && (this.space(), this.word("is"), this.space(), this.print(e.typeAnnotation.typeAnnotation));
}
function wM(e) {
  this.word("typeof"), this.space(), this.print(e.exprName), e.typeParameters && this.print(e.typeParameters, e);
}
function OM(e) {
  this.tsPrintTypeLiteralOrInterfaceBody(e.members, e);
}
function NM(e, t) {
  ro(this, e, t);
}
function ro(e, t, r) {
  if (e.token("{"), t.length) {
    e.indent(), e.newline();
    for (const i of t)
      e.print(i, r), e.newline();
    e.dedent();
  }
  e.rightBrace(r);
}
function _M(e) {
  this.print(e.elementType, e, !0), this.token("[]");
}
function DM(e) {
  this.tokenChar(91), this.printList(e.elementTypes, e), this.tokenChar(93);
}
function kM(e) {
  this.print(e.typeAnnotation, e), this.tokenChar(63);
}
function LM(e) {
  this.token("..."), this.print(e.typeAnnotation, e);
}
function MM(e) {
  this.print(e.label, e), e.optional && this.tokenChar(63), this.tokenChar(58), this.space(), this.print(e.elementType, e);
}
function BM(e) {
  Df(this, e, "|");
}
function FM(e) {
  Df(this, e, "&");
}
function Df(e, t, r) {
  e.printJoin(t.types, t, {
    separator() {
      this.space(), this.token(r), this.space();
    }
  });
}
function jM(e) {
  this.print(e.checkType), this.space(), this.word("extends"), this.space(), this.print(e.extendsType), this.space(), this.tokenChar(63), this.space(), this.print(e.trueType), this.space(), this.tokenChar(58), this.space(), this.print(e.falseType);
}
function RM(e) {
  this.token("infer"), this.space(), this.print(e.typeParameter);
}
function $M(e) {
  this.tokenChar(40), this.print(e.typeAnnotation, e), this.tokenChar(41);
}
function UM(e) {
  this.word(e.operator), this.space(), this.print(e.typeAnnotation, e);
}
function VM(e) {
  this.print(e.objectType, e, !0), this.tokenChar(91), this.print(e.indexType, e), this.tokenChar(93);
}
function KM(e) {
  const {
    nameType: t,
    optional: r,
    readonly: i,
    typeParameter: s
  } = e;
  this.tokenChar(123), this.space(), i && (Gl(this, i), this.word("readonly"), this.space()), this.tokenChar(91), this.word(s.name), this.space(), this.word("in"), this.space(), this.print(s.constraint, s), t && (this.space(), this.word("as"), this.space(), this.print(t, e)), this.tokenChar(93), r && (Gl(this, r), this.tokenChar(63)), this.tokenChar(58), this.space(), this.print(e.typeAnnotation, e), this.space(), this.tokenChar(125);
}
function Gl(e, t) {
  t !== !0 && e.token(t);
}
function qM(e) {
  this.print(e.literal, e);
}
function WM(e) {
  this.print(e.expression, e), this.print(e.typeParameters, e);
}
function YM(e) {
  const {
    declare: t,
    id: r,
    typeParameters: i,
    extends: s,
    body: n
  } = e;
  t && (this.word("declare"), this.space()), this.word("interface"), this.space(), this.print(r, e), this.print(i, e), s != null && s.length && (this.space(), this.word("extends"), this.space(), this.printList(s, e)), this.space(), this.print(n, e);
}
function XM(e) {
  this.tsPrintTypeLiteralOrInterfaceBody(e.body, e);
}
function JM(e) {
  const {
    declare: t,
    id: r,
    typeParameters: i,
    typeAnnotation: s
  } = e;
  t && (this.word("declare"), this.space()), this.word("type"), this.space(), this.print(r, e), this.print(i, e), this.space(), this.tokenChar(61), this.space(), this.print(s, e), this.tokenChar(59);
}
function HM(e) {
  var t;
  const {
    type: r,
    expression: i,
    typeAnnotation: s
  } = e, n = !!((t = i.trailingComments) != null && t.length);
  this.print(i, e, !0, void 0, n), this.space(), this.word(r === "TSAsExpression" ? "as" : "satisfies"), this.space(), this.print(s, e);
}
function GM(e) {
  const {
    typeAnnotation: t,
    expression: r
  } = e;
  this.tokenChar(60), this.print(t, e), this.tokenChar(62), this.space(), this.print(r, e);
}
function zM(e) {
  this.print(e.expression, e), this.print(e.typeParameters, e);
}
function QM(e) {
  const {
    declare: t,
    const: r,
    id: i,
    members: s
  } = e;
  t && (this.word("declare"), this.space()), r && (this.word("const"), this.space()), this.word("enum"), this.space(), this.print(i, e), this.space(), ro(this, s, e);
}
function ZM(e) {
  const {
    id: t,
    initializer: r
  } = e;
  this.print(t, e), r && (this.space(), this.tokenChar(61), this.space(), this.print(r, e)), this.tokenChar(44);
}
function eB(e) {
  const {
    declare: t,
    id: r
  } = e;
  if (t && (this.word("declare"), this.space()), e.global || (this.word(r.type === "Identifier" ? "namespace" : "module"), this.space()), this.print(r, e), !e.body) {
    this.tokenChar(59);
    return;
  }
  let i = e.body;
  for (; i.type === "TSModuleDeclaration"; )
    this.tokenChar(46), this.print(i.id, i), i = i.body;
  this.space(), this.print(i, e);
}
function tB(e) {
  ro(this, e.body, e);
}
function rB(e) {
  const {
    argument: t,
    qualifier: r,
    typeParameters: i
  } = e;
  this.word("import"), this.tokenChar(40), this.print(t, e), this.tokenChar(41), r && (this.tokenChar(46), this.print(r, e)), i && this.print(i, e);
}
function iB(e) {
  const {
    isExport: t,
    id: r,
    moduleReference: i
  } = e;
  t && (this.word("export"), this.space()), this.word("import"), this.space(), this.print(r, e), this.space(), this.tokenChar(61), this.space(), this.print(i, e), this.tokenChar(59);
}
function sB(e) {
  this.token("require("), this.print(e.expression, e), this.tokenChar(41);
}
function nB(e) {
  this.print(e.expression, e), this.tokenChar(33);
}
function aB(e) {
  this.word("export"), this.space(), this.tokenChar(61), this.space(), this.print(e.expression, e), this.tokenChar(59);
}
function oB(e) {
  this.word("export"), this.space(), this.word("as"), this.space(), this.word("namespace"), this.space(), this.print(e.id, e);
}
function lB(e) {
  const {
    typeParameters: t
  } = e, r = e.parameters;
  this.print(t, e), this.tokenChar(40), this._parameters(r, e), this.tokenChar(41);
  const i = e.typeAnnotation;
  this.print(i, e);
}
function uB(e) {
  const t = e.type === "ClassAccessorProperty" || e.type === "ClassProperty";
  t && e.declare && (this.word("declare"), this.space()), e.accessibility && (this.word(e.accessibility), this.space()), e.static && (this.word("static"), this.space()), e.override && (this.word("override"), this.space()), e.abstract && (this.word("abstract"), this.space()), t && e.readonly && (this.word("readonly"), this.space());
}
(function(e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  });
  var t = gi;
  Object.keys(t).forEach(function(h) {
    h === "default" || h === "__esModule" || h in e && e[h] === t[h] || Object.defineProperty(e, h, {
      enumerable: !0,
      get: function() {
        return t[h];
      }
    });
  });
  var r = Me;
  Object.keys(r).forEach(function(h) {
    h === "default" || h === "__esModule" || h in e && e[h] === r[h] || Object.defineProperty(e, h, {
      enumerable: !0,
      get: function() {
        return r[h];
      }
    });
  });
  var i = Ve;
  Object.keys(i).forEach(function(h) {
    h === "default" || h === "__esModule" || h in e && e[h] === i[h] || Object.defineProperty(e, h, {
      enumerable: !0,
      get: function() {
        return i[h];
      }
    });
  });
  var s = mt;
  Object.keys(s).forEach(function(h) {
    h === "default" || h === "__esModule" || h in e && e[h] === s[h] || Object.defineProperty(e, h, {
      enumerable: !0,
      get: function() {
        return s[h];
      }
    });
  });
  var n = gt;
  Object.keys(n).forEach(function(h) {
    h === "default" || h === "__esModule" || h in e && e[h] === n[h] || Object.defineProperty(e, h, {
      enumerable: !0,
      get: function() {
        return n[h];
      }
    });
  });
  var a = at;
  Object.keys(a).forEach(function(h) {
    h === "default" || h === "__esModule" || h in e && e[h] === a[h] || Object.defineProperty(e, h, {
      enumerable: !0,
      get: function() {
        return a[h];
      }
    });
  });
  var o = Fe;
  Object.keys(o).forEach(function(h) {
    h === "default" || h === "__esModule" || h in e && e[h] === o[h] || Object.defineProperty(e, h, {
      enumerable: !0,
      get: function() {
        return o[h];
      }
    });
  });
  var l = _f;
  Object.keys(l).forEach(function(h) {
    h === "default" || h === "__esModule" || h in e && e[h] === l[h] || Object.defineProperty(e, h, {
      enumerable: !0,
      get: function() {
        return l[h];
      }
    });
  });
  var u = Rt;
  Object.keys(u).forEach(function(h) {
    h === "default" || h === "__esModule" || h in e && e[h] === u[h] || Object.defineProperty(e, h, {
      enumerable: !0,
      get: function() {
        return u[h];
      }
    });
  });
  var c = Qe;
  Object.keys(c).forEach(function(h) {
    h === "default" || h === "__esModule" || h in e && e[h] === c[h] || Object.defineProperty(e, h, {
      enumerable: !0,
      get: function() {
        return c[h];
      }
    });
  });
  var p = ne;
  Object.keys(p).forEach(function(h) {
    h === "default" || h === "__esModule" || h in e && e[h] === p[h] || Object.defineProperty(e, h, {
      enumerable: !0,
      get: function() {
        return p[h];
      }
    });
  });
})(Ef);
Object.defineProperty(Us, "__esModule", {
  value: !0
});
Us.default = void 0;
var cB = Vs, fB = yr, pB = Ae(), hB = Ef;
const {
  isFunction: dB,
  isStatement: mB,
  isClassBody: yB,
  isTSInterfaceBody: TB,
  isTSEnumDeclaration: SB
} = pB, bB = /e/i, gB = /\.0+$/, EB = /^0[box]/, PB = /^\s*[@#]__PURE__\s*$/, zl = /[\n\r\u2028\u2029]/, xB = /\*\//, {
  needsParens: vB
} = fB;
class io {
  constructor(t, r) {
    this.inForStatementInitCounter = 0, this._printStack = [], this._indent = 0, this._indentChar = 0, this._indentRepeat = 0, this._insideAux = !1, this._parenPushNewlineState = null, this._noLineTerminator = !1, this._printAuxAfterOnNextUserNode = !1, this._printedComments = /* @__PURE__ */ new Set(), this._endsWithInteger = !1, this._endsWithWord = !1, this._lastCommentLine = 0, this._endsWithInnerRaw = !1, this._indentInnerComments = !0, this.format = t, this._buf = new cB.default(r), this._indentChar = t.indent.style.charCodeAt(0), this._indentRepeat = t.indent.style.length, this._inputMap = r == null ? void 0 : r._inputMap;
  }
  generate(t) {
    return this.print(t), this._maybeAddAuxComment(), this._buf.get();
  }
  indent() {
    this.format.compact || this.format.concise || this._indent++;
  }
  dedent() {
    this.format.compact || this.format.concise || this._indent--;
  }
  semicolon(t = !1) {
    this._maybeAddAuxComment(), t ? this._appendChar(59) : this._queue(59), this._noLineTerminator = !1;
  }
  rightBrace(t) {
    this.format.minified && this._buf.removeLastSemicolon(), this.sourceWithOffset("end", t.loc, -1), this.tokenChar(125);
  }
  rightParens(t) {
    this.sourceWithOffset("end", t.loc, -1), this.tokenChar(41);
  }
  space(t = !1) {
    if (!this.format.compact) {
      if (t)
        this._space();
      else if (this._buf.hasContent()) {
        const r = this.getLastChar();
        r !== 32 && r !== 10 && this._space();
      }
    }
  }
  word(t, r = !1) {
    this._maybePrintInnerComments(), (this._endsWithWord || t.charCodeAt(0) === 47 && this.endsWith(47)) && this._space(), this._maybeAddAuxComment(), this._append(t, !1), this._endsWithWord = !0, this._noLineTerminator = r;
  }
  number(t) {
    this.word(t), this._endsWithInteger = Number.isInteger(+t) && !EB.test(t) && !bB.test(t) && !gB.test(t) && t.charCodeAt(t.length - 1) !== 46;
  }
  token(t, r = !1) {
    this._maybePrintInnerComments();
    const i = this.getLastChar(), s = t.charCodeAt(0);
    (i === 33 && (t === "--" || s === 61) || s === 43 && i === 43 || s === 45 && i === 45 || s === 46 && this._endsWithInteger) && this._space(), this._maybeAddAuxComment(), this._append(t, r), this._noLineTerminator = !1;
  }
  tokenChar(t) {
    this._maybePrintInnerComments();
    const r = this.getLastChar();
    (t === 43 && r === 43 || t === 45 && r === 45 || t === 46 && this._endsWithInteger) && this._space(), this._maybeAddAuxComment(), this._appendChar(t), this._noLineTerminator = !1;
  }
  newline(t = 1, r) {
    if (!(t <= 0)) {
      if (!r) {
        if (this.format.retainLines || this.format.compact)
          return;
        if (this.format.concise) {
          this.space();
          return;
        }
      }
      t > 2 && (t = 2), t -= this._buf.getNewlineCount();
      for (let i = 0; i < t; i++)
        this._newline();
    }
  }
  endsWith(t) {
    return this.getLastChar() === t;
  }
  getLastChar() {
    return this._buf.getLastChar();
  }
  endsWithCharAndNewline() {
    return this._buf.endsWithCharAndNewline();
  }
  removeTrailingNewline() {
    this._buf.removeTrailingNewline();
  }
  exactSource(t, r) {
    if (!t) {
      r();
      return;
    }
    this._catchUp("start", t), this._buf.exactSource(t, r);
  }
  source(t, r) {
    r && (this._catchUp(t, r), this._buf.source(t, r));
  }
  sourceWithOffset(t, r, i) {
    r && (this._catchUp(t, r), this._buf.sourceWithOffset(t, r, i));
  }
  withSource(t, r, i) {
    if (!r) {
      i();
      return;
    }
    this._catchUp(t, r), this._buf.withSource(t, r, i);
  }
  sourceIdentifierName(t, r) {
    if (!this._buf._canMarkIdName)
      return;
    const i = this._buf._sourcePosition;
    i.identifierNamePos = r, i.identifierName = t;
  }
  _space() {
    this._queue(32);
  }
  _newline() {
    this._queue(10);
  }
  _append(t, r) {
    this._maybeAddParen(t), this._maybeIndent(t.charCodeAt(0)), this._buf.append(t, r), this._endsWithWord = !1, this._endsWithInteger = !1;
  }
  _appendChar(t) {
    this._maybeAddParenChar(t), this._maybeIndent(t), this._buf.appendChar(t), this._endsWithWord = !1, this._endsWithInteger = !1;
  }
  _queue(t) {
    this._maybeAddParenChar(t), this._maybeIndent(t), this._buf.queue(t), this._endsWithWord = !1, this._endsWithInteger = !1;
  }
  _maybeIndent(t) {
    this._indent && t !== 10 && this.endsWith(10) && this._buf.queueIndentation(this._indentChar, this._getIndent());
  }
  _shouldIndent(t) {
    if (this._indent && t !== 10 && this.endsWith(10))
      return !0;
  }
  _maybeAddParenChar(t) {
    const r = this._parenPushNewlineState;
    if (r && t !== 32) {
      if (t !== 10) {
        this._parenPushNewlineState = null;
        return;
      }
      this.tokenChar(40), this.indent(), r.printed = !0;
    }
  }
  _maybeAddParen(t) {
    const r = this._parenPushNewlineState;
    if (!r)
      return;
    const i = t.length;
    let s;
    for (s = 0; s < i && t.charCodeAt(s) === 32; s++)
      ;
    if (s === i)
      return;
    const n = t.charCodeAt(s);
    if (n !== 10) {
      if (n !== 47 || s + 1 === i) {
        this._parenPushNewlineState = null;
        return;
      }
      const a = t.charCodeAt(s + 1);
      if (a === 42) {
        if (PB.test(t.slice(s + 2, i - 2)))
          return;
      } else if (a !== 47) {
        this._parenPushNewlineState = null;
        return;
      }
    }
    this.tokenChar(40), this.indent(), r.printed = !0;
  }
  catchUp(t) {
    if (!this.format.retainLines)
      return;
    const r = t - this._buf.getCurrentLine();
    for (let i = 0; i < r; i++)
      this._newline();
  }
  _catchUp(t, r) {
    var i;
    if (!this.format.retainLines)
      return;
    const s = r == null || (i = r[t]) == null ? void 0 : i.line;
    if (s != null) {
      const n = s - this._buf.getCurrentLine();
      for (let a = 0; a < n; a++)
        this._newline();
    }
  }
  _getIndent() {
    return this._indentRepeat * this._indent;
  }
  printTerminatorless(t, r, i) {
    if (i)
      this._noLineTerminator = !0, this.print(t, r);
    else {
      const s = {
        printed: !1
      };
      this._parenPushNewlineState = s, this.print(t, r), s.printed && (this.dedent(), this.newline(), this.tokenChar(41));
    }
  }
  print(t, r, i, s, n) {
    var a;
    if (!t)
      return;
    this._endsWithInnerRaw = !1;
    const o = t.type, l = this.format, u = l.concise;
    t._compact && (l.concise = !0);
    const c = this[o];
    if (c === void 0)
      throw new ReferenceError(`unknown node of type ${JSON.stringify(o)} with constructor ${JSON.stringify(t.constructor.name)}`);
    this._printStack.push(t);
    const p = this._insideAux;
    this._insideAux = t.loc == null, this._maybeAddAuxComment(this._insideAux && !p);
    const h = n || l.retainFunctionParens && o === "FunctionExpression" && ((a = t.extra) == null ? void 0 : a.parenthesized) || vB(t, r, this._printStack);
    h && (this.tokenChar(40), this._endsWithInnerRaw = !1), this._lastCommentLine = 0, this._printLeadingComments(t, r);
    const y = o === "Program" || o === "File" ? null : t.loc;
    this.exactSource(y, c.bind(this, t, r)), h ? (this._printTrailingComments(t, r), this.tokenChar(41), this._noLineTerminator = i) : i && !this._noLineTerminator ? (this._noLineTerminator = !0, this._printTrailingComments(t, r)) : this._printTrailingComments(t, r, s), this._printStack.pop(), l.concise = u, this._insideAux = p, this._endsWithInnerRaw = !1;
  }
  _maybeAddAuxComment(t) {
    t && this._printAuxBeforeComment(), this._insideAux || this._printAuxAfterComment();
  }
  _printAuxBeforeComment() {
    if (this._printAuxAfterOnNextUserNode)
      return;
    this._printAuxAfterOnNextUserNode = !0;
    const t = this.format.auxiliaryCommentBefore;
    t && this._printComment({
      type: "CommentBlock",
      value: t
    }, 0);
  }
  _printAuxAfterComment() {
    if (!this._printAuxAfterOnNextUserNode)
      return;
    this._printAuxAfterOnNextUserNode = !1;
    const t = this.format.auxiliaryCommentAfter;
    t && this._printComment({
      type: "CommentBlock",
      value: t
    }, 0);
  }
  getPossibleRaw(t) {
    const r = t.extra;
    if (r && r.raw != null && r.rawValue != null && t.value === r.rawValue)
      return r.raw;
  }
  printJoin(t, r, i = {}) {
    if (!(t != null && t.length))
      return;
    let {
      indent: s
    } = i;
    if (s == null && this.format.retainLines) {
      var n;
      const c = (n = t[0].loc) == null ? void 0 : n.start.line;
      c != null && c !== this._buf.getCurrentLine() && (s = !0);
    }
    s && this.indent();
    const a = {
      addNewlines: i.addNewlines,
      nextNodeStartLine: 0
    }, o = i.separator ? i.separator.bind(this) : null, l = t.length;
    for (let c = 0; c < l; c++) {
      const p = t[c];
      if (p && (i.statement && this._printNewline(c === 0, a), this.print(p, r, void 0, i.trailingCommentsLineOffset || 0), i.iterator == null || i.iterator(p, c), c < l - 1 && (o == null || o()), i.statement))
        if (c + 1 === l)
          this.newline(1);
        else {
          var u;
          const h = t[c + 1];
          a.nextNodeStartLine = ((u = h.loc) == null ? void 0 : u.start.line) || 0, this._printNewline(!0, a);
        }
    }
    s && this.dedent();
  }
  printAndIndentOnComments(t, r) {
    const i = t.leadingComments && t.leadingComments.length > 0;
    i && this.indent(), this.print(t, r), i && this.dedent();
  }
  printBlock(t) {
    const r = t.body;
    r.type !== "EmptyStatement" && this.space(), this.print(r, t);
  }
  _printTrailingComments(t, r, i) {
    const {
      innerComments: s,
      trailingComments: n
    } = t;
    s != null && s.length && this._printComments(2, s, t, r, i), n != null && n.length && this._printComments(2, n, t, r, i);
  }
  _printLeadingComments(t, r) {
    const i = t.leadingComments;
    i != null && i.length && this._printComments(0, i, t, r);
  }
  _maybePrintInnerComments() {
    this._endsWithInnerRaw && this.printInnerComments(), this._endsWithInnerRaw = !0, this._indentInnerComments = !0;
  }
  printInnerComments() {
    const t = this._printStack[this._printStack.length - 1], r = t.innerComments;
    if (!(r != null && r.length))
      return;
    const i = this.endsWith(32), s = this._indentInnerComments, n = this._printedComments.size;
    s && this.indent(), this._printComments(1, r, t), i && n !== this._printedComments.size && this.space(), s && this.dedent();
  }
  noIndentInnerCommentsHere() {
    this._indentInnerComments = !1;
  }
  printSequence(t, r, i = {}) {
    var s;
    i.statement = !0, (s = i.indent) != null || (i.indent = !1), this.printJoin(t, r, i);
  }
  printList(t, r, i = {}) {
    i.separator == null && (i.separator = CB), this.printJoin(t, r, i);
  }
  _printNewline(t, r) {
    const i = this.format;
    if (i.retainLines || i.compact)
      return;
    if (i.concise) {
      this.space();
      return;
    }
    if (!t)
      return;
    const s = r.nextNodeStartLine, n = this._lastCommentLine;
    if (s > 0 && n > 0) {
      const a = s - n;
      if (a >= 0) {
        this.newline(a || 1);
        return;
      }
    }
    this._buf.hasContent() && this.newline(1);
  }
  _shouldPrintComment(t) {
    return t.ignore || this._printedComments.has(t) ? 0 : this._noLineTerminator && (zl.test(t.value) || xB.test(t.value)) ? 2 : (this._printedComments.add(t), this.format.shouldPrintComment(t.value) ? 1 : 0);
  }
  _printComment(t, r) {
    const i = this._noLineTerminator, s = t.type === "CommentBlock", n = s && r !== 1 && !this._noLineTerminator;
    n && this._buf.hasContent() && r !== 2 && this.newline(1);
    const a = this.getLastChar();
    a !== 91 && a !== 123 && this.space();
    let o;
    if (s) {
      if (o = `/*${t.value}*/`, this.format.indent.adjustMultilineComment) {
        var l;
        const u = (l = t.loc) == null ? void 0 : l.start.column;
        if (u) {
          const p = new RegExp("\\n\\s{1," + u + "}", "g");
          o = o.replace(p, `
`);
        }
        let c = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
        (this._shouldIndent(47) || this.format.retainLines) && (c += this._getIndent()), o = o.replace(/\n(?!$)/g, `
${" ".repeat(c)}`);
      }
    } else
      i ? o = `/*${t.value}*/` : o = `//${t.value}`;
    this.endsWith(47) && this._space(), this.source("start", t.loc), this._append(o, s), !s && !i && this.newline(1, !0), n && r !== 3 && this.newline(1);
  }
  _printComments(t, r, i, s, n = 0) {
    const a = i.loc, o = r.length;
    let l = !!a;
    const u = l ? a.start.line : 0, c = l ? a.end.line : 0;
    let p = 0, h = 0;
    const y = this._noLineTerminator ? function() {
    } : this.newline.bind(this);
    for (let P = 0; P < o; P++) {
      const v = r[P], w = this._shouldPrintComment(v);
      if (w === 2) {
        l = !1;
        break;
      }
      if (l && v.loc && w === 1) {
        const x = v.loc.start.line, O = v.loc.end.line;
        if (t === 0) {
          let _ = 0;
          P === 0 ? this._buf.hasContent() && (v.type === "CommentLine" || x != O) && (_ = h = 1) : _ = x - p, p = O, y(_), this._printComment(v, 1), P + 1 === o && (y(Math.max(u - p, h)), p = u);
        } else if (t === 1) {
          const _ = x - (P === 0 ? u : p);
          p = O, y(_), this._printComment(v, 1), P + 1 === o && (y(Math.min(1, c - p)), p = c);
        } else {
          const _ = x - (P === 0 ? c - n : p);
          p = O, y(_), this._printComment(v, 1);
        }
      } else {
        if (l = !1, w !== 1)
          continue;
        if (o === 1) {
          const x = v.loc ? v.loc.start.line === v.loc.end.line : !zl.test(v.value), O = x && !mB(i) && !yB(s) && !TB(s) && !SB(s);
          t === 0 ? this._printComment(v, O && i.type !== "ObjectExpression" || x && dB(s, {
            body: i
          }) ? 1 : 0) : O && t === 2 ? this._printComment(v, 1) : this._printComment(v, 0);
        } else
          t === 1 && !(i.type === "ObjectExpression" && i.properties.length > 1) && i.type !== "ClassBody" && i.type !== "TSInterfaceBody" ? this._printComment(v, P === 0 ? 2 : P === o - 1 ? 3 : 0) : this._printComment(v, 0);
      }
    }
    t === 2 && l && p && (this._lastCommentLine = p);
  }
}
Object.assign(io.prototype, hB);
io.prototype.Noop = function() {
};
var AB = io;
Us.default = AB;
function CB() {
  this.tokenChar(44), this.space();
}
Object.defineProperty(Ti, "__esModule", {
  value: !0
});
Ti.CodeGenerator = void 0;
Ti.default = _B;
var IB = $s, wB = Us;
class kf extends wB.default {
  constructor(t, r = {}, i) {
    const s = OB(i, r), n = r.sourceMaps ? new IB.default(r, i) : null;
    super(s, n), this.ast = void 0, this.ast = t;
  }
  generate() {
    return super.generate(this.ast);
  }
}
function OB(e, t) {
  var r;
  const i = {
    auxiliaryCommentBefore: t.auxiliaryCommentBefore,
    auxiliaryCommentAfter: t.auxiliaryCommentAfter,
    shouldPrintComment: t.shouldPrintComment,
    retainLines: t.retainLines,
    retainFunctionParens: t.retainFunctionParens,
    comments: t.comments == null || t.comments,
    compact: t.compact,
    minified: t.minified,
    concise: t.concise,
    indent: {
      adjustMultilineComment: !0,
      style: "  "
    },
    jsescOption: Object.assign({
      quotes: "double",
      wrap: !0,
      minimal: !1
    }, t.jsescOption),
    recordAndTupleSyntaxType: (r = t.recordAndTupleSyntaxType) != null ? r : "hash",
    topicToken: t.topicToken,
    importAttributesKeyword: t.importAttributesKeyword
  };
  i.decoratorsBeforeExport = t.decoratorsBeforeExport, i.jsescOption.json = t.jsonCompatibleStrings, i.minified ? (i.compact = !0, i.shouldPrintComment = i.shouldPrintComment || (() => i.comments)) : i.shouldPrintComment = i.shouldPrintComment || ((o) => i.comments || o.includes("@license") || o.includes("@preserve")), i.compact === "auto" && (i.compact = typeof e == "string" && e.length > 5e5, i.compact && console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${t.filename} as it exceeds the max of 500KB.`)), i.compact && (i.indent.adjustMultilineComment = !1);
  const {
    auxiliaryCommentBefore: s,
    auxiliaryCommentAfter: n,
    shouldPrintComment: a
  } = i;
  return s && !a(s) && (i.auxiliaryCommentBefore = void 0), n && !a(n) && (i.auxiliaryCommentAfter = void 0), i;
}
class NB {
  constructor(t, r, i) {
    this._generator = void 0, this._generator = new kf(t, r, i);
  }
  generate() {
    return this._generator.generate();
  }
}
Ti.CodeGenerator = NB;
function _B(e, t, r) {
  return new kf(e, t, r).generate();
}
var yt = {};
Object.defineProperty(yt, "__esModule", {
  value: !0
});
yt.find = MB;
yt.findParent = LB;
yt.getAncestry = $B;
yt.getDeepestCommonAncestorFrom = RB;
yt.getEarliestCommonAncestorFrom = jB;
yt.getFunctionParent = BB;
yt.getStatementParent = FB;
yt.inType = KB;
yt.isAncestor = UB;
yt.isDescendant = VB;
var DB = Ae();
const {
  VISITOR_KEYS: kB
} = DB;
function LB(e) {
  let t = this;
  for (; t = t.parentPath; )
    if (e(t))
      return t;
  return null;
}
function MB(e) {
  let t = this;
  do
    if (e(t))
      return t;
  while (t = t.parentPath);
  return null;
}
function BB() {
  return this.findParent((e) => e.isFunction());
}
function FB() {
  let e = this;
  do {
    if (!e.parentPath || Array.isArray(e.container) && e.isStatement())
      break;
    e = e.parentPath;
  } while (e);
  if (e && (e.isProgram() || e.isFile()))
    throw new Error("File/Program node, we can't possibly find a statement parent to this");
  return e;
}
function jB(e) {
  return this.getDeepestCommonAncestorFrom(e, function(t, r, i) {
    let s;
    const n = kB[t.type];
    for (const a of i) {
      const o = a[r + 1];
      if (!s) {
        s = o;
        continue;
      }
      if (o.listKey && s.listKey === o.listKey && o.key < s.key) {
        s = o;
        continue;
      }
      const l = n.indexOf(s.parentKey), u = n.indexOf(o.parentKey);
      l > u && (s = o);
    }
    return s;
  });
}
function RB(e, t) {
  if (!e.length)
    return this;
  if (e.length === 1)
    return e[0];
  let r = 1 / 0, i, s;
  const n = e.map((o) => {
    const l = [];
    do
      l.unshift(o);
    while ((o = o.parentPath) && o !== this);
    return l.length < r && (r = l.length), l;
  }), a = n[0];
  e:
    for (let o = 0; o < r; o++) {
      const l = a[o];
      for (const u of n)
        if (u[o] !== l)
          break e;
      i = o, s = l;
    }
  if (s)
    return t ? t(s, i, n) : s;
  throw new Error("Couldn't find intersection");
}
function $B() {
  let e = this;
  const t = [];
  do
    t.push(e);
  while (e = e.parentPath);
  return t;
}
function UB(e) {
  return e.isDescendant(this);
}
function VB(e) {
  return !!this.findParent((t) => t === e);
}
function KB(...e) {
  let t = this;
  for (; t; ) {
    for (const r of e)
      if (t.node.type === r)
        return !0;
    t = t.parentPath;
  }
  return !1;
}
var Zt = {}, Lf = {}, so = {}, Xs = {};
Object.defineProperty(Xs, "__esModule", {
  value: !0
});
Xs.createUnionType = XB;
var qB = Ae();
const {
  createFlowUnionType: Ql,
  createTSUnionType: Zl,
  createUnionTypeAnnotation: WB,
  isFlowType: YB,
  isTSType: a4
} = qB;
function XB(e) {
  {
    if (YB(e[0]))
      return Ql ? Ql(e) : WB(e);
    if (Zl)
      return Zl(e);
  }
}
Object.defineProperty(so, "__esModule", {
  value: !0
});
so.default = QB;
var JB = Ae(), Mf = Xs;
const {
  BOOLEAN_NUMBER_BINARY_OPERATORS: HB,
  createTypeAnnotationBasedOnTypeof: GB,
  numberTypeAnnotation: Bf,
  voidTypeAnnotation: zB
} = JB;
function QB(e) {
  if (!this.isReferenced())
    return;
  const t = this.scope.getBinding(e.name);
  if (t)
    return t.identifier.typeAnnotation ? t.identifier.typeAnnotation : ZB(t, this, e.name);
  if (e.name === "undefined")
    return zB();
  if (e.name === "NaN" || e.name === "Infinity")
    return Bf();
  e.name;
}
function ZB(e, t, r) {
  const i = [], s = [];
  let n = eu(e, t, s);
  const a = Ff(e, t, r);
  if (a) {
    const o = eu(e, a.ifStatement);
    n = n.filter((l) => o.indexOf(l) < 0), i.push(a.typeAnnotation);
  }
  if (n.length) {
    n.push(...s);
    for (const o of n)
      i.push(o.getTypeAnnotation());
  }
  if (i.length)
    return (0, Mf.createUnionType)(i);
}
function eu(e, t, r) {
  const i = e.constantViolations.slice();
  return i.unshift(e.path), i.filter((s) => {
    s = s.resolve();
    const n = s._guessExecutionStatusRelativeTo(t);
    return r && n === "unknown" && r.push(s), n === "before";
  });
}
function eF(e, t) {
  const r = t.node.operator, i = t.get("right").resolve(), s = t.get("left").resolve();
  let n;
  if (s.isIdentifier({
    name: e
  }) ? n = i : i.isIdentifier({
    name: e
  }) && (n = s), n)
    return r === "===" ? n.getTypeAnnotation() : HB.indexOf(r) >= 0 ? Bf() : void 0;
  if (r !== "===" && r !== "==")
    return;
  let a, o;
  if (s.isUnaryExpression({
    operator: "typeof"
  }) ? (a = s, o = i) : i.isUnaryExpression({
    operator: "typeof"
  }) && (a = i, o = s), !a || !a.get("argument").isIdentifier({
    name: e
  }) || (o = o.resolve(), !o.isLiteral()))
    return;
  const l = o.node.value;
  if (typeof l == "string")
    return GB(l);
}
function tF(e, t, r) {
  let i;
  for (; i = t.parentPath; ) {
    if (i.isIfStatement() || i.isConditionalExpression())
      return t.key === "test" ? void 0 : i;
    if (i.isFunction() && i.parentPath.scope.getBinding(r) !== e)
      return;
    t = i;
  }
}
function Ff(e, t, r) {
  const i = tF(e, t, r);
  if (!i)
    return;
  const n = [i.get("test")], a = [];
  for (let o = 0; o < n.length; o++) {
    const l = n[o];
    if (l.isLogicalExpression())
      l.node.operator === "&&" && (n.push(l.get("left")), n.push(l.get("right")));
    else if (l.isBinaryExpression()) {
      const u = eF(r, l);
      u && a.push(u);
    }
  }
  return a.length ? {
    typeAnnotation: (0, Mf.createUnionType)(a),
    ifStatement: i
  } : Ff(e, i, r);
}
(function(e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), e.ArrayExpression = Je, e.AssignmentExpression = j, e.BinaryExpression = ce, e.BooleanLiteral = ie, e.CallExpression = Se, e.ConditionalExpression = k, e.ClassDeclaration = e.ClassExpression = e.FunctionDeclaration = e.ArrowFunctionExpression = e.FunctionExpression = We, Object.defineProperty(e, "Identifier", {
    enumerable: !0,
    get: function() {
      return r.default;
    }
  }), e.LogicalExpression = me, e.NewExpression = te, e.NullLiteral = ge, e.NumericLiteral = ae, e.ObjectExpression = je, e.ParenthesizedExpression = D, e.RegExpLiteral = Ce, e.RestElement = He, e.SequenceExpression = M, e.StringLiteral = W, e.TSAsExpression = L, e.TSNonNullExpression = F, e.TaggedTemplateExpression = oe, e.TemplateLiteral = Z, e.TypeCastExpression = C, e.UnaryExpression = J, e.UpdateExpression = X, e.VariableDeclarator = B;
  var t = Ae(), r = so, i = Xs;
  const {
    BOOLEAN_BINARY_OPERATORS: s,
    BOOLEAN_UNARY_OPERATORS: n,
    NUMBER_BINARY_OPERATORS: a,
    NUMBER_UNARY_OPERATORS: o,
    STRING_UNARY_OPERATORS: l,
    anyTypeAnnotation: u,
    arrayTypeAnnotation: c,
    booleanTypeAnnotation: p,
    buildMatchMemberExpression: h,
    genericTypeAnnotation: y,
    identifier: P,
    nullLiteralTypeAnnotation: v,
    numberTypeAnnotation: w,
    stringTypeAnnotation: x,
    tupleTypeAnnotation: O,
    unionTypeAnnotation: _,
    voidTypeAnnotation: K,
    isIdentifier: R
  } = t;
  function B() {
    if (this.get("id").isIdentifier())
      return this.get("init").getTypeAnnotation();
  }
  function C(Q) {
    return Q.typeAnnotation;
  }
  C.validParent = !0;
  function L(Q) {
    return Q.typeAnnotation;
  }
  L.validParent = !0;
  function F() {
    return this.get("expression").getTypeAnnotation();
  }
  function te(Q) {
    if (Q.callee.type === "Identifier")
      return y(Q.callee);
  }
  function Z() {
    return x();
  }
  function J(Q) {
    const pe = Q.operator;
    if (pe === "void")
      return K();
    if (o.indexOf(pe) >= 0)
      return w();
    if (l.indexOf(pe) >= 0)
      return x();
    if (n.indexOf(pe) >= 0)
      return p();
  }
  function ce(Q) {
    const pe = Q.operator;
    if (a.indexOf(pe) >= 0)
      return w();
    if (s.indexOf(pe) >= 0)
      return p();
    if (pe === "+") {
      const ve = this.get("right"), De = this.get("left");
      return De.isBaseType("number") && ve.isBaseType("number") ? w() : De.isBaseType("string") || ve.isBaseType("string") ? x() : _([x(), w()]);
    }
  }
  function me() {
    const Q = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
    return (0, i.createUnionType)(Q);
  }
  function k() {
    const Q = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
    return (0, i.createUnionType)(Q);
  }
  function M() {
    return this.get("expressions").pop().getTypeAnnotation();
  }
  function D() {
    return this.get("expression").getTypeAnnotation();
  }
  function j() {
    return this.get("right").getTypeAnnotation();
  }
  function X(Q) {
    const pe = Q.operator;
    if (pe === "++" || pe === "--")
      return w();
  }
  function W() {
    return x();
  }
  function ae() {
    return w();
  }
  function ie() {
    return p();
  }
  function ge() {
    return v();
  }
  function Ce() {
    return y(P("RegExp"));
  }
  function je() {
    return y(P("Object"));
  }
  function Je() {
    return y(P("Array"));
  }
  function He() {
    return Je();
  }
  He.validParent = !0;
  function We() {
    return y(P("Function"));
  }
  const Y = h("Array.from"), V = h("Object.keys"), z = h("Object.values"), ee = h("Object.entries");
  function Se() {
    const {
      callee: Q
    } = this.node;
    return V(Q) ? c(x()) : Y(Q) || z(Q) || R(Q, {
      name: "Array"
    }) ? c(u()) : ee(Q) ? c(O([x(), u()])) : ye(this.get("callee"));
  }
  function oe() {
    return ye(this.get("tag"));
  }
  function ye(Q) {
    if (Q = Q.resolve(), Q.isFunction()) {
      const {
        node: pe
      } = Q;
      if (pe.async)
        return pe.generator ? y(P("AsyncIterator")) : y(P("Promise"));
      if (pe.generator)
        return y(P("Iterator"));
      if (Q.node.returnType)
        return Q.node.returnType;
    }
  }
})(Lf);
Object.defineProperty(Zt, "__esModule", {
  value: !0
});
Zt._getTypeAnnotation = EF;
Zt.baseTypeStrictlyMatches = vF;
Zt.couldBeBaseType = xF;
Zt.getTypeAnnotation = gF;
Zt.isBaseType = PF;
Zt.isGenericType = AF;
var tu = Lf, rF = Ae();
const {
  anyTypeAnnotation: jf,
  isAnyTypeAnnotation: ys,
  isArrayTypeAnnotation: iF,
  isBooleanTypeAnnotation: sF,
  isEmptyTypeAnnotation: nF,
  isFlowBaseAnnotation: aF,
  isGenericTypeAnnotation: oF,
  isIdentifier: ru,
  isMixedTypeAnnotation: lF,
  isNumberTypeAnnotation: uF,
  isStringTypeAnnotation: cF,
  isTSArrayType: fF,
  isTSTypeAnnotation: pF,
  isTSTypeReference: hF,
  isTupleTypeAnnotation: dF,
  isTypeAnnotation: mF,
  isUnionTypeAnnotation: yF,
  isVoidTypeAnnotation: TF,
  stringTypeAnnotation: SF,
  voidTypeAnnotation: bF
} = rF;
function gF() {
  let e = this.getData("typeAnnotation");
  return e != null || (e = this._getTypeAnnotation() || jf(), (mF(e) || pF(e)) && (e = e.typeAnnotation), this.setData("typeAnnotation", e)), e;
}
const xn = /* @__PURE__ */ new WeakSet();
function EF() {
  const e = this.node;
  if (!e)
    if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
      const r = this.parentPath.parentPath, i = r.parentPath;
      return r.key === "left" && i.isForInStatement() ? SF() : r.key === "left" && i.isForOfStatement() ? jf() : bF();
    } else
      return;
  if (e.typeAnnotation)
    return e.typeAnnotation;
  if (!xn.has(e)) {
    xn.add(e);
    try {
      var t;
      let r = tu[e.type];
      if (r)
        return r.call(this, e);
      if (r = tu[this.parentPath.type], (t = r) != null && t.validParent)
        return this.parentPath.getTypeAnnotation();
    } finally {
      xn.delete(e);
    }
  }
}
function PF(e, t) {
  return Yn(e, this.getTypeAnnotation(), t);
}
function Yn(e, t, r) {
  if (e === "string")
    return cF(t);
  if (e === "number")
    return uF(t);
  if (e === "boolean")
    return sF(t);
  if (e === "any")
    return ys(t);
  if (e === "mixed")
    return lF(t);
  if (e === "empty")
    return nF(t);
  if (e === "void")
    return TF(t);
  if (r)
    return !1;
  throw new Error(`Unknown base type ${e}`);
}
function xF(e) {
  const t = this.getTypeAnnotation();
  if (ys(t))
    return !0;
  if (yF(t)) {
    for (const r of t.types)
      if (ys(r) || Yn(e, r, !0))
        return !0;
    return !1;
  } else
    return Yn(e, t, !0);
}
function vF(e) {
  const t = this.getTypeAnnotation(), r = e.getTypeAnnotation();
  return !ys(t) && aF(t) ? r.type === t.type : !1;
}
function AF(e) {
  const t = this.getTypeAnnotation();
  return e === "Array" && (fF(t) || iF(t) || dF(t)) ? !0 : oF(t) && ru(t.id, {
    name: e
  }) || hF(t) && ru(t.typeName, {
    name: e
  });
}
var It = {}, Pi = {}, xi = {}, Js = {};
Object.defineProperty(Js, "__esModule", {
  value: !0
});
Js.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
Js.matchToToken = function(e) {
  var t = { type: "invalid", value: e[0], closed: void 0 };
  return e[1] ? (t.type = "string", t.closed = !!(e[3] || e[4])) : e[5] ? t.type = "comment" : e[6] ? (t.type = "comment", t.closed = !!e[7]) : e[8] ? t.type = "regex" : e[9] ? t.type = "number" : e[10] ? t.type = "name" : e[11] ? t.type = "punctuator" : e[12] && (t.type = "whitespace"), t;
};
var Rf = { exports: {} }, CF = /[|\\{}()[\]^$+*?.]/g, IF = function(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(CF, "\\$&");
}, no = { exports: {} }, $f = { exports: {} }, wF = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
}, cr = wF, Uf = {};
for (var vn in cr)
  cr.hasOwnProperty(vn) && (Uf[cr[vn]] = vn);
var fe = $f.exports = {
  rgb: { channels: 3, labels: "rgb" },
  hsl: { channels: 3, labels: "hsl" },
  hsv: { channels: 3, labels: "hsv" },
  hwb: { channels: 3, labels: "hwb" },
  cmyk: { channels: 4, labels: "cmyk" },
  xyz: { channels: 3, labels: "xyz" },
  lab: { channels: 3, labels: "lab" },
  lch: { channels: 3, labels: "lch" },
  hex: { channels: 1, labels: ["hex"] },
  keyword: { channels: 1, labels: ["keyword"] },
  ansi16: { channels: 1, labels: ["ansi16"] },
  ansi256: { channels: 1, labels: ["ansi256"] },
  hcg: { channels: 3, labels: ["h", "c", "g"] },
  apple: { channels: 3, labels: ["r16", "g16", "b16"] },
  gray: { channels: 1, labels: ["gray"] }
};
for (var lt in fe)
  if (fe.hasOwnProperty(lt)) {
    if (!("channels" in fe[lt]))
      throw new Error("missing channels property: " + lt);
    if (!("labels" in fe[lt]))
      throw new Error("missing channel labels property: " + lt);
    if (fe[lt].labels.length !== fe[lt].channels)
      throw new Error("channel and label counts mismatch: " + lt);
    var OF = fe[lt].channels, NF = fe[lt].labels;
    delete fe[lt].channels, delete fe[lt].labels, Object.defineProperty(fe[lt], "channels", { value: OF }), Object.defineProperty(fe[lt], "labels", { value: NF });
  }
fe.rgb.hsl = function(e) {
  var t = e[0] / 255, r = e[1] / 255, i = e[2] / 255, s = Math.min(t, r, i), n = Math.max(t, r, i), a = n - s, o, l, u;
  return n === s ? o = 0 : t === n ? o = (r - i) / a : r === n ? o = 2 + (i - t) / a : i === n && (o = 4 + (t - r) / a), o = Math.min(o * 60, 360), o < 0 && (o += 360), u = (s + n) / 2, n === s ? l = 0 : u <= 0.5 ? l = a / (n + s) : l = a / (2 - n - s), [o, l * 100, u * 100];
};
fe.rgb.hsv = function(e) {
  var t, r, i, s, n, a = e[0] / 255, o = e[1] / 255, l = e[2] / 255, u = Math.max(a, o, l), c = u - Math.min(a, o, l), p = function(h) {
    return (u - h) / 6 / c + 1 / 2;
  };
  return c === 0 ? s = n = 0 : (n = c / u, t = p(a), r = p(o), i = p(l), a === u ? s = i - r : o === u ? s = 1 / 3 + t - i : l === u && (s = 2 / 3 + r - t), s < 0 ? s += 1 : s > 1 && (s -= 1)), [
    s * 360,
    n * 100,
    u * 100
  ];
};
fe.rgb.hwb = function(e) {
  var t = e[0], r = e[1], i = e[2], s = fe.rgb.hsl(e)[0], n = 1 / 255 * Math.min(t, Math.min(r, i));
  return i = 1 - 1 / 255 * Math.max(t, Math.max(r, i)), [s, n * 100, i * 100];
};
fe.rgb.cmyk = function(e) {
  var t = e[0] / 255, r = e[1] / 255, i = e[2] / 255, s, n, a, o;
  return o = Math.min(1 - t, 1 - r, 1 - i), s = (1 - t - o) / (1 - o) || 0, n = (1 - r - o) / (1 - o) || 0, a = (1 - i - o) / (1 - o) || 0, [s * 100, n * 100, a * 100, o * 100];
};
function _F(e, t) {
  return Math.pow(e[0] - t[0], 2) + Math.pow(e[1] - t[1], 2) + Math.pow(e[2] - t[2], 2);
}
fe.rgb.keyword = function(e) {
  var t = Uf[e];
  if (t)
    return t;
  var r = 1 / 0, i;
  for (var s in cr)
    if (cr.hasOwnProperty(s)) {
      var n = cr[s], a = _F(e, n);
      a < r && (r = a, i = s);
    }
  return i;
};
fe.keyword.rgb = function(e) {
  return cr[e];
};
fe.rgb.xyz = function(e) {
  var t = e[0] / 255, r = e[1] / 255, i = e[2] / 255;
  t = t > 0.04045 ? Math.pow((t + 0.055) / 1.055, 2.4) : t / 12.92, r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92, i = i > 0.04045 ? Math.pow((i + 0.055) / 1.055, 2.4) : i / 12.92;
  var s = t * 0.4124 + r * 0.3576 + i * 0.1805, n = t * 0.2126 + r * 0.7152 + i * 0.0722, a = t * 0.0193 + r * 0.1192 + i * 0.9505;
  return [s * 100, n * 100, a * 100];
};
fe.rgb.lab = function(e) {
  var t = fe.rgb.xyz(e), r = t[0], i = t[1], s = t[2], n, a, o;
  return r /= 95.047, i /= 100, s /= 108.883, r = r > 8856e-6 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116, i = i > 8856e-6 ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116, s = s > 8856e-6 ? Math.pow(s, 1 / 3) : 7.787 * s + 16 / 116, n = 116 * i - 16, a = 500 * (r - i), o = 200 * (i - s), [n, a, o];
};
fe.hsl.rgb = function(e) {
  var t = e[0] / 360, r = e[1] / 100, i = e[2] / 100, s, n, a, o, l;
  if (r === 0)
    return l = i * 255, [l, l, l];
  i < 0.5 ? n = i * (1 + r) : n = i + r - i * r, s = 2 * i - n, o = [0, 0, 0];
  for (var u = 0; u < 3; u++)
    a = t + 1 / 3 * -(u - 1), a < 0 && a++, a > 1 && a--, 6 * a < 1 ? l = s + (n - s) * 6 * a : 2 * a < 1 ? l = n : 3 * a < 2 ? l = s + (n - s) * (2 / 3 - a) * 6 : l = s, o[u] = l * 255;
  return o;
};
fe.hsl.hsv = function(e) {
  var t = e[0], r = e[1] / 100, i = e[2] / 100, s = r, n = Math.max(i, 0.01), a, o;
  return i *= 2, r *= i <= 1 ? i : 2 - i, s *= n <= 1 ? n : 2 - n, o = (i + r) / 2, a = i === 0 ? 2 * s / (n + s) : 2 * r / (i + r), [t, a * 100, o * 100];
};
fe.hsv.rgb = function(e) {
  var t = e[0] / 60, r = e[1] / 100, i = e[2] / 100, s = Math.floor(t) % 6, n = t - Math.floor(t), a = 255 * i * (1 - r), o = 255 * i * (1 - r * n), l = 255 * i * (1 - r * (1 - n));
  switch (i *= 255, s) {
    case 0:
      return [i, l, a];
    case 1:
      return [o, i, a];
    case 2:
      return [a, i, l];
    case 3:
      return [a, o, i];
    case 4:
      return [l, a, i];
    case 5:
      return [i, a, o];
  }
};
fe.hsv.hsl = function(e) {
  var t = e[0], r = e[1] / 100, i = e[2] / 100, s = Math.max(i, 0.01), n, a, o;
  return o = (2 - r) * i, n = (2 - r) * s, a = r * s, a /= n <= 1 ? n : 2 - n, a = a || 0, o /= 2, [t, a * 100, o * 100];
};
fe.hwb.rgb = function(e) {
  var t = e[0] / 360, r = e[1] / 100, i = e[2] / 100, s = r + i, n, a, o, l;
  s > 1 && (r /= s, i /= s), n = Math.floor(6 * t), a = 1 - i, o = 6 * t - n, n & 1 && (o = 1 - o), l = r + o * (a - r);
  var u, c, p;
  switch (n) {
    default:
    case 6:
    case 0:
      u = a, c = l, p = r;
      break;
    case 1:
      u = l, c = a, p = r;
      break;
    case 2:
      u = r, c = a, p = l;
      break;
    case 3:
      u = r, c = l, p = a;
      break;
    case 4:
      u = l, c = r, p = a;
      break;
    case 5:
      u = a, c = r, p = l;
      break;
  }
  return [u * 255, c * 255, p * 255];
};
fe.cmyk.rgb = function(e) {
  var t = e[0] / 100, r = e[1] / 100, i = e[2] / 100, s = e[3] / 100, n, a, o;
  return n = 1 - Math.min(1, t * (1 - s) + s), a = 1 - Math.min(1, r * (1 - s) + s), o = 1 - Math.min(1, i * (1 - s) + s), [n * 255, a * 255, o * 255];
};
fe.xyz.rgb = function(e) {
  var t = e[0] / 100, r = e[1] / 100, i = e[2] / 100, s, n, a;
  return s = t * 3.2406 + r * -1.5372 + i * -0.4986, n = t * -0.9689 + r * 1.8758 + i * 0.0415, a = t * 0.0557 + r * -0.204 + i * 1.057, s = s > 31308e-7 ? 1.055 * Math.pow(s, 1 / 2.4) - 0.055 : s * 12.92, n = n > 31308e-7 ? 1.055 * Math.pow(n, 1 / 2.4) - 0.055 : n * 12.92, a = a > 31308e-7 ? 1.055 * Math.pow(a, 1 / 2.4) - 0.055 : a * 12.92, s = Math.min(Math.max(0, s), 1), n = Math.min(Math.max(0, n), 1), a = Math.min(Math.max(0, a), 1), [s * 255, n * 255, a * 255];
};
fe.xyz.lab = function(e) {
  var t = e[0], r = e[1], i = e[2], s, n, a;
  return t /= 95.047, r /= 100, i /= 108.883, t = t > 8856e-6 ? Math.pow(t, 1 / 3) : 7.787 * t + 16 / 116, r = r > 8856e-6 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116, i = i > 8856e-6 ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116, s = 116 * r - 16, n = 500 * (t - r), a = 200 * (r - i), [s, n, a];
};
fe.lab.xyz = function(e) {
  var t = e[0], r = e[1], i = e[2], s, n, a;
  n = (t + 16) / 116, s = r / 500 + n, a = n - i / 200;
  var o = Math.pow(n, 3), l = Math.pow(s, 3), u = Math.pow(a, 3);
  return n = o > 8856e-6 ? o : (n - 16 / 116) / 7.787, s = l > 8856e-6 ? l : (s - 16 / 116) / 7.787, a = u > 8856e-6 ? u : (a - 16 / 116) / 7.787, s *= 95.047, n *= 100, a *= 108.883, [s, n, a];
};
fe.lab.lch = function(e) {
  var t = e[0], r = e[1], i = e[2], s, n, a;
  return s = Math.atan2(i, r), n = s * 360 / 2 / Math.PI, n < 0 && (n += 360), a = Math.sqrt(r * r + i * i), [t, a, n];
};
fe.lch.lab = function(e) {
  var t = e[0], r = e[1], i = e[2], s, n, a;
  return a = i / 360 * 2 * Math.PI, s = r * Math.cos(a), n = r * Math.sin(a), [t, s, n];
};
fe.rgb.ansi16 = function(e) {
  var t = e[0], r = e[1], i = e[2], s = 1 in arguments ? arguments[1] : fe.rgb.hsv(e)[2];
  if (s = Math.round(s / 50), s === 0)
    return 30;
  var n = 30 + (Math.round(i / 255) << 2 | Math.round(r / 255) << 1 | Math.round(t / 255));
  return s === 2 && (n += 60), n;
};
fe.hsv.ansi16 = function(e) {
  return fe.rgb.ansi16(fe.hsv.rgb(e), e[2]);
};
fe.rgb.ansi256 = function(e) {
  var t = e[0], r = e[1], i = e[2];
  if (t === r && r === i)
    return t < 8 ? 16 : t > 248 ? 231 : Math.round((t - 8) / 247 * 24) + 232;
  var s = 16 + 36 * Math.round(t / 255 * 5) + 6 * Math.round(r / 255 * 5) + Math.round(i / 255 * 5);
  return s;
};
fe.ansi16.rgb = function(e) {
  var t = e % 10;
  if (t === 0 || t === 7)
    return e > 50 && (t += 3.5), t = t / 10.5 * 255, [t, t, t];
  var r = (~~(e > 50) + 1) * 0.5, i = (t & 1) * r * 255, s = (t >> 1 & 1) * r * 255, n = (t >> 2 & 1) * r * 255;
  return [i, s, n];
};
fe.ansi256.rgb = function(e) {
  if (e >= 232) {
    var t = (e - 232) * 10 + 8;
    return [t, t, t];
  }
  e -= 16;
  var r, i = Math.floor(e / 36) / 5 * 255, s = Math.floor((r = e % 36) / 6) / 5 * 255, n = r % 6 / 5 * 255;
  return [i, s, n];
};
fe.rgb.hex = function(e) {
  var t = ((Math.round(e[0]) & 255) << 16) + ((Math.round(e[1]) & 255) << 8) + (Math.round(e[2]) & 255), r = t.toString(16).toUpperCase();
  return "000000".substring(r.length) + r;
};
fe.hex.rgb = function(e) {
  var t = e.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
  if (!t)
    return [0, 0, 0];
  var r = t[0];
  t[0].length === 3 && (r = r.split("").map(function(o) {
    return o + o;
  }).join(""));
  var i = parseInt(r, 16), s = i >> 16 & 255, n = i >> 8 & 255, a = i & 255;
  return [s, n, a];
};
fe.rgb.hcg = function(e) {
  var t = e[0] / 255, r = e[1] / 255, i = e[2] / 255, s = Math.max(Math.max(t, r), i), n = Math.min(Math.min(t, r), i), a = s - n, o, l;
  return a < 1 ? o = n / (1 - a) : o = 0, a <= 0 ? l = 0 : s === t ? l = (r - i) / a % 6 : s === r ? l = 2 + (i - t) / a : l = 4 + (t - r) / a + 4, l /= 6, l %= 1, [l * 360, a * 100, o * 100];
};
fe.hsl.hcg = function(e) {
  var t = e[1] / 100, r = e[2] / 100, i = 1, s = 0;
  return r < 0.5 ? i = 2 * t * r : i = 2 * t * (1 - r), i < 1 && (s = (r - 0.5 * i) / (1 - i)), [e[0], i * 100, s * 100];
};
fe.hsv.hcg = function(e) {
  var t = e[1] / 100, r = e[2] / 100, i = t * r, s = 0;
  return i < 1 && (s = (r - i) / (1 - i)), [e[0], i * 100, s * 100];
};
fe.hcg.rgb = function(e) {
  var t = e[0] / 360, r = e[1] / 100, i = e[2] / 100;
  if (r === 0)
    return [i * 255, i * 255, i * 255];
  var s = [0, 0, 0], n = t % 1 * 6, a = n % 1, o = 1 - a, l = 0;
  switch (Math.floor(n)) {
    case 0:
      s[0] = 1, s[1] = a, s[2] = 0;
      break;
    case 1:
      s[0] = o, s[1] = 1, s[2] = 0;
      break;
    case 2:
      s[0] = 0, s[1] = 1, s[2] = a;
      break;
    case 3:
      s[0] = 0, s[1] = o, s[2] = 1;
      break;
    case 4:
      s[0] = a, s[1] = 0, s[2] = 1;
      break;
    default:
      s[0] = 1, s[1] = 0, s[2] = o;
  }
  return l = (1 - r) * i, [
    (r * s[0] + l) * 255,
    (r * s[1] + l) * 255,
    (r * s[2] + l) * 255
  ];
};
fe.hcg.hsv = function(e) {
  var t = e[1] / 100, r = e[2] / 100, i = t + r * (1 - t), s = 0;
  return i > 0 && (s = t / i), [e[0], s * 100, i * 100];
};
fe.hcg.hsl = function(e) {
  var t = e[1] / 100, r = e[2] / 100, i = r * (1 - t) + 0.5 * t, s = 0;
  return i > 0 && i < 0.5 ? s = t / (2 * i) : i >= 0.5 && i < 1 && (s = t / (2 * (1 - i))), [e[0], s * 100, i * 100];
};
fe.hcg.hwb = function(e) {
  var t = e[1] / 100, r = e[2] / 100, i = t + r * (1 - t);
  return [e[0], (i - t) * 100, (1 - i) * 100];
};
fe.hwb.hcg = function(e) {
  var t = e[1] / 100, r = e[2] / 100, i = 1 - r, s = i - t, n = 0;
  return s < 1 && (n = (i - s) / (1 - s)), [e[0], s * 100, n * 100];
};
fe.apple.rgb = function(e) {
  return [e[0] / 65535 * 255, e[1] / 65535 * 255, e[2] / 65535 * 255];
};
fe.rgb.apple = function(e) {
  return [e[0] / 255 * 65535, e[1] / 255 * 65535, e[2] / 255 * 65535];
};
fe.gray.rgb = function(e) {
  return [e[0] / 100 * 255, e[0] / 100 * 255, e[0] / 100 * 255];
};
fe.gray.hsl = fe.gray.hsv = function(e) {
  return [0, 0, e[0]];
};
fe.gray.hwb = function(e) {
  return [0, 100, e[0]];
};
fe.gray.cmyk = function(e) {
  return [0, 0, 0, e[0]];
};
fe.gray.lab = function(e) {
  return [e[0], 0, 0];
};
fe.gray.hex = function(e) {
  var t = Math.round(e[0] / 100 * 255) & 255, r = (t << 16) + (t << 8) + t, i = r.toString(16).toUpperCase();
  return "000000".substring(i.length) + i;
};
fe.rgb.gray = function(e) {
  var t = (e[0] + e[1] + e[2]) / 3;
  return [t / 255 * 100];
};
var Vf = $f.exports, Ts = Vf;
function DF() {
  for (var e = {}, t = Object.keys(Ts), r = t.length, i = 0; i < r; i++)
    e[t[i]] = {
      // http://jsperf.com/1-vs-infinity
      // micro-opt, but this is simple.
      distance: -1,
      parent: null
    };
  return e;
}
function kF(e) {
  var t = DF(), r = [e];
  for (t[e].distance = 0; r.length; )
    for (var i = r.pop(), s = Object.keys(Ts[i]), n = s.length, a = 0; a < n; a++) {
      var o = s[a], l = t[o];
      l.distance === -1 && (l.distance = t[i].distance + 1, l.parent = i, r.unshift(o));
    }
  return t;
}
function LF(e, t) {
  return function(r) {
    return t(e(r));
  };
}
function MF(e, t) {
  for (var r = [t[e].parent, e], i = Ts[t[e].parent][e], s = t[e].parent; t[s].parent; )
    r.unshift(t[s].parent), i = LF(Ts[t[s].parent][s], i), s = t[s].parent;
  return i.conversion = r, i;
}
var BF = function(e) {
  for (var t = kF(e), r = {}, i = Object.keys(t), s = i.length, n = 0; n < s; n++) {
    var a = i[n], o = t[a];
    o.parent !== null && (r[a] = MF(a, t));
  }
  return r;
}, Xn = Vf, FF = BF, Ar = {}, jF = Object.keys(Xn);
function RF(e) {
  var t = function(r) {
    return r == null ? r : (arguments.length > 1 && (r = Array.prototype.slice.call(arguments)), e(r));
  };
  return "conversion" in e && (t.conversion = e.conversion), t;
}
function $F(e) {
  var t = function(r) {
    if (r == null)
      return r;
    arguments.length > 1 && (r = Array.prototype.slice.call(arguments));
    var i = e(r);
    if (typeof i == "object")
      for (var s = i.length, n = 0; n < s; n++)
        i[n] = Math.round(i[n]);
    return i;
  };
  return "conversion" in e && (t.conversion = e.conversion), t;
}
jF.forEach(function(e) {
  Ar[e] = {}, Object.defineProperty(Ar[e], "channels", { value: Xn[e].channels }), Object.defineProperty(Ar[e], "labels", { value: Xn[e].labels });
  var t = FF(e), r = Object.keys(t);
  r.forEach(function(i) {
    var s = t[i];
    Ar[e][i] = $F(s), Ar[e][i].raw = RF(s);
  });
});
var UF = Ar;
no.exports;
(function(e) {
  const t = UF, r = (a, o) => function() {
    return `\x1B[${a.apply(t, arguments) + o}m`;
  }, i = (a, o) => function() {
    const l = a.apply(t, arguments);
    return `\x1B[${38 + o};5;${l}m`;
  }, s = (a, o) => function() {
    const l = a.apply(t, arguments);
    return `\x1B[${38 + o};2;${l[0]};${l[1]};${l[2]}m`;
  };
  function n() {
    const a = /* @__PURE__ */ new Map(), o = {
      modifier: {
        reset: [0, 0],
        // 21 isn't widely supported and 22 does the same thing
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        gray: [90, 39],
        // Bright color
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        // Bright color
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    o.color.grey = o.color.gray;
    for (const c of Object.keys(o)) {
      const p = o[c];
      for (const h of Object.keys(p)) {
        const y = p[h];
        o[h] = {
          open: `\x1B[${y[0]}m`,
          close: `\x1B[${y[1]}m`
        }, p[h] = o[h], a.set(y[0], y[1]);
      }
      Object.defineProperty(o, c, {
        value: p,
        enumerable: !1
      }), Object.defineProperty(o, "codes", {
        value: a,
        enumerable: !1
      });
    }
    const l = (c) => c, u = (c, p, h) => [c, p, h];
    o.color.close = "\x1B[39m", o.bgColor.close = "\x1B[49m", o.color.ansi = {
      ansi: r(l, 0)
    }, o.color.ansi256 = {
      ansi256: i(l, 0)
    }, o.color.ansi16m = {
      rgb: s(u, 0)
    }, o.bgColor.ansi = {
      ansi: r(l, 10)
    }, o.bgColor.ansi256 = {
      ansi256: i(l, 10)
    }, o.bgColor.ansi16m = {
      rgb: s(u, 10)
    };
    for (let c of Object.keys(t)) {
      if (typeof t[c] != "object")
        continue;
      const p = t[c];
      c === "ansi16" && (c = "ansi"), "ansi16" in p && (o.color.ansi[c] = r(p.ansi16, 0), o.bgColor.ansi[c] = r(p.ansi16, 10)), "ansi256" in p && (o.color.ansi256[c] = i(p.ansi256, 0), o.bgColor.ansi256[c] = i(p.ansi256, 10)), "rgb" in p && (o.color.ansi16m[c] = s(p.rgb, 0), o.bgColor.ansi16m[c] = s(p.rgb, 10));
    }
    return o;
  }
  Object.defineProperty(e, "exports", {
    enumerable: !0,
    get: n
  });
})(no);
var VF = no.exports, KF = {
  stdout: !1,
  stderr: !1
};
const qF = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, iu = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, WF = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, YF = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, XF = /* @__PURE__ */ new Map([
  ["n", `
`],
  ["r", "\r"],
  ["t", "	"],
  ["b", "\b"],
  ["f", "\f"],
  ["v", "\v"],
  ["0", "\0"],
  ["\\", "\\"],
  ["e", "\x1B"],
  ["a", "\x07"]
]);
function Kf(e) {
  return e[0] === "u" && e.length === 5 || e[0] === "x" && e.length === 3 ? String.fromCharCode(parseInt(e.slice(1), 16)) : XF.get(e) || e;
}
function JF(e, t) {
  const r = [], i = t.trim().split(/\s*,\s*/g);
  let s;
  for (const n of i)
    if (!isNaN(n))
      r.push(Number(n));
    else if (s = n.match(WF))
      r.push(s[2].replace(YF, (a, o, l) => o ? Kf(o) : l));
    else
      throw new Error(`Invalid Chalk template style argument: ${n} (in style '${e}')`);
  return r;
}
function HF(e) {
  iu.lastIndex = 0;
  const t = [];
  let r;
  for (; (r = iu.exec(e)) !== null; ) {
    const i = r[1];
    if (r[2]) {
      const s = JF(i, r[2]);
      t.push([i].concat(s));
    } else
      t.push([i]);
  }
  return t;
}
function su(e, t) {
  const r = {};
  for (const s of t)
    for (const n of s.styles)
      r[n[0]] = s.inverse ? null : n.slice(1);
  let i = e;
  for (const s of Object.keys(r))
    if (Array.isArray(r[s])) {
      if (!(s in i))
        throw new Error(`Unknown Chalk style: ${s}`);
      r[s].length > 0 ? i = i[s].apply(i, r[s]) : i = i[s];
    }
  return i;
}
var GF = (e, t) => {
  const r = [], i = [];
  let s = [];
  if (t.replace(qF, (n, a, o, l, u, c) => {
    if (a)
      s.push(Kf(a));
    else if (l) {
      const p = s.join("");
      s = [], i.push(r.length === 0 ? p : su(e, r)(p)), r.push({ inverse: o, styles: HF(l) });
    } else if (u) {
      if (r.length === 0)
        throw new Error("Found extraneous } in Chalk template literal");
      i.push(su(e, r)(s.join(""))), s = [], r.pop();
    } else
      s.push(c);
  }), i.push(s.join("")), r.length > 0) {
    const n = `Chalk template literal is missing ${r.length} closing bracket${r.length === 1 ? "" : "s"} (\`}\`)`;
    throw new Error(n);
  }
  return i.join("");
};
(function(e) {
  const t = IF, r = VF, i = KF.stdout, s = GF, n = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith("xterm"), a = ["ansi", "ansi", "ansi256", "ansi16m"], o = /* @__PURE__ */ new Set(["gray"]), l = /* @__PURE__ */ Object.create(null);
  function u(v, w) {
    w = w || {};
    const x = i ? i.level : 0;
    v.level = w.level === void 0 ? x : w.level, v.enabled = "enabled" in w ? w.enabled : v.level > 0;
  }
  function c(v) {
    if (!this || !(this instanceof c) || this.template) {
      const w = {};
      return u(w, v), w.template = function() {
        const x = [].slice.call(arguments);
        return P.apply(null, [w.template].concat(x));
      }, Object.setPrototypeOf(w, c.prototype), Object.setPrototypeOf(w.template, w), w.template.constructor = c, w.template;
    }
    u(this, v);
  }
  n && (r.blue.open = "\x1B[94m");
  for (const v of Object.keys(r))
    r[v].closeRe = new RegExp(t(r[v].close), "g"), l[v] = {
      get() {
        const w = r[v];
        return h.call(this, this._styles ? this._styles.concat(w) : [w], this._empty, v);
      }
    };
  l.visible = {
    get() {
      return h.call(this, this._styles || [], !0, "visible");
    }
  }, r.color.closeRe = new RegExp(t(r.color.close), "g");
  for (const v of Object.keys(r.color.ansi))
    o.has(v) || (l[v] = {
      get() {
        const w = this.level;
        return function() {
          const O = {
            open: r.color[a[w]][v].apply(null, arguments),
            close: r.color.close,
            closeRe: r.color.closeRe
          };
          return h.call(this, this._styles ? this._styles.concat(O) : [O], this._empty, v);
        };
      }
    });
  r.bgColor.closeRe = new RegExp(t(r.bgColor.close), "g");
  for (const v of Object.keys(r.bgColor.ansi)) {
    if (o.has(v))
      continue;
    const w = "bg" + v[0].toUpperCase() + v.slice(1);
    l[w] = {
      get() {
        const x = this.level;
        return function() {
          const _ = {
            open: r.bgColor[a[x]][v].apply(null, arguments),
            close: r.bgColor.close,
            closeRe: r.bgColor.closeRe
          };
          return h.call(this, this._styles ? this._styles.concat(_) : [_], this._empty, v);
        };
      }
    };
  }
  const p = Object.defineProperties(() => {
  }, l);
  function h(v, w, x) {
    const O = function() {
      return y.apply(O, arguments);
    };
    O._styles = v, O._empty = w;
    const _ = this;
    return Object.defineProperty(O, "level", {
      enumerable: !0,
      get() {
        return _.level;
      },
      set(K) {
        _.level = K;
      }
    }), Object.defineProperty(O, "enabled", {
      enumerable: !0,
      get() {
        return _.enabled;
      },
      set(K) {
        _.enabled = K;
      }
    }), O.hasGrey = this.hasGrey || x === "gray" || x === "grey", O.__proto__ = p, O;
  }
  function y() {
    const v = arguments, w = v.length;
    let x = String(arguments[0]);
    if (w === 0)
      return "";
    if (w > 1)
      for (let _ = 1; _ < w; _++)
        x += " " + v[_];
    if (!this.enabled || this.level <= 0 || !x)
      return this._empty ? "" : x;
    const O = r.dim.open;
    n && this.hasGrey && (r.dim.open = "");
    for (const _ of this._styles.slice().reverse())
      x = _.open + x.replace(_.closeRe, _.open) + _.close, x = x.replace(/\r?\n/g, `${_.close}$&${_.open}`);
    return r.dim.open = O, x;
  }
  function P(v, w) {
    if (!Array.isArray(w))
      return [].slice.call(arguments, 1).join(" ");
    const x = [].slice.call(arguments, 2), O = [w.raw[0]];
    for (let _ = 1; _ < w.length; _++)
      O.push(String(x[_ - 1]).replace(/[{}\\]/g, "\\$&")), O.push(String(w.raw[_]));
    return s(v, O.join(""));
  }
  Object.defineProperties(c.prototype, l), e.exports = c(), e.exports.supportsColor = i, e.exports.default = e.exports;
})(Rf);
var zF = Rf.exports;
Object.defineProperty(xi, "__esModule", {
  value: !0
});
xi.default = i3;
xi.getChalk = Yf;
xi.shouldHighlight = Wf;
var nu = Js, au = pi, Jn = zF;
const QF = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]);
function ZF(e) {
  return {
    keyword: e.cyan,
    capitalized: e.yellow,
    jsxIdentifier: e.yellow,
    punctuator: e.yellow,
    number: e.magenta,
    string: e.green,
    regex: e.magenta,
    comment: e.grey,
    invalid: e.white.bgRed.bold
  };
}
const e3 = /\r\n|[\n\r\u2028\u2029]/, t3 = /^[()[\]{}]$/;
let qf;
{
  const e = /^[a-z][\w-]*$/i, t = function(r, i, s) {
    if (r.type === "name") {
      if ((0, au.isKeyword)(r.value) || (0, au.isStrictReservedWord)(r.value, !0) || QF.has(r.value))
        return "keyword";
      if (e.test(r.value) && (s[i - 1] === "<" || s.slice(i - 2, i) == "</"))
        return "jsxIdentifier";
      if (r.value[0] !== r.value[0].toLowerCase())
        return "capitalized";
    }
    return r.type === "punctuator" && t3.test(r.value) ? "bracket" : r.type === "invalid" && (r.value === "@" || r.value === "#") ? "punctuator" : r.type;
  };
  qf = function* (r) {
    let i;
    for (; i = nu.default.exec(r); ) {
      const s = nu.matchToToken(i);
      yield {
        type: t(s, i.index, r),
        value: s.value
      };
    }
  };
}
function r3(e, t) {
  let r = "";
  for (const {
    type: i,
    value: s
  } of qf(t)) {
    const n = e[i];
    n ? r += s.split(e3).map((a) => n(a)).join(`
`) : r += s;
  }
  return r;
}
function Wf(e) {
  return !!Jn.supportsColor || e.forceColor;
}
function Yf(e) {
  return e.forceColor ? new Jn.constructor({
    enabled: !0,
    level: 1
  }) : Jn;
}
function i3(e, t = {}) {
  if (e !== "" && Wf(t)) {
    const r = Yf(t), i = ZF(r);
    return r3(i, e);
  } else
    return e;
}
Object.defineProperty(Pi, "__esModule", {
  value: !0
});
Pi.codeFrameColumns = Xf;
Pi.default = a3;
var An = xi;
let ou = !1;
function s3(e) {
  return {
    gutter: e.grey,
    marker: e.red.bold,
    message: e.red.bold
  };
}
const lu = /\r\n|[\n\r\u2028\u2029]/;
function n3(e, t, r) {
  const i = Object.assign({
    column: 0,
    line: -1
  }, e.start), s = Object.assign({}, i, e.end), {
    linesAbove: n = 2,
    linesBelow: a = 3
  } = r || {}, o = i.line, l = i.column, u = s.line, c = s.column;
  let p = Math.max(o - (n + 1), 0), h = Math.min(t.length, u + a);
  o === -1 && (p = 0), u === -1 && (h = t.length);
  const y = u - o, P = {};
  if (y)
    for (let v = 0; v <= y; v++) {
      const w = v + o;
      if (!l)
        P[w] = !0;
      else if (v === 0) {
        const x = t[w - 1].length;
        P[w] = [l, x - l + 1];
      } else if (v === y)
        P[w] = [0, c];
      else {
        const x = t[w - v].length;
        P[w] = [0, x];
      }
    }
  else
    l === c ? l ? P[o] = [l, 0] : P[o] = !0 : P[o] = [l, c - l];
  return {
    start: p,
    end: h,
    markerLines: P
  };
}
function Xf(e, t, r = {}) {
  const i = (r.highlightCode || r.forceColor) && (0, An.shouldHighlight)(r), s = (0, An.getChalk)(r), n = s3(s), a = (v, w) => i ? v(w) : w, o = e.split(lu), {
    start: l,
    end: u,
    markerLines: c
  } = n3(t, o, r), p = t.start && typeof t.start.column == "number", h = String(u).length;
  let P = (i ? (0, An.default)(e, r) : e).split(lu, u).slice(l, u).map((v, w) => {
    const x = l + 1 + w, _ = ` ${` ${x}`.slice(-h)} |`, K = c[x], R = !c[x + 1];
    if (K) {
      let B = "";
      if (Array.isArray(K)) {
        const C = v.slice(0, Math.max(K[0] - 1, 0)).replace(/[^\t]/g, " "), L = K[1] || 1;
        B = [`
 `, a(n.gutter, _.replace(/\d/g, " ")), " ", C, a(n.marker, "^").repeat(L)].join(""), R && r.message && (B += " " + a(n.message, r.message));
      }
      return [a(n.marker, ">"), a(n.gutter, _), v.length > 0 ? ` ${v}` : "", B].join("");
    } else
      return ` ${a(n.gutter, _)}${v.length > 0 ? ` ${v}` : ""}`;
  }).join(`
`);
  return r.message && !p && (P = `${" ".repeat(h + 1)}${r.message}
${P}`), i ? s.reset(P) : P;
}
function a3(e, t, r, i = {}) {
  if (!ou) {
    ou = !0;
    const n = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
    if (process.emitWarning)
      process.emitWarning(n, "DeprecationWarning");
    else {
      const a = new Error(n);
      a.name = "DeprecationWarning", console.warn(new Error(n));
    }
  }
  return r = Math.max(r, 0), Xf(e, {
    start: {
      column: r,
      line: t
    }
  }, i);
}
var ao = {};
Object.defineProperty(ao, "__esModule", {
  value: !0
});
ao.default = p3;
var o3 = Ae();
const {
  assignmentExpression: l3,
  expressionStatement: u3,
  identifier: c3
} = o3, f3 = {
  Scope(e, t) {
    t.kind === "let" && e.skip();
  },
  FunctionParent(e) {
    e.skip();
  },
  VariableDeclaration(e, t) {
    if (t.kind && e.node.kind !== t.kind)
      return;
    const r = [], i = e.get("declarations");
    let s;
    for (const n of i) {
      s = n.node.id, n.node.init && r.push(u3(l3("=", n.node.id, n.node.init)));
      for (const a of Object.keys(n.getBindingIdentifiers()))
        t.emit(c3(a), a, n.node.init !== null);
    }
    e.parentPath.isFor({
      left: e.node
    }) ? e.replaceWith(s) : e.replaceWithMultiple(r);
  }
};
function p3(e, t, r = "var") {
  e.traverse(f3, {
    kind: r,
    emit: t
  });
}
var uu;
function h3() {
  if (uu)
    return It;
  uu = 1, Object.defineProperty(It, "__esModule", {
    value: !0
  }), It._replaceWith = me, It.replaceExpressionWithStatements = k, It.replaceInline = M, It.replaceWith = ce, It.replaceWithMultiple = Z, It.replaceWithSourceString = J;
  var e = Pi, t = tn(), r = br(), i = Ze, s = pr, n = Ae(), a = ao;
  const {
    FUNCTION_TYPES: o,
    arrowFunctionExpression: l,
    assignmentExpression: u,
    awaitExpression: c,
    blockStatement: p,
    callExpression: h,
    cloneNode: y,
    expressionStatement: P,
    identifier: v,
    inheritLeadingComments: w,
    inheritTrailingComments: x,
    inheritsComments: O,
    isExpression: _,
    isProgram: K,
    isStatement: R,
    removeComments: B,
    returnStatement: C,
    toSequenceExpression: L,
    validate: F,
    yieldExpression: te
  } = n;
  function Z(D) {
    var j;
    this.resync(), D = this._verifyNodeList(D), w(D[0], this.node), x(D[D.length - 1], this.node), (j = i.path.get(this.parent)) == null || j.delete(this.node), this.node = this.container[this.key] = null;
    const X = this.insertAfter(D);
    return this.node ? this.requeue() : this.remove(), X;
  }
  function J(D) {
    this.resync();
    let j;
    try {
      D = `(${D})`, j = (0, s.parse)(D);
    } catch (W) {
      const ae = W.loc;
      throw ae && (W.message += ` - make sure this is an expression.
` + (0, e.codeFrameColumns)(D, {
        start: {
          line: ae.line,
          column: ae.column + 1
        }
      }), W.code = "BABEL_REPLACE_SOURCE_ERROR"), W;
    }
    const X = j.program.body[0].expression;
    return t.default.removeProperties(X), this.replaceWith(X);
  }
  function ce(D) {
    if (this.resync(), this.removed)
      throw new Error("You can't replace this node, we've already removed it");
    let j = D instanceof r.default ? D.node : D;
    if (!j)
      throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
    if (this.node === j)
      return [this];
    if (this.isProgram() && !K(j))
      throw new Error("You can only replace a Program root node with another Program node");
    if (Array.isArray(j))
      throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
    if (typeof j == "string")
      throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
    let X = "";
    if (this.isNodeType("Statement") && _(j) && !this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(j) && !this.parentPath.isExportDefaultDeclaration() && (j = P(j), X = "expression"), this.isNodeType("Expression") && R(j) && !this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(j))
      return this.replaceExpressionWithStatements([j]);
    const W = this.node;
    return W && (O(j, W), B(W)), this._replaceWith(j), this.type = j.type, this.setScope(), this.requeue(), [X ? this.get(X) : this];
  }
  function me(D) {
    var j;
    if (!this.container)
      throw new ReferenceError("Container is falsy");
    this.inList ? F(this.parent, this.key, [D]) : F(this.parent, this.key, D), this.debug(`Replace with ${D == null ? void 0 : D.type}`), (j = i.path.get(this.parent)) == null || j.set(D, this).delete(this.node), this.node = this.container[this.key] = D;
  }
  function k(D) {
    this.resync();
    const j = L(D, this.scope);
    if (j)
      return this.replaceWith(j)[0].get("expressions");
    const X = this.getFunctionParent(), W = X == null ? void 0 : X.is("async"), ae = X == null ? void 0 : X.is("generator"), ie = l([], p(D));
    this.replaceWith(h(ie, []));
    const ge = this.get("callee");
    (0, a.default)(ge.get("body"), (We) => {
      this.scope.push({
        id: We
      });
    }, "var");
    const Ce = this.get("callee").getCompletionRecords();
    for (const We of Ce) {
      if (!We.isExpressionStatement())
        continue;
      const Y = We.findParent((V) => V.isLoop());
      if (Y) {
        let V = Y.getData("expressionReplacementReturnUid");
        V ? V = v(V.name) : (V = ge.scope.generateDeclaredUidIdentifier("ret"), ge.get("body").pushContainer("body", C(y(V))), Y.setData("expressionReplacementReturnUid", V)), We.get("expression").replaceWith(u("=", y(V), We.node.expression));
      } else
        We.replaceWith(C(We.node.expression));
    }
    ge.arrowFunctionToExpression();
    const je = ge, Je = W && t.default.hasType(this.get("callee.body").node, "AwaitExpression", o), He = ae && t.default.hasType(this.get("callee.body").node, "YieldExpression", o);
    return Je && (je.set("async", !0), He || this.replaceWith(c(this.node))), He && (je.set("generator", !0), this.replaceWith(te(this.node, !0))), je.get("body.body");
  }
  function M(D) {
    if (this.resync(), Array.isArray(D))
      if (Array.isArray(this.container)) {
        D = this._verifyNodeList(D);
        const j = this._containerInsertAfter(D);
        return this.remove(), j;
      } else
        return this.replaceWithMultiple(D);
    else
      return this.replaceWith(D);
  }
  return It;
}
var Hs = {};
Object.defineProperty(Hs, "__esModule", {
  value: !0
});
Hs.evaluate = b3;
Hs.evaluateTruthy = T3;
const d3 = ["String", "Number", "Math"], m3 = ["random"];
function cu(e) {
  return d3.includes(e);
}
function y3(e) {
  return m3.includes(e);
}
function T3() {
  const e = this.evaluate();
  if (e.confident)
    return !!e.value;
}
function Nt(e, t) {
  t.confident && (t.deoptPath = e, t.confident = !1);
}
const fu = /* @__PURE__ */ new Map([["undefined", void 0], ["Infinity", 1 / 0], ["NaN", NaN]]);
function st(e, t) {
  const {
    node: r
  } = e, {
    seen: i
  } = t;
  if (i.has(r)) {
    const s = i.get(r);
    if (s.resolved)
      return s.value;
    Nt(e, t);
    return;
  } else {
    const s = {
      resolved: !1
    };
    i.set(r, s);
    const n = S3(e, t);
    return t.confident && (s.resolved = !0, s.value = n), n;
  }
}
function S3(e, t) {
  if (t.confident) {
    if (e.isSequenceExpression()) {
      const r = e.get("expressions");
      return st(r[r.length - 1], t);
    }
    if (e.isStringLiteral() || e.isNumericLiteral() || e.isBooleanLiteral())
      return e.node.value;
    if (e.isNullLiteral())
      return null;
    if (e.isTemplateLiteral())
      return pu(e, e.node.quasis, t);
    if (e.isTaggedTemplateExpression() && e.get("tag").isMemberExpression()) {
      const r = e.get("tag.object"), {
        node: {
          name: i
        }
      } = r, s = e.get("tag.property");
      if (r.isIdentifier() && i === "String" && !e.scope.getBinding(i) && s.isIdentifier() && s.node.name === "raw")
        return pu(e, e.node.quasi.quasis, t, !0);
    }
    if (e.isConditionalExpression()) {
      const r = st(e.get("test"), t);
      return t.confident ? st(r ? e.get("consequent") : e.get("alternate"), t) : void 0;
    }
    if (e.isExpressionWrapper())
      return st(e.get("expression"), t);
    if (e.isMemberExpression() && !e.parentPath.isCallExpression({
      callee: e.node
    })) {
      const r = e.get("property"), i = e.get("object");
      if (i.isLiteral()) {
        const s = i.node.value, n = typeof s;
        let a = null;
        if (e.node.computed) {
          if (a = st(r, t), !t.confident)
            return;
        } else
          r.isIdentifier() && (a = r.node.name);
        if ((n === "number" || n === "string") && a != null && (typeof a == "number" || typeof a == "string"))
          return s[a];
      }
    }
    if (e.isReferencedIdentifier()) {
      const r = e.scope.getBinding(e.node.name);
      if (r) {
        if (r.constantViolations.length > 0 || e.node.start < r.path.node.end) {
          Nt(r.path, t);
          return;
        }
        if (r.hasValue)
          return r.value;
      }
      const i = e.node.name;
      if (fu.has(i)) {
        if (!r)
          return fu.get(i);
        Nt(r.path, t);
        return;
      }
      const s = e.resolve();
      if (s === e) {
        Nt(e, t);
        return;
      } else
        return st(s, t);
    }
    if (e.isUnaryExpression({
      prefix: !0
    })) {
      if (e.node.operator === "void")
        return;
      const r = e.get("argument");
      if (e.node.operator === "typeof" && (r.isFunction() || r.isClass()))
        return "function";
      const i = st(r, t);
      if (!t.confident)
        return;
      switch (e.node.operator) {
        case "!":
          return !i;
        case "+":
          return +i;
        case "-":
          return -i;
        case "~":
          return ~i;
        case "typeof":
          return typeof i;
      }
    }
    if (e.isArrayExpression()) {
      const r = [], i = e.get("elements");
      for (const s of i) {
        const n = s.evaluate();
        if (n.confident)
          r.push(n.value);
        else {
          Nt(n.deopt, t);
          return;
        }
      }
      return r;
    }
    if (e.isObjectExpression()) {
      const r = {}, i = e.get("properties");
      for (const s of i) {
        if (s.isObjectMethod() || s.isSpreadElement()) {
          Nt(s, t);
          return;
        }
        const n = s.get("key");
        let a;
        if (s.node.computed) {
          if (a = n.evaluate(), !a.confident) {
            Nt(a.deopt, t);
            return;
          }
          a = a.value;
        } else
          n.isIdentifier() ? a = n.node.name : a = n.node.value;
        let l = s.get("value").evaluate();
        if (!l.confident) {
          Nt(l.deopt, t);
          return;
        }
        l = l.value, r[a] = l;
      }
      return r;
    }
    if (e.isLogicalExpression()) {
      const r = t.confident, i = st(e.get("left"), t), s = t.confident;
      t.confident = r;
      const n = st(e.get("right"), t), a = t.confident;
      switch (e.node.operator) {
        case "||":
          return t.confident = s && (!!i || a), t.confident ? i || n : void 0;
        case "&&":
          return t.confident = s && (!i || a), t.confident ? i && n : void 0;
        case "??":
          return t.confident = s && (i != null || a), t.confident ? i ?? n : void 0;
      }
    }
    if (e.isBinaryExpression()) {
      const r = st(e.get("left"), t);
      if (!t.confident)
        return;
      const i = st(e.get("right"), t);
      if (!t.confident)
        return;
      switch (e.node.operator) {
        case "-":
          return r - i;
        case "+":
          return r + i;
        case "/":
          return r / i;
        case "*":
          return r * i;
        case "%":
          return r % i;
        case "**":
          return Math.pow(r, i);
        case "<":
          return r < i;
        case ">":
          return r > i;
        case "<=":
          return r <= i;
        case ">=":
          return r >= i;
        case "==":
          return r == i;
        case "!=":
          return r != i;
        case "===":
          return r === i;
        case "!==":
          return r !== i;
        case "|":
          return r | i;
        case "&":
          return r & i;
        case "^":
          return r ^ i;
        case "<<":
          return r << i;
        case ">>":
          return r >> i;
        case ">>>":
          return r >>> i;
      }
    }
    if (e.isCallExpression()) {
      const r = e.get("callee");
      let i, s;
      if (r.isIdentifier() && !e.scope.getBinding(r.node.name) && cu(r.node.name) && (s = zt[r.node.name]), r.isMemberExpression()) {
        const n = r.get("object"), a = r.get("property");
        if (n.isIdentifier() && a.isIdentifier() && cu(n.node.name) && !y3(a.node.name) && (i = zt[n.node.name], s = i[a.node.name]), n.isLiteral() && a.isIdentifier()) {
          const o = typeof n.node.value;
          (o === "string" || o === "number") && (i = n.node.value, s = i[a.node.name]);
        }
      }
      if (s) {
        const n = e.get("arguments").map((a) => st(a, t));
        return t.confident ? s.apply(i, n) : void 0;
      }
    }
    Nt(e, t);
  }
}
function pu(e, t, r, i = !1) {
  let s = "", n = 0;
  const a = e.isTemplateLiteral() ? e.get("expressions") : e.get("quasi.expressions");
  for (const o of t) {
    if (!r.confident)
      break;
    s += i ? o.value.raw : o.value.cooked;
    const l = a[n++];
    l && (s += String(st(l, r)));
  }
  if (r.confident)
    return s;
}
function b3() {
  const e = {
    confident: !0,
    deoptPath: null,
    seen: /* @__PURE__ */ new Map()
  };
  let t = st(this, e);
  return e.confident || (t = void 0), {
    confident: e.confident,
    deopt: e.deoptPath,
    value: t
  };
}
var Tr = {}, oo = {}, ut = {}, dt = {};
Object.defineProperty(dt, "__esModule", {
  value: !0
});
dt.statements = dt.statement = dt.smart = dt.program = dt.expression = void 0;
var g3 = Ae();
const {
  assertExpressionStatement: E3
} = g3;
function lo(e) {
  return {
    code: (t) => `/* @babel/template */;
${t}`,
    validate: () => {
    },
    unwrap: (t) => e(t.program.body.slice(1))
  };
}
const P3 = lo((e) => e.length > 1 ? e : e[0]);
dt.smart = P3;
const x3 = lo((e) => e);
dt.statements = x3;
const v3 = lo((e) => {
  if (e.length === 0)
    throw new Error("Found nothing to return.");
  if (e.length > 1)
    throw new Error("Found multiple statements but wanted one");
  return e[0];
});
dt.statement = v3;
const Jf = {
  code: (e) => `(
${e}
)`,
  validate: (e) => {
    if (e.program.body.length > 1)
      throw new Error("Found multiple statements but wanted one");
    if (Jf.unwrap(e).start === 0)
      throw new Error("Parse result included parens.");
  },
  unwrap: ({
    program: e
  }) => {
    const [t] = e.body;
    return E3(t), t.expression;
  }
};
dt.expression = Jf;
const A3 = {
  code: (e) => e,
  validate: () => {
  },
  unwrap: (e) => e.program
};
dt.program = A3;
var uo = {}, Sr = {};
Object.defineProperty(Sr, "__esModule", {
  value: !0
});
Sr.merge = w3;
Sr.normalizeReplacements = N3;
Sr.validate = O3;
const C3 = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];
function I3(e, t) {
  if (e == null)
    return {};
  var r = {}, i = Object.keys(e), s, n;
  for (n = 0; n < i.length; n++)
    s = i[n], !(t.indexOf(s) >= 0) && (r[s] = e[s]);
  return r;
}
function w3(e, t) {
  const {
    placeholderWhitelist: r = e.placeholderWhitelist,
    placeholderPattern: i = e.placeholderPattern,
    preserveComments: s = e.preserveComments,
    syntacticPlaceholders: n = e.syntacticPlaceholders
  } = t;
  return {
    parser: Object.assign({}, e.parser, t.parser),
    placeholderWhitelist: r,
    placeholderPattern: i,
    preserveComments: s,
    syntacticPlaceholders: n
  };
}
function O3(e) {
  if (e != null && typeof e != "object")
    throw new Error("Unknown template options.");
  const t = e || {}, {
    placeholderWhitelist: r,
    placeholderPattern: i,
    preserveComments: s,
    syntacticPlaceholders: n
  } = t, a = I3(t, C3);
  if (r != null && !(r instanceof Set))
    throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
  if (i != null && !(i instanceof RegExp) && i !== !1)
    throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
  if (s != null && typeof s != "boolean")
    throw new Error("'.preserveComments' must be a boolean, null, or undefined");
  if (n != null && typeof n != "boolean")
    throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
  if (n === !0 && (r != null || i != null))
    throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
  return {
    parser: a,
    placeholderWhitelist: r || void 0,
    placeholderPattern: i ?? void 0,
    preserveComments: s ?? void 0,
    syntacticPlaceholders: n ?? void 0
  };
}
function N3(e) {
  if (Array.isArray(e))
    return e.reduce((t, r, i) => (t["$" + i] = r, t), {});
  if (typeof e == "object" || e == null)
    return e || void 0;
  throw new Error("Template replacements must be an array, object, null, or undefined");
}
var co = {}, Gs = {};
Object.defineProperty(Gs, "__esModule", {
  value: !0
});
Gs.default = q3;
var _3 = Ae(), D3 = pr, k3 = Pi;
const {
  isCallExpression: L3,
  isExpressionStatement: M3,
  isFunction: B3,
  isIdentifier: F3,
  isJSXIdentifier: j3,
  isNewExpression: R3,
  isPlaceholder: zi,
  isStatement: $3,
  isStringLiteral: hu,
  removePropertiesDeep: U3,
  traverse: V3
} = _3, K3 = /^[_$A-Z0-9]+$/;
function q3(e, t, r) {
  const {
    placeholderWhitelist: i,
    placeholderPattern: s,
    preserveComments: n,
    syntacticPlaceholders: a
  } = r, o = X3(t, r.parser, a);
  U3(o, {
    preserveComments: n
  }), e.validate(o);
  const l = {
    syntactic: {
      placeholders: [],
      placeholderNames: /* @__PURE__ */ new Set()
    },
    legacy: {
      placeholders: [],
      placeholderNames: /* @__PURE__ */ new Set()
    },
    placeholderWhitelist: i,
    placeholderPattern: s,
    syntacticPlaceholders: a
  };
  return V3(o, W3, l), Object.assign({
    ast: o
  }, l.syntactic.placeholders.length ? l.syntactic : l.legacy);
}
function W3(e, t, r) {
  var i;
  let s, n = r.syntactic.placeholders.length > 0;
  if (zi(e)) {
    if (r.syntacticPlaceholders === !1)
      throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
    s = e.name.name, n = !0;
  } else {
    if (n || r.syntacticPlaceholders)
      return;
    if (F3(e) || j3(e))
      s = e.name;
    else if (hu(e))
      s = e.value;
    else
      return;
  }
  if (n && (r.placeholderPattern != null || r.placeholderWhitelist != null))
    throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
  if (!n && (r.placeholderPattern === !1 || !(r.placeholderPattern || K3).test(s)) && !((i = r.placeholderWhitelist) != null && i.has(s)))
    return;
  t = t.slice();
  const {
    node: a,
    key: o
  } = t[t.length - 1];
  let l;
  hu(e) || zi(e, {
    expectedNode: "StringLiteral"
  }) ? l = "string" : R3(a) && o === "arguments" || L3(a) && o === "arguments" || B3(a) && o === "params" ? l = "param" : M3(a) && !zi(e) ? (l = "statement", t = t.slice(0, -1)) : $3(e) && zi(e) ? l = "statement" : l = "other";
  const {
    placeholders: u,
    placeholderNames: c
  } = n ? r.syntactic : r.legacy;
  u.push({
    name: s,
    type: l,
    resolve: (p) => Y3(p, t),
    isDuplicate: c.has(s)
  }), c.add(s);
}
function Y3(e, t) {
  let r = e;
  for (let n = 0; n < t.length - 1; n++) {
    const {
      key: a,
      index: o
    } = t[n];
    o === void 0 ? r = r[a] : r = r[a][o];
  }
  const {
    key: i,
    index: s
  } = t[t.length - 1];
  return {
    parent: r,
    key: i,
    index: s
  };
}
function X3(e, t, r) {
  const i = (t.plugins || []).slice();
  r !== !1 && i.push("placeholders"), t = Object.assign({
    allowReturnOutsideFunction: !0,
    allowSuperOutsideMethod: !0,
    sourceType: "module"
  }, t, {
    plugins: i
  });
  try {
    return (0, D3.parse)(e, t);
  } catch (s) {
    const n = s.loc;
    throw n && (s.message += `
` + (0, k3.codeFrameColumns)(e, {
      start: n
    }), s.code = "BABEL_TEMPLATE_PARSE_ERROR"), s;
  }
}
var zs = {};
Object.defineProperty(zs, "__esModule", {
  value: !0
});
zs.default = Z3;
var J3 = Ae();
const {
  blockStatement: H3,
  cloneNode: Hn,
  emptyStatement: G3,
  expressionStatement: Cn,
  identifier: Qi,
  isStatement: du,
  isStringLiteral: z3,
  stringLiteral: Q3,
  validate: mu
} = J3;
function Z3(e, t) {
  const r = Hn(e.ast);
  return t && (e.placeholders.forEach((i) => {
    if (!Object.prototype.hasOwnProperty.call(t, i.name)) {
      const s = i.name;
      throw new Error(`Error: No substitution given for "${s}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${s}'])}
            - { placeholderPattern: /^${s}$/ }`);
    }
  }), Object.keys(t).forEach((i) => {
    if (!e.placeholderNames.has(i))
      throw new Error(`Unknown substitution "${i}" given`);
  })), e.placeholders.slice().reverse().forEach((i) => {
    try {
      ej(i, r, t && t[i.name] || null);
    } catch (s) {
      throw s.message = `@babel/template placeholder "${i.name}": ${s.message}`, s;
    }
  }), r;
}
function ej(e, t, r) {
  e.isDuplicate && (Array.isArray(r) ? r = r.map((a) => Hn(a)) : typeof r == "object" && (r = Hn(r)));
  const {
    parent: i,
    key: s,
    index: n
  } = e.resolve(t);
  if (e.type === "string") {
    if (typeof r == "string" && (r = Q3(r)), !r || !z3(r))
      throw new Error("Expected string substitution");
  } else if (e.type === "statement")
    n === void 0 ? r ? Array.isArray(r) ? r = H3(r) : typeof r == "string" ? r = Cn(Qi(r)) : du(r) || (r = Cn(r)) : r = G3() : r && !Array.isArray(r) && (typeof r == "string" && (r = Qi(r)), du(r) || (r = Cn(r)));
  else if (e.type === "param") {
    if (typeof r == "string" && (r = Qi(r)), n === void 0)
      throw new Error("Assertion failure.");
  } else if (typeof r == "string" && (r = Qi(r)), Array.isArray(r))
    throw new Error("Cannot replace single expression with an array.");
  if (n === void 0)
    mu(i, s, r), i[s] = r;
  else {
    const a = i[s].slice();
    e.type === "statement" || e.type === "param" ? r == null ? a.splice(n, 1) : Array.isArray(r) ? a.splice(n, 1, ...r) : a[n] = r : a[n] = r, mu(i, s, a), i[s] = a;
  }
}
Object.defineProperty(co, "__esModule", {
  value: !0
});
co.default = sj;
var tj = Sr, rj = Gs, ij = zs;
function sj(e, t, r) {
  t = e.code(t);
  let i;
  return (s) => {
    const n = (0, tj.normalizeReplacements)(s);
    return i || (i = (0, rj.default)(e, t, r)), e.unwrap((0, ij.default)(i, n));
  };
}
var fo = {};
Object.defineProperty(fo, "__esModule", {
  value: !0
});
fo.default = lj;
var nj = Sr, aj = Gs, oj = zs;
function lj(e, t, r) {
  const {
    metadata: i,
    names: s
  } = uj(e, t, r);
  return (n) => {
    const a = {};
    return n.forEach((o, l) => {
      a[s[l]] = o;
    }), (o) => {
      const l = (0, nj.normalizeReplacements)(o);
      return l && Object.keys(l).forEach((u) => {
        if (Object.prototype.hasOwnProperty.call(a, u))
          throw new Error("Unexpected replacement overlap.");
      }), e.unwrap((0, oj.default)(i, l ? Object.assign(l, a) : a));
    };
  };
}
function uj(e, t, r) {
  let i = "BABEL_TPL$";
  const s = t.join("");
  do
    i = "$$" + i;
  while (s.includes(i));
  const {
    names: n,
    code: a
  } = cj(t, i);
  return {
    metadata: (0, aj.default)(e, e.code(a), {
      parser: r.parser,
      placeholderWhitelist: new Set(n.concat(r.placeholderWhitelist ? Array.from(r.placeholderWhitelist) : [])),
      placeholderPattern: r.placeholderPattern,
      preserveComments: r.preserveComments,
      syntacticPlaceholders: r.syntacticPlaceholders
    }),
    names: n
  };
}
function cj(e, t) {
  const r = [];
  let i = e[0];
  for (let s = 1; s < e.length; s++) {
    const n = `${t}${s - 1}`;
    r.push(n), i += n + e[s];
  }
  return {
    names: r,
    code: i
  };
}
Object.defineProperty(uo, "__esModule", {
  value: !0
});
uo.default = Hf;
var xt = Sr, yu = co, Tu = fo;
const Su = (0, xt.validate)({
  placeholderPattern: !1
});
function Hf(e, t) {
  const r = /* @__PURE__ */ new WeakMap(), i = /* @__PURE__ */ new WeakMap(), s = t || (0, xt.validate)(null);
  return Object.assign((n, ...a) => {
    if (typeof n == "string") {
      if (a.length > 1)
        throw new Error("Unexpected extra params.");
      return bu((0, yu.default)(e, n, (0, xt.merge)(s, (0, xt.validate)(a[0]))));
    } else if (Array.isArray(n)) {
      let o = r.get(n);
      return o || (o = (0, Tu.default)(e, n, s), r.set(n, o)), bu(o(a));
    } else if (typeof n == "object" && n) {
      if (a.length > 0)
        throw new Error("Unexpected extra params.");
      return Hf(e, (0, xt.merge)(s, (0, xt.validate)(n)));
    }
    throw new Error(`Unexpected template param ${typeof n}`);
  }, {
    ast: (n, ...a) => {
      if (typeof n == "string") {
        if (a.length > 1)
          throw new Error("Unexpected extra params.");
        return (0, yu.default)(e, n, (0, xt.merge)((0, xt.merge)(s, (0, xt.validate)(a[0])), Su))();
      } else if (Array.isArray(n)) {
        let o = i.get(n);
        return o || (o = (0, Tu.default)(e, n, (0, xt.merge)(s, Su)), i.set(n, o)), o(a)();
      }
      throw new Error(`Unexpected template param ${typeof n}`);
    }
  });
}
function bu(e) {
  let t = "";
  try {
    throw new Error();
  } catch (r) {
    r.stack && (t = r.stack.split(`
`).slice(3).join(`
`));
  }
  return (r) => {
    try {
      return e(r);
    } catch (i) {
      throw i.stack += `
    =============
${t}`, i;
    }
  };
}
Object.defineProperty(ut, "__esModule", {
  value: !0
});
ut.statements = ut.statement = ut.smart = ut.program = ut.expression = ut.default = void 0;
var vi = dt, Ai = uo;
const ns = (0, Ai.default)(vi.smart);
ut.smart = ns;
const Gf = (0, Ai.default)(vi.statement);
ut.statement = Gf;
const zf = (0, Ai.default)(vi.statements);
ut.statements = zf;
const Qf = (0, Ai.default)(vi.expression);
ut.expression = Qf;
const Zf = (0, Ai.default)(vi.program);
ut.program = Zf;
var fj = Object.assign(ns.bind(void 0), {
  smart: ns,
  statement: Gf,
  statements: zf,
  expression: Qf,
  program: Zf,
  ast: ns.ast
});
ut.default = fj;
Object.defineProperty(oo, "__esModule", {
  value: !0
});
oo.default = Dj;
var ep = ut, pj = Ae();
const {
  NOT_LOCAL_BINDING: gu,
  cloneNode: hj,
  identifier: dj,
  isAssignmentExpression: mj,
  isAssignmentPattern: yj,
  isFunction: tp,
  isIdentifier: Eu,
  isLiteral: Pu,
  isNullLiteral: Tj,
  isObjectMethod: Sj,
  isObjectProperty: bj,
  isRegExpLiteral: gj,
  isRestElement: Ej,
  isTemplateLiteral: Pj,
  isVariableDeclarator: xj,
  toBindingIdentifierName: vj
} = pj;
function Aj(e) {
  const t = e.params.findIndex((r) => yj(r) || Ej(r));
  return t === -1 ? e.params.length : t;
}
const Cj = ep.default.statement(`
  (function (FUNCTION_KEY) {
    function FUNCTION_ID() {
      return FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    }

    return FUNCTION_ID;
  })(FUNCTION)
`), Ij = ep.default.statement(`
  (function (FUNCTION_KEY) {
    function* FUNCTION_ID() {
      return yield* FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    };

    return FUNCTION_ID;
  })(FUNCTION)
`), wj = {
  "ReferencedIdentifier|BindingIdentifier"(e, t) {
    e.node.name !== t.name || e.scope.getBindingIdentifier(t.name) !== t.outerDeclar || (t.selfReference = !0, e.stop());
  }
};
function Oj(e) {
  return Tj(e) ? "null" : gj(e) ? `_${e.pattern}_${e.flags}` : Pj(e) ? e.quasis.map((t) => t.value.raw).join("") : e.value !== void 0 ? e.value + "" : "";
}
function Nj(e, t, r, i) {
  if (e.selfReference)
    if (i.hasBinding(r.name) && !i.hasGlobal(r.name))
      i.rename(r.name);
    else {
      if (!tp(t))
        return;
      let s = Cj;
      t.generator && (s = Ij);
      const n = s({
        FUNCTION: t,
        FUNCTION_ID: r,
        FUNCTION_KEY: i.generateUidIdentifier(r.name)
      }).expression, a = n.callee.body.body[0].params;
      for (let o = 0, l = Aj(t); o < l; o++)
        a.push(i.generateUidIdentifier("x"));
      return n;
    }
  t.id = r, i.getProgramParent().references[r.name] = !0;
}
function _j(e, t, r) {
  const i = {
    selfAssignment: !1,
    selfReference: !1,
    outerDeclar: r.getBindingIdentifier(t),
    name: t
  }, s = r.getOwnBinding(t);
  return s ? s.kind === "param" && (i.selfReference = !0) : (i.outerDeclar || r.hasGlobal(t)) && r.traverse(e, wj, i), i;
}
function Dj({
  node: e,
  parent: t,
  scope: r,
  id: i
}, s = !1, n = !1) {
  if (e.id)
    return;
  if ((bj(t) || Sj(t, {
    kind: "method"
  })) && (!t.computed || Pu(t.key)))
    i = t.key;
  else if (xj(t)) {
    if (i = t.id, Eu(i) && !s) {
      const u = r.parent.getBinding(i.name);
      if (u && u.constant && r.getBinding(i.name) === u) {
        e.id = hj(i), e.id[gu] = !0;
        return;
      }
    }
  } else if (mj(t, {
    operator: "="
  }))
    i = t.left;
  else if (!i)
    return;
  let a;
  if (i && Pu(i) ? a = Oj(i) : i && Eu(i) && (a = i.name), a === void 0 || !n && tp(e) && /[\uD800-\uDFFF]/.test(a))
    return;
  a = vj(a);
  const o = dj(a);
  o[gu] = !0;
  const l = _j(e, a, r);
  return Nj(l, e, o, r) || e;
}
Object.defineProperty(Tr, "__esModule", {
  value: !0
});
Tr.arrowFunctionToExpression = eR;
Tr.ensureBlock = zj;
Tr.toComputedKey = Gj;
Tr.unwrapFunctionEnvironment = Qj;
var kj = Ae(), po = mr, Lj = oo, ho = Ft;
const {
  arrowFunctionExpression: mo,
  assignmentExpression: nr,
  binaryExpression: Gn,
  blockStatement: Mj,
  callExpression: Lr,
  conditionalExpression: Bj,
  expressionStatement: rp,
  identifier: Re,
  isIdentifier: Fj,
  jsxIdentifier: jj,
  logicalExpression: Rj,
  LOGICAL_OPERATORS: $j,
  memberExpression: St,
  metaProperty: Uj,
  numericLiteral: Vj,
  objectExpression: Kj,
  restElement: qj,
  returnStatement: Wj,
  sequenceExpression: Yj,
  spreadElement: Xj,
  stringLiteral: ip,
  super: zn,
  thisExpression: oi,
  toExpression: Jj,
  unaryExpression: Hj
} = kj;
function Gj() {
  let e;
  if (this.isMemberExpression())
    e = this.node.property;
  else if (this.isProperty() || this.isMethod())
    e = this.node.key;
  else
    throw new ReferenceError("todo");
  return this.node.computed || Fj(e) && (e = ip(e.name)), e;
}
function zj() {
  const e = this.get("body"), t = e.node;
  if (Array.isArray(e))
    throw new Error("Can't convert array path to a block statement");
  if (!t)
    throw new Error("Can't convert node without a body");
  if (e.isBlockStatement())
    return t;
  const r = [];
  let i = "body", s, n;
  e.isStatement() ? (n = "body", s = 0, r.push(e.node)) : (i += ".body.0", this.isFunction() ? (s = "argument", r.push(Wj(e.node))) : (s = "expression", r.push(rp(e.node)))), this.node.body = Mj(r);
  const a = this.get(i);
  return e.setup(a, n ? a.node[n] : a.node, n, s), this.node;
}
Tr.arrowFunctionToShadowed = function() {
  this.isArrowFunctionExpression() && this.arrowFunctionToExpression();
};
function Qj() {
  if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration())
    throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
  sp(this);
}
function Zj(e, t) {
  e.node.type = t;
}
function eR({
  allowInsertArrow: e = !0,
  allowInsertArrowWithRest: t = e,
  noNewArrows: r = !(() => {
    var i;
    return (i = arguments[0]) == null ? void 0 : i.specCompliant;
  })()
} = {}) {
  if (!this.isArrowFunctionExpression())
    throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
  const {
    thisBinding: i,
    fnPath: s
  } = sp(this, r, e, t);
  if (s.ensureBlock(), Zj(s, "FunctionExpression"), !r) {
    const n = i ? null : s.scope.generateUidIdentifier("arrowCheckId");
    return n && s.parentPath.scope.push({
      id: n,
      init: Kj([])
    }), s.get("body").unshiftContainer("body", rp(Lr(this.hub.addHelper("newArrowCheck"), [oi(), Re(n ? n.name : i)]))), s.replaceWith(Lr(St((0, Lj.default)(this, !0) || s.node, Re("bind")), [n ? Re(n.name) : oi()])), s.get("callee.object");
  }
  return s;
}
const tR = (0, ho.merge)([{
  CallExpression(e, {
    allSuperCalls: t
  }) {
    e.get("callee").isSuper() && t.push(e);
  }
}, po.default]);
function sp(e, t = !0, r = !0, i = !0) {
  let s, n = e.findParent((y) => {
    if (y.isArrowFunctionExpression()) {
      var P;
      return (P = s) != null || (s = y), !1;
    }
    return y.isFunction() || y.isProgram() || y.isClassProperty({
      static: !1
    }) || y.isClassPrivateProperty({
      static: !1
    });
  });
  const a = n.isClassMethod({
    kind: "constructor"
  });
  if (n.isClassProperty() || n.isClassPrivateProperty())
    if (s)
      n = s;
    else if (r)
      e.replaceWith(Lr(mo([], Jj(e.node)), [])), n = e.get("callee"), e = n.get("body");
    else
      throw e.buildCodeFrameError("Unable to transform arrow inside class property");
  const {
    thisPaths: o,
    argumentsPaths: l,
    newTargetPaths: u,
    superProps: c,
    superCalls: p
  } = uR(e);
  if (a && p.length > 0) {
    if (!r)
      throw p[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super()` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
    if (!i)
      throw p[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
    const y = [];
    n.traverse(tR, {
      allSuperCalls: y
    });
    const P = aR(n);
    y.forEach((v) => {
      const w = Re(P);
      w.loc = v.node.callee.loc, v.get("callee").replaceWith(w);
    });
  }
  if (l.length > 0) {
    const y = li(n, "arguments", () => {
      const P = () => Re("arguments");
      return n.scope.path.isProgram() ? Bj(Gn("===", Hj("typeof", P()), ip("undefined")), n.scope.buildUndefinedNode(), P()) : P();
    });
    l.forEach((P) => {
      const v = Re(y);
      v.loc = P.node.loc, P.replaceWith(v);
    });
  }
  if (u.length > 0) {
    const y = li(n, "newtarget", () => Uj(Re("new"), Re("target")));
    u.forEach((P) => {
      const v = Re(y);
      v.loc = P.node.loc, P.replaceWith(v);
    });
  }
  if (c.length > 0) {
    if (!r)
      throw c[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super.prop` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
    c.reduce((P, v) => P.concat(iR(v)), []).forEach((P) => {
      const v = P.node.computed ? "" : P.get("property").node.name, w = P.parentPath, x = w.isAssignmentExpression({
        left: P.node
      }), O = w.isCallExpression({
        callee: P.node
      }), _ = w.isTaggedTemplateExpression({
        tag: P.node
      }), K = oR(n, x, v), R = [];
      if (P.node.computed && R.push(P.get("property").node), x) {
        const C = w.node.right;
        R.push(C);
      }
      const B = Lr(Re(K), R);
      O ? (w.unshiftContainer("arguments", oi()), P.replaceWith(St(B, Re("call"))), o.push(w.get("arguments.0"))) : x ? w.replaceWith(B) : _ ? (P.replaceWith(Lr(St(B, Re("bind"), !1), [oi()])), o.push(P.get("arguments.0"))) : P.replaceWith(B);
    });
  }
  let h;
  return (o.length > 0 || !t) && (h = nR(n, a), (t || a && np(n)) && (o.forEach((y) => {
    const P = y.isJSX() ? jj(h) : Re(h);
    P.loc = y.node.loc, y.replaceWith(P);
  }), t || (h = null))), {
    thisBinding: h,
    fnPath: e
  };
}
function rR(e) {
  return $j.includes(e);
}
function iR(e) {
  if (e.parentPath.isAssignmentExpression() && e.parentPath.node.operator !== "=") {
    const r = e.parentPath, i = r.node.operator.slice(0, -1), s = r.node.right, n = rR(i);
    if (e.node.computed) {
      const a = e.scope.generateDeclaredUidIdentifier("tmp"), o = e.node.object, l = e.node.property;
      r.get("left").replaceWith(St(o, nr("=", a, l), !0)), r.get("right").replaceWith(t(n ? "=" : i, St(o, Re(a.name), !0), s));
    } else {
      const a = e.node.object, o = e.node.property;
      r.get("left").replaceWith(St(a, o)), r.get("right").replaceWith(t(n ? "=" : i, St(a, Re(o.name)), s));
    }
    return n ? r.replaceWith(Rj(i, r.node.left, r.node.right)) : r.node.operator = "=", [r.get("left"), r.get("right").get("left")];
  } else if (e.parentPath.isUpdateExpression()) {
    const r = e.parentPath, i = e.scope.generateDeclaredUidIdentifier("tmp"), s = e.node.computed ? e.scope.generateDeclaredUidIdentifier("prop") : null, n = [nr("=", i, St(e.node.object, s ? nr("=", s, e.node.property) : e.node.property, e.node.computed)), nr("=", St(e.node.object, s ? Re(s.name) : e.node.property, e.node.computed), Gn(e.parentPath.node.operator[0], Re(i.name), Vj(1)))];
    e.parentPath.node.prefix || n.push(Re(i.name)), r.replaceWith(Yj(n));
    const a = r.get("expressions.0.right"), o = r.get("expressions.1.left");
    return [a, o];
  }
  return [e];
  function t(r, i, s) {
    return r === "=" ? nr("=", i, s) : Gn(r, i, s);
  }
}
function np(e) {
  return e.isClassMethod() && !!e.parentPath.parentPath.node.superClass;
}
const sR = (0, ho.merge)([{
  CallExpression(e, {
    supers: t,
    thisBinding: r
  }) {
    e.get("callee").isSuper() && (t.has(e.node) || (t.add(e.node), e.replaceWithMultiple([e.node, nr("=", Re(r), Re("this"))])));
  }
}, po.default]);
function nR(e, t) {
  return li(e, "this", (r) => {
    if (!t || !np(e))
      return oi();
    e.traverse(sR, {
      supers: /* @__PURE__ */ new WeakSet(),
      thisBinding: r
    });
  });
}
function aR(e) {
  return li(e, "supercall", () => {
    const t = e.scope.generateUidIdentifier("args");
    return mo([qj(t)], Lr(zn(), [Xj(Re(t.name))]));
  });
}
function oR(e, t, r) {
  return li(e, `superprop_${t ? "set" : "get"}:${r || ""}`, () => {
    const s = [];
    let n;
    if (r)
      n = St(zn(), Re(r));
    else {
      const a = e.scope.generateUidIdentifier("prop");
      s.unshift(a), n = St(zn(), Re(a.name), !0);
    }
    if (t) {
      const a = e.scope.generateUidIdentifier("value");
      s.push(a), n = nr("=", n, Re(a.name));
    }
    return mo(s, n);
  });
}
function li(e, t, r) {
  const i = "binding:" + t;
  let s = e.getData(i);
  if (!s) {
    const n = e.scope.generateUidIdentifier(t);
    s = n.name, e.setData(i, s), e.scope.push({
      id: n,
      init: r(s)
    });
  }
  return s;
}
const lR = (0, ho.merge)([{
  ThisExpression(e, {
    thisPaths: t
  }) {
    t.push(e);
  },
  JSXIdentifier(e, {
    thisPaths: t
  }) {
    e.node.name === "this" && (!e.parentPath.isJSXMemberExpression({
      object: e.node
    }) && !e.parentPath.isJSXOpeningElement({
      name: e.node
    }) || t.push(e));
  },
  CallExpression(e, {
    superCalls: t
  }) {
    e.get("callee").isSuper() && t.push(e);
  },
  MemberExpression(e, {
    superProps: t
  }) {
    e.get("object").isSuper() && t.push(e);
  },
  Identifier(e, {
    argumentsPaths: t
  }) {
    if (!e.isReferencedIdentifier({
      name: "arguments"
    }))
      return;
    let r = e.scope;
    do {
      if (r.hasOwnBinding("arguments")) {
        r.rename("arguments");
        return;
      }
      if (r.path.isFunction() && !r.path.isArrowFunctionExpression())
        break;
    } while (r = r.parent);
    t.push(e);
  },
  MetaProperty(e, {
    newTargetPaths: t
  }) {
    e.get("meta").isIdentifier({
      name: "new"
    }) && e.get("property").isIdentifier({
      name: "target"
    }) && t.push(e);
  }
}, po.default]);
function uR(e) {
  const t = [], r = [], i = [], s = [], n = [];
  return e.traverse(lR, {
    thisPaths: t,
    argumentsPaths: r,
    newTargetPaths: i,
    superProps: s,
    superCalls: n
  }), {
    thisPaths: t,
    argumentsPaths: r,
    newTargetPaths: i,
    superProps: s,
    superCalls: n
  };
}
var Ke = {};
Object.defineProperty(Ke, "__esModule", {
  value: !0
});
Ke._guessExecutionStatusRelativeTo = kR;
Ke._resolve = FR;
Ke.canHaveVariableDeclarationOrExpression = AR;
Ke.canSwapBetweenExpressionAndStatement = CR;
Ke.equals = xR;
Ke.getSource = NR;
Ke.has = op;
Ke.is = void 0;
Ke.isCompletionRecord = IR;
Ke.isConstantExpression = jR;
Ke.isInStrictMode = RR;
Ke.isNodeType = vR;
Ke.isStatementOrBlock = wR;
Ke.isStatic = gR;
Ke.isnt = PR;
Ke.matchesPattern = bR;
Ke.referencesImport = OR;
Ke.resolve = BR;
Ke.willIMaybeExecuteBefore = _R;
var cR = Ae();
const {
  STATEMENT_OR_BLOCK_KEYS: fR,
  VISITOR_KEYS: pR,
  isBlockStatement: ap,
  isExpression: hR,
  isIdentifier: dR,
  isLiteral: mR,
  isStringLiteral: yR,
  isType: TR,
  matchesPattern: SR
} = cR;
function bR(e, t) {
  return SR(this.node, e, t);
}
function op(e) {
  const t = this.node && this.node[e];
  return t && Array.isArray(t) ? !!t.length : !!t;
}
function gR() {
  return this.scope.isStatic(this.node);
}
const ER = op;
Ke.is = ER;
function PR(e) {
  return !this.has(e);
}
function xR(e, t) {
  return this.node[e] === t;
}
function vR(e) {
  return TR(this.type, e);
}
function AR() {
  return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
}
function CR(e) {
  return this.key !== "body" || !this.parentPath.isArrowFunctionExpression() ? !1 : this.isExpression() ? ap(e) : this.isBlockStatement() ? hR(e) : !1;
}
function IR(e) {
  let t = this, r = !0;
  do {
    const {
      type: i,
      container: s
    } = t;
    if (!r && (t.isFunction() || i === "StaticBlock"))
      return !!e;
    if (r = !1, Array.isArray(s) && t.key !== s.length - 1)
      return !1;
  } while ((t = t.parentPath) && !t.isProgram() && !t.isDoExpression());
  return !0;
}
function wR() {
  return this.parentPath.isLabeledStatement() || ap(this.container) ? !1 : fR.includes(this.key);
}
function OR(e, t) {
  if (!this.isReferencedIdentifier()) {
    if (this.isJSXMemberExpression() && this.node.property.name === t || (this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? yR(this.node.property, {
      value: t
    }) : this.node.property.name === t)) {
      const n = this.get("object");
      return n.isReferencedIdentifier() && n.referencesImport(e, "*");
    }
    return !1;
  }
  const r = this.scope.getBinding(this.node.name);
  if (!r || r.kind !== "module")
    return !1;
  const i = r.path, s = i.parentPath;
  if (!s.isImportDeclaration())
    return !1;
  if (s.node.source.value === e) {
    if (!t)
      return !0;
  } else
    return !1;
  return !!(i.isImportDefaultSpecifier() && t === "default" || i.isImportNamespaceSpecifier() && t === "*" || i.isImportSpecifier() && dR(i.node.imported, {
    name: t
  }));
}
function NR() {
  const e = this.node;
  if (e.end) {
    const t = this.hub.getCode();
    if (t)
      return t.slice(e.start, e.end);
  }
  return "";
}
function _R(e) {
  return this._guessExecutionStatusRelativeTo(e) !== "after";
}
function xu(e) {
  return e.isProgram() ? e : (e.parentPath.scope.getFunctionParent() || e.parentPath.scope.getProgramParent()).path;
}
function DR(e, t) {
  switch (e) {
    case "LogicalExpression":
      return t === "right";
    case "ConditionalExpression":
    case "IfStatement":
      return t === "consequent" || t === "alternate";
    case "WhileStatement":
    case "DoWhileStatement":
    case "ForInStatement":
    case "ForOfStatement":
      return t === "body";
    case "ForStatement":
      return t === "body" || t === "update";
    case "SwitchStatement":
      return t === "cases";
    case "TryStatement":
      return t === "handler";
    case "AssignmentPattern":
      return t === "right";
    case "OptionalMemberExpression":
      return t === "property";
    case "OptionalCallExpression":
      return t === "arguments";
    default:
      return !1;
  }
}
function vu(e, t) {
  for (let r = 0; r < t; r++) {
    const i = e[r];
    if (DR(i.parent.type, i.parentKey))
      return !0;
  }
  return !1;
}
const Au = Symbol();
function kR(e) {
  return Qn(this, e, /* @__PURE__ */ new Map());
}
function Qn(e, t, r) {
  const i = {
    this: xu(e),
    target: xu(t)
  };
  if (i.target.node !== i.this.node)
    return MR(e, i.target, r);
  const s = {
    target: t.getAncestry(),
    this: e.getAncestry()
  };
  if (s.target.indexOf(e) >= 0)
    return "after";
  if (s.this.indexOf(t) >= 0)
    return "before";
  let n;
  const a = {
    target: 0,
    this: 0
  };
  for (; !n && a.this < s.this.length; ) {
    const c = s.this[a.this];
    a.target = s.target.indexOf(c), a.target >= 0 ? n = c : a.this++;
  }
  if (!n)
    throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
  if (vu(s.this, a.this - 1) || vu(s.target, a.target - 1))
    return "unknown";
  const o = {
    this: s.this[a.this - 1],
    target: s.target[a.target - 1]
  };
  if (o.target.listKey && o.this.listKey && o.target.container === o.this.container)
    return o.target.key > o.this.key ? "before" : "after";
  const l = pR[n.type], u = {
    this: l.indexOf(o.this.parentKey),
    target: l.indexOf(o.target.parentKey)
  };
  return u.target > u.this ? "before" : "after";
}
function LR(e, t, r) {
  if (t.isFunctionDeclaration()) {
    if (t.parentPath.isExportDeclaration())
      return "unknown";
  } else
    return Qn(e, t, r) === "before" ? "before" : "unknown";
  const i = t.scope.getBinding(t.node.id.name);
  if (!i.references)
    return "before";
  const s = i.referencePaths;
  let n;
  for (const a of s) {
    if (!!a.find((u) => u.node === t.node))
      continue;
    if (a.key !== "callee" || !a.parentPath.isCallExpression())
      return "unknown";
    const l = Qn(e, a, r);
    if (n && n !== l)
      return "unknown";
    n = l;
  }
  return n;
}
function MR(e, t, r) {
  let i = r.get(e.node), s;
  if (!i)
    r.set(e.node, i = /* @__PURE__ */ new Map());
  else if (s = i.get(t.node))
    return s === Au ? "unknown" : s;
  i.set(t.node, Au);
  const n = LR(e, t, r);
  return i.set(t.node, n), n;
}
function BR(e, t) {
  return this._resolve(e, t) || this;
}
function FR(e, t) {
  if (!(t && t.indexOf(this) >= 0))
    if (t = t || [], t.push(this), this.isVariableDeclarator()) {
      if (this.get("id").isIdentifier())
        return this.get("init").resolve(e, t);
    } else if (this.isReferencedIdentifier()) {
      const r = this.scope.getBinding(this.node.name);
      if (!r || !r.constant || r.kind === "module")
        return;
      if (r.path !== this) {
        const i = r.path.resolve(e, t);
        return this.find((s) => s.node === i.node) ? void 0 : i;
      }
    } else {
      if (this.isTypeCastExpression())
        return this.get("expression").resolve(e, t);
      if (e && this.isMemberExpression()) {
        const r = this.toComputedKey();
        if (!mR(r))
          return;
        const i = r.value, s = this.get("object").resolve(e, t);
        if (s.isObjectExpression()) {
          const n = s.get("properties");
          for (const a of n) {
            if (!a.isProperty())
              continue;
            const o = a.get("key");
            let l = a.isnt("computed") && o.isIdentifier({
              name: i
            });
            if (l = l || o.isLiteral({
              value: i
            }), l)
              return a.get("value").resolve(e, t);
          }
        } else if (s.isArrayExpression() && !isNaN(+i)) {
          const a = s.get("elements")[i];
          if (a)
            return a.resolve(e, t);
        }
      }
    }
}
function jR() {
  if (this.isIdentifier()) {
    const e = this.scope.getBinding(this.node.name);
    return e ? e.constant : !1;
  }
  if (this.isLiteral())
    return this.isRegExpLiteral() ? !1 : this.isTemplateLiteral() ? this.get("expressions").every((e) => e.isConstantExpression()) : !0;
  if (this.isUnaryExpression())
    return this.node.operator !== "void" ? !1 : this.get("argument").isConstantExpression();
  if (this.isBinaryExpression()) {
    const {
      operator: e
    } = this.node;
    return e !== "in" && e !== "instanceof" && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
  }
  return !1;
}
function RR() {
  return !!(this.isProgram() ? this : this.parentPath).find((r) => {
    if (r.isProgram({
      sourceType: "module"
    }) || r.isClass())
      return !0;
    if (r.isArrowFunctionExpression() && !r.get("body").isBlockStatement())
      return !1;
    let i;
    if (r.isFunction())
      i = r.node.body;
    else if (r.isProgram())
      i = r.node;
    else
      return !1;
    for (const s of i.directives)
      if (s.value.value === "use strict")
        return !0;
  });
}
var Ue = {}, Cu;
function $R() {
  if (Cu)
    return Ue;
  Cu = 1, Object.defineProperty(Ue, "__esModule", {
    value: !0
  }), Ue._call = i, Ue._getQueueContexts = B, Ue._resyncKey = P, Ue._resyncList = v, Ue._resyncParent = y, Ue._resyncRemoved = w, Ue.call = r, Ue.isBlacklisted = Ue.isDenylisted = s, Ue.popContext = x, Ue.pushContext = O, Ue.requeue = R, Ue.resync = h, Ue.setContext = p, Ue.setKey = K, Ue.setScope = c, Ue.setup = _, Ue.skip = o, Ue.skipKey = l, Ue.stop = u, Ue.visit = a;
  var e = To(), t = br();
  function r(C) {
    const L = this.opts;
    if (this.debug(C), this.node && this._call(L[C]))
      return !0;
    if (this.node) {
      var F;
      return this._call((F = L[this.node.type]) == null ? void 0 : F[C]);
    }
    return !1;
  }
  function i(C) {
    if (!C)
      return !1;
    for (const L of C) {
      if (!L)
        continue;
      const F = this.node;
      if (!F)
        return !0;
      const te = L.call(this.state, this, this.state);
      if (te && typeof te == "object" && typeof te.then == "function")
        throw new Error("You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
      if (te)
        throw new Error(`Unexpected return value from visitor method ${L}`);
      if (this.node !== F || this._traverseFlags > 0)
        return !0;
    }
    return !1;
  }
  function s() {
    var C;
    const L = (C = this.opts.denylist) != null ? C : this.opts.blacklist;
    return L && L.indexOf(this.node.type) > -1;
  }
  function n(C, L) {
    C.context !== L && (C.context = L, C.state = L.state, C.opts = L.opts);
  }
  function a() {
    var C, L;
    if (!this.node || this.isDenylisted() || (C = (L = this.opts).shouldSkip) != null && C.call(L, this))
      return !1;
    const F = this.context;
    return this.shouldSkip || this.call("enter") ? (this.debug("Skip..."), this.shouldStop) : (n(this, F), this.debug("Recursing into..."), this.shouldStop = (0, e.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys), n(this, F), this.call("exit"), this.shouldStop);
  }
  function o() {
    this.shouldSkip = !0;
  }
  function l(C) {
    this.skipKeys == null && (this.skipKeys = {}), this.skipKeys[C] = !0;
  }
  function u() {
    this._traverseFlags |= t.SHOULD_SKIP | t.SHOULD_STOP;
  }
  function c() {
    var C, L;
    if ((C = this.opts) != null && C.noScope)
      return;
    let F = this.parentPath;
    ((this.key === "key" || this.listKey === "decorators") && F.isMethod() || this.key === "discriminant" && F.isSwitchStatement()) && (F = F.parentPath);
    let te;
    for (; F && !te; ) {
      var Z;
      if ((Z = F.opts) != null && Z.noScope)
        return;
      te = F.scope, F = F.parentPath;
    }
    this.scope = this.getScope(te), (L = this.scope) == null || L.init();
  }
  function p(C) {
    return this.skipKeys != null && (this.skipKeys = {}), this._traverseFlags = 0, C && (this.context = C, this.state = C.state, this.opts = C.opts), this.setScope(), this;
  }
  function h() {
    this.removed || (this._resyncParent(), this._resyncList(), this._resyncKey());
  }
  function y() {
    this.parentPath && (this.parent = this.parentPath.node);
  }
  function P() {
    if (this.container && this.node !== this.container[this.key]) {
      if (Array.isArray(this.container)) {
        for (let C = 0; C < this.container.length; C++)
          if (this.container[C] === this.node) {
            this.setKey(C);
            return;
          }
      } else
        for (const C of Object.keys(this.container))
          if (this.container[C] === this.node) {
            this.setKey(C);
            return;
          }
      this.key = null;
    }
  }
  function v() {
    if (!this.parent || !this.inList)
      return;
    const C = this.parent[this.listKey];
    this.container !== C && (this.container = C || null);
  }
  function w() {
    (this.key == null || !this.container || this.container[this.key] !== this.node) && this._markRemoved();
  }
  function x() {
    this.contexts.pop(), this.contexts.length > 0 ? this.setContext(this.contexts[this.contexts.length - 1]) : this.setContext(void 0);
  }
  function O(C) {
    this.contexts.push(C), this.setContext(C);
  }
  function _(C, L, F, te) {
    this.listKey = F, this.container = L, this.parentPath = C || this.parentPath, this.setKey(te);
  }
  function K(C) {
    var L;
    this.key = C, this.node = this.container[this.key], this.type = (L = this.node) == null ? void 0 : L.type;
  }
  function R(C = this) {
    if (C.removed)
      return;
    const L = this.contexts;
    for (const F of L)
      F.maybeQueue(C);
  }
  function B() {
    let C = this, L = this.contexts;
    for (; !L.length && (C = C.parentPath, !!C); )
      L = C.contexts;
    return L;
  }
  return Ue;
}
var wt = {}, Qs = {};
Object.defineProperty(Qs, "__esModule", {
  value: !0
});
Qs.hooks = void 0;
const UR = [function(e, t) {
  if (e.key === "test" && (t.isWhile() || t.isSwitchCase()) || e.key === "declaration" && t.isExportDeclaration() || e.key === "body" && t.isLabeledStatement() || e.listKey === "declarations" && t.isVariableDeclaration() && t.node.declarations.length === 1 || e.key === "expression" && t.isExpressionStatement())
    return t.remove(), !0;
}, function(e, t) {
  if (t.isSequenceExpression() && t.node.expressions.length === 1)
    return t.replaceWith(t.node.expressions[0]), !0;
}, function(e, t) {
  if (t.isBinary())
    return e.key === "left" ? t.replaceWith(t.node.right) : t.replaceWith(t.node.left), !0;
}, function(e, t) {
  if (t.isIfStatement() && e.key === "consequent" || e.key === "body" && (t.isLoop() || t.isArrowFunctionExpression()))
    return e.replaceWith({
      type: "BlockStatement",
      body: []
    }), !0;
}];
Qs.hooks = UR;
var Iu;
function VR() {
  if (Iu)
    return wt;
  Iu = 1, Object.defineProperty(wt, "__esModule", {
    value: !0
  }), wt._assertUnremoved = l, wt._callRemovalHooks = n, wt._markRemoved = o, wt._remove = a, wt._removeFromScope = s, wt.remove = i;
  var e = Qs, t = Ze, r = br();
  function i() {
    var u;
    if (this._assertUnremoved(), this.resync(), (u = this.opts) != null && u.noScope || this._removeFromScope(), this._callRemovalHooks()) {
      this._markRemoved();
      return;
    }
    this.shareCommentsWithSiblings(), this._remove(), this._markRemoved();
  }
  function s() {
    const u = this.getBindingIdentifiers();
    Object.keys(u).forEach((c) => this.scope.removeBinding(c));
  }
  function n() {
    for (const u of e.hooks)
      if (u(this, this.parentPath))
        return !0;
  }
  function a() {
    Array.isArray(this.container) ? (this.container.splice(this.key, 1), this.updateSiblingKeys(this.key, -1)) : this._replaceWith(null);
  }
  function o() {
    this._traverseFlags |= r.SHOULD_SKIP | r.REMOVED, this.parent && t.path.get(this.parent).delete(this.node), this.node = null;
  }
  function l() {
    if (this.removed)
      throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
  }
  return wt;
}
var pt = {}, Zs = {};
Object.defineProperty(Zs, "__esModule", {
  value: !0
});
Zs.default = void 0;
var lp = Ae(), KR = lp;
const {
  react: qR
} = lp, {
  cloneNode: WR,
  jsxExpressionContainer: YR,
  variableDeclaration: XR,
  variableDeclarator: JR
} = KR, HR = {
  ReferencedIdentifier(e, t) {
    if (e.isJSXIdentifier() && qR.isCompatTag(e.node.name) && !e.parentPath.isJSXMemberExpression())
      return;
    if (e.node.name === "this") {
      let i = e.scope;
      do
        if (i.path.isFunction() && !i.path.isArrowFunctionExpression())
          break;
      while (i = i.parent);
      i && t.breakOnScopePaths.push(i.path);
    }
    const r = e.scope.getBinding(e.node.name);
    if (r) {
      for (const i of r.constantViolations)
        if (i.scope !== r.path.scope) {
          t.mutableBinding = !0, e.stop();
          return;
        }
      r === t.scope.getBinding(e.node.name) && (t.bindings[e.node.name] = r);
    }
  }
};
class GR {
  constructor(t, r) {
    this.breakOnScopePaths = void 0, this.bindings = void 0, this.mutableBinding = void 0, this.scopes = void 0, this.scope = void 0, this.path = void 0, this.attachAfter = void 0, this.breakOnScopePaths = [], this.bindings = {}, this.mutableBinding = !1, this.scopes = [], this.scope = r, this.path = t, this.attachAfter = !1;
  }
  isCompatibleScope(t) {
    for (const r of Object.keys(this.bindings)) {
      const i = this.bindings[r];
      if (!t.bindingIdentifierEquals(r, i.identifier))
        return !1;
    }
    return !0;
  }
  getCompatibleScopes() {
    let t = this.path.scope;
    do {
      if (this.isCompatibleScope(t))
        this.scopes.push(t);
      else
        break;
      if (this.breakOnScopePaths.indexOf(t.path) >= 0)
        break;
    } while (t = t.parent);
  }
  getAttachmentPath() {
    let t = this._getAttachmentPath();
    if (!t)
      return;
    let r = t.scope;
    if (r.path === t && (r = t.scope.parent), r.path.isProgram() || r.path.isFunction())
      for (const i of Object.keys(this.bindings)) {
        if (!r.hasOwnBinding(i))
          continue;
        const s = this.bindings[i];
        if (s.kind === "param" || s.path.parentKey === "params")
          continue;
        if (this.getAttachmentParentForPath(s.path).key >= t.key) {
          this.attachAfter = !0, t = s.path;
          for (const a of s.constantViolations)
            this.getAttachmentParentForPath(a).key > t.key && (t = a);
        }
      }
    return t;
  }
  _getAttachmentPath() {
    const r = this.scopes.pop();
    if (r) {
      if (r.path.isFunction())
        if (this.hasOwnParamBindings(r)) {
          if (this.scope === r)
            return;
          const i = r.path.get("body").get("body");
          for (let s = 0; s < i.length; s++)
            if (!i[s].node._blockHoist)
              return i[s];
        } else
          return this.getNextScopeAttachmentParent();
      else if (r.path.isProgram())
        return this.getNextScopeAttachmentParent();
    }
  }
  getNextScopeAttachmentParent() {
    const t = this.scopes.pop();
    if (t)
      return this.getAttachmentParentForPath(t.path);
  }
  getAttachmentParentForPath(t) {
    do
      if (!t.parentPath || Array.isArray(t.container) && t.isStatement())
        return t;
    while (t = t.parentPath);
  }
  hasOwnParamBindings(t) {
    for (const r of Object.keys(this.bindings)) {
      if (!t.hasOwnBinding(r))
        continue;
      const i = this.bindings[r];
      if (i.kind === "param" && i.constant)
        return !0;
    }
    return !1;
  }
  run() {
    if (this.path.traverse(HR, this), this.mutableBinding)
      return;
    this.getCompatibleScopes();
    const t = this.getAttachmentPath();
    if (!t || t.getFunctionParent() === this.path.getFunctionParent())
      return;
    let r = t.scope.generateUidIdentifier("ref");
    const i = JR(r, this.path.node), s = this.attachAfter ? "insertAfter" : "insertBefore", [n] = t[s]([t.isVariableDeclarator() ? i : XR("var", [i])]), a = this.path.parentPath;
    return a.isJSXElement() && this.path.container === a.node.children && (r = YR(r)), this.path.replaceWith(WR(r)), t.isVariableDeclarator() ? n.get("init") : n.get("declarations.0.init");
  }
}
Zs.default = GR;
var wu;
function zR() {
  if (wu)
    return pt;
  wu = 1, Object.defineProperty(pt, "__esModule", {
    value: !0
  }), pt._containerInsert = K, pt._containerInsertAfter = B, pt._containerInsertBefore = R, pt._verifyNodeList = J, pt.hoist = k, pt.insertAfter = te, pt.insertBefore = _, pt.pushContainer = me, pt.unshiftContainer = ce, pt.updateSiblingKeys = Z;
  var e = Ze, t = Zs, r = br(), i = Ae();
  const {
    arrowFunctionExpression: s,
    assertExpression: n,
    assignmentExpression: a,
    blockStatement: o,
    callExpression: l,
    cloneNode: u,
    expressionStatement: c,
    isAssignmentExpression: p,
    isCallExpression: h,
    isExportNamedDeclaration: y,
    isExpression: P,
    isIdentifier: v,
    isSequenceExpression: w,
    isSuper: x,
    thisExpression: O
  } = i;
  function _(M) {
    this._assertUnremoved();
    const D = this._verifyNodeList(M), {
      parentPath: j,
      parent: X
    } = this;
    if (j.isExpressionStatement() || j.isLabeledStatement() || y(X) || j.isExportDefaultDeclaration() && this.isDeclaration())
      return j.insertBefore(D);
    if (this.isNodeType("Expression") && !this.isJSXElement() || j.isForStatement() && this.key === "init")
      return this.node && D.push(this.node), this.replaceExpressionWithStatements(D);
    if (Array.isArray(this.container))
      return this._containerInsertBefore(D);
    if (this.isStatementOrBlock()) {
      const W = this.node, ae = W && (!this.isExpressionStatement() || W.expression != null);
      return this.replaceWith(o(ae ? [W] : [])), this.unshiftContainer("body", D);
    } else
      throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
  }
  function K(M, D) {
    this.updateSiblingKeys(M, D.length);
    const j = [];
    this.container.splice(M, 0, ...D);
    for (let W = 0; W < D.length; W++) {
      const ae = M + W, ie = this.getSibling(ae);
      j.push(ie), this.context && this.context.queue && ie.pushContext(this.context);
    }
    const X = this._getQueueContexts();
    for (const W of j) {
      W.setScope(), W.debug("Inserted.");
      for (const ae of X)
        ae.maybeQueue(W, !0);
    }
    return j;
  }
  function R(M) {
    return this._containerInsert(this.key, M);
  }
  function B(M) {
    return this._containerInsert(this.key + 1, M);
  }
  const C = (M) => M[M.length - 1];
  function L(M) {
    return w(M.parent) && (C(M.parent.expressions) !== M.node || L(M.parentPath));
  }
  function F(M, D) {
    if (!p(M) || !v(M.left))
      return !1;
    const j = D.getBlockParent();
    return j.hasOwnBinding(M.left.name) && j.getOwnBinding(M.left.name).constantViolations.length <= 1;
  }
  function te(M) {
    if (this._assertUnremoved(), this.isSequenceExpression())
      return C(this.get("expressions")).insertAfter(M);
    const D = this._verifyNodeList(M), {
      parentPath: j,
      parent: X
    } = this;
    if (j.isExpressionStatement() || j.isLabeledStatement() || y(X) || j.isExportDefaultDeclaration() && this.isDeclaration())
      return j.insertAfter(D.map((W) => P(W) ? c(W) : W));
    if (this.isNodeType("Expression") && !this.isJSXElement() && !j.isJSXElement() || j.isForStatement() && this.key === "init") {
      if (this.node) {
        const W = this.node;
        let {
          scope: ae
        } = this;
        if (ae.path.isPattern())
          return n(W), this.replaceWith(l(s([], W), [])), this.get("callee.body").insertAfter(D), [this];
        if (L(this))
          D.unshift(W);
        else if (h(W) && x(W.callee))
          D.unshift(W), D.push(O());
        else if (F(W, ae))
          D.unshift(W), D.push(u(W.left));
        else if (ae.isPure(W, !0))
          D.push(W);
        else {
          j.isMethod({
            computed: !0,
            key: W
          }) && (ae = ae.parent);
          const ie = ae.generateDeclaredUidIdentifier();
          D.unshift(c(a("=", u(ie), W))), D.push(c(u(ie)));
        }
      }
      return this.replaceExpressionWithStatements(D);
    } else {
      if (Array.isArray(this.container))
        return this._containerInsertAfter(D);
      if (this.isStatementOrBlock()) {
        const W = this.node, ae = W && (!this.isExpressionStatement() || W.expression != null);
        return this.replaceWith(o(ae ? [W] : [])), this.pushContainer("body", D);
      } else
        throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
    }
  }
  function Z(M, D) {
    if (!this.parent)
      return;
    const j = e.path.get(this.parent);
    for (const [, X] of j)
      typeof X.key == "number" && X.key >= M && (X.key += D);
  }
  function J(M) {
    if (!M)
      return [];
    Array.isArray(M) || (M = [M]);
    for (let D = 0; D < M.length; D++) {
      const j = M[D];
      let X;
      if (j ? typeof j != "object" ? X = "contains a non-object node" : j.type ? j instanceof r.default && (X = "has a NodePath when it expected a raw object") : X = "without a type" : X = "has falsy node", X) {
        const W = Array.isArray(j) ? "array" : typeof j;
        throw new Error(`Node list ${X} with the index of ${D} and type of ${W}`);
      }
    }
    return M;
  }
  function ce(M, D) {
    return this._assertUnremoved(), D = this._verifyNodeList(D), r.default.get({
      parentPath: this,
      parent: this.node,
      container: this.node[M],
      listKey: M,
      key: 0
    }).setContext(this.context)._containerInsertBefore(D);
  }
  function me(M, D) {
    this._assertUnremoved();
    const j = this._verifyNodeList(D), X = this.node[M];
    return r.default.get({
      parentPath: this,
      parent: this.node,
      container: X,
      listKey: M,
      key: X.length
    }).setContext(this.context).replaceWithMultiple(j);
  }
  function k(M = this.scope) {
    return new t.default(this, M).run();
  }
  return pt;
}
var ze = {}, Ou;
function QR() {
  if (Ou)
    return ze;
  Ou = 1, Object.defineProperty(ze, "__esModule", {
    value: !0
  }), ze._getKey = F, ze._getPattern = te, ze.get = L, ze.getAllNextSiblings = B, ze.getAllPrevSiblings = C, ze.getBindingIdentifierPaths = ce, ze.getBindingIdentifiers = Z, ze.getCompletionRecords = O, ze.getNextSibling = R, ze.getOpposite = p, ze.getOuterBindingIdentifierPaths = me, ze.getOuterBindingIdentifiers = J, ze.getPrevSibling = K, ze.getSibling = _;
  var e = br(), t = Ae();
  const {
    getBindingIdentifiers: r,
    getOuterBindingIdentifiers: i,
    isDeclaration: s,
    numericLiteral: n,
    unaryExpression: a
  } = t, o = 0, l = 1;
  function u(k) {
    return {
      type: o,
      path: k
    };
  }
  function c(k) {
    return {
      type: l,
      path: k
    };
  }
  function p() {
    return this.key === "left" ? this.getSibling("right") : this.key === "right" ? this.getSibling("left") : null;
  }
  function h(k, M, D) {
    return k && M.push(...x(k, D)), M;
  }
  function y(k, M, D) {
    let j = [];
    for (let X = 0; X < k.length; X++) {
      const W = k[X], ae = x(W, D), ie = [], ge = [];
      for (const Ce of ae)
        Ce.type === o && ie.push(Ce), Ce.type === l && ge.push(Ce);
      ie.length && (j = ie), M.push(...ge);
    }
    return M.push(...j), M;
  }
  function P(k) {
    k.forEach((M) => {
      M.type = l;
    });
  }
  function v(k, M) {
    k.forEach((D) => {
      D.path.isBreakStatement({
        label: null
      }) && (M ? D.path.replaceWith(a("void", n(0))) : D.path.remove());
    });
  }
  function w(k, M) {
    const D = [];
    if (M.canHaveBreak) {
      let j = [];
      for (let X = 0; X < k.length; X++) {
        const W = k[X], ae = Object.assign({}, M, {
          inCaseClause: !1
        });
        W.isBlockStatement() && (M.inCaseClause || M.shouldPopulateBreak) ? ae.shouldPopulateBreak = !0 : ae.shouldPopulateBreak = !1;
        const ie = x(W, ae);
        if (ie.length > 0 && ie.every((ge) => ge.type === l)) {
          j.length > 0 && ie.every((ge) => ge.path.isBreakStatement({
            label: null
          })) ? (P(j), D.push(...j), j.some((ge) => ge.path.isDeclaration()) && (D.push(...ie), v(ie, !0)), v(ie, !1)) : (D.push(...ie), M.shouldPopulateBreak || v(ie, !0));
          break;
        }
        if (X === k.length - 1)
          D.push(...ie);
        else {
          j = [];
          for (let ge = 0; ge < ie.length; ge++) {
            const Ce = ie[ge];
            Ce.type === l && D.push(Ce), Ce.type === o && j.push(Ce);
          }
        }
      }
    } else if (k.length)
      for (let j = k.length - 1; j >= 0; j--) {
        const X = x(k[j], M);
        if (X.length > 1 || X.length === 1 && !X[0].path.isVariableDeclaration()) {
          D.push(...X);
          break;
        }
      }
    return D;
  }
  function x(k, M) {
    let D = [];
    if (k.isIfStatement())
      D = h(k.get("consequent"), D, M), D = h(k.get("alternate"), D, M);
    else {
      if (k.isDoExpression() || k.isFor() || k.isWhile() || k.isLabeledStatement())
        return h(k.get("body"), D, M);
      if (k.isProgram() || k.isBlockStatement())
        return w(k.get("body"), M);
      if (k.isFunction())
        return x(k.get("body"), M);
      if (k.isTryStatement())
        D = h(k.get("block"), D, M), D = h(k.get("handler"), D, M);
      else {
        if (k.isCatchClause())
          return h(k.get("body"), D, M);
        if (k.isSwitchStatement())
          return y(k.get("cases"), D, M);
        if (k.isSwitchCase())
          return w(k.get("consequent"), {
            canHaveBreak: !0,
            shouldPopulateBreak: !1,
            inCaseClause: !0
          });
        k.isBreakStatement() ? D.push(c(k)) : D.push(u(k));
      }
    }
    return D;
  }
  function O() {
    return x(this, {
      canHaveBreak: !1,
      shouldPopulateBreak: !1,
      inCaseClause: !1
    }).map((M) => M.path);
  }
  function _(k) {
    return e.default.get({
      parentPath: this.parentPath,
      parent: this.parent,
      container: this.container,
      listKey: this.listKey,
      key: k
    }).setContext(this.context);
  }
  function K() {
    return this.getSibling(this.key - 1);
  }
  function R() {
    return this.getSibling(this.key + 1);
  }
  function B() {
    let k = this.key, M = this.getSibling(++k);
    const D = [];
    for (; M.node; )
      D.push(M), M = this.getSibling(++k);
    return D;
  }
  function C() {
    let k = this.key, M = this.getSibling(--k);
    const D = [];
    for (; M.node; )
      D.push(M), M = this.getSibling(--k);
    return D;
  }
  function L(k, M = !0) {
    M === !0 && (M = this.context);
    const D = k.split(".");
    return D.length === 1 ? this._getKey(k, M) : this._getPattern(D, M);
  }
  function F(k, M) {
    const D = this.node, j = D[k];
    return Array.isArray(j) ? j.map((X, W) => e.default.get({
      listKey: k,
      parentPath: this,
      parent: D,
      container: j,
      key: W
    }).setContext(M)) : e.default.get({
      parentPath: this,
      parent: D,
      container: D,
      key: k
    }).setContext(M);
  }
  function te(k, M) {
    let D = this;
    for (const j of k)
      j === "." ? D = D.parentPath : Array.isArray(D) ? D = D[j] : D = D.get(j, M);
    return D;
  }
  function Z(k) {
    return r(this.node, k);
  }
  function J(k) {
    return i(this.node, k);
  }
  function ce(k = !1, M = !1) {
    const j = [this], X = /* @__PURE__ */ Object.create(null);
    for (; j.length; ) {
      const W = j.shift();
      if (!W || !W.node)
        continue;
      const ae = r.keys[W.node.type];
      if (W.isIdentifier()) {
        k ? (X[W.node.name] = X[W.node.name] || []).push(W) : X[W.node.name] = W;
        continue;
      }
      if (W.isExportDeclaration()) {
        const ie = W.get("declaration");
        s(ie) && j.push(ie);
        continue;
      }
      if (M) {
        if (W.isFunctionDeclaration()) {
          j.push(W.get("id"));
          continue;
        }
        if (W.isFunctionExpression())
          continue;
      }
      if (ae)
        for (let ie = 0; ie < ae.length; ie++) {
          const ge = ae[ie], Ce = W.get(ge);
          Array.isArray(Ce) ? j.push(...Ce) : Ce.node && j.push(Ce);
        }
    }
    return X;
  }
  function me(k = !1) {
    return this.getBindingIdentifierPaths(k, !0);
  }
  return ze;
}
var Ci = {};
Object.defineProperty(Ci, "__esModule", {
  value: !0
});
Ci.addComment = i5;
Ci.addComments = s5;
Ci.shareCommentsWithSiblings = r5;
var ZR = Ae();
const {
  addComment: e5,
  addComments: t5
} = ZR;
function r5() {
  if (typeof this.key == "string")
    return;
  const e = this.node;
  if (!e)
    return;
  const t = e.trailingComments, r = e.leadingComments;
  if (!t && !r)
    return;
  const i = this.getSibling(this.key - 1), s = this.getSibling(this.key + 1), n = !!i.node, a = !!s.node;
  n && (r && i.addComments("trailing", Nu(r, i.node.trailingComments)), t && !a && i.addComments("trailing", t)), a && (t && s.addComments("leading", Nu(t, s.node.leadingComments)), r && !n && s.addComments("leading", r));
}
function Nu(e, t) {
  if (!t)
    return e;
  let r = -1;
  return e.filter((i) => {
    const s = t.indexOf(i, r);
    if (s === -1)
      return !0;
    r = s;
  });
}
function i5(e, t, r) {
  e5(this.node, e, t, r);
}
function s5(e, t) {
  t5(this.node, e, t);
}
var Ye = {};
Object.defineProperty(Ye, "__esModule", {
  value: !0
});
Ye.isBindingIdentifier = I5;
Ye.isBlockScoped = D5;
Ye.isExistentialTypeParam = U5;
Ye.isExpression = O5;
Ye.isFlow = F5;
Ye.isForAwaitStatement = $5;
Ye.isGenerated = M5;
Ye.isNumericLiteralTypeAnnotation = V5;
Ye.isPure = B5;
Ye.isReferenced = _5;
Ye.isReferencedIdentifier = A5;
Ye.isReferencedMemberExpression = C5;
Ye.isRestProperty = j5;
Ye.isScope = N5;
Ye.isSpreadProperty = R5;
Ye.isStatement = w5;
Ye.isUser = L5;
Ye.isVar = k5;
var n5 = Ae();
const {
  isBinding: a5,
  isBlockScoped: o5,
  isExportDeclaration: l5,
  isExpression: u5,
  isFlow: c5,
  isForStatement: f5,
  isForXStatement: p5,
  isIdentifier: up,
  isImportDeclaration: h5,
  isImportSpecifier: d5,
  isJSXIdentifier: m5,
  isJSXMemberExpression: y5,
  isMemberExpression: T5,
  isRestElement: cp,
  isReferenced: yo,
  isScope: S5,
  isStatement: b5,
  isVar: g5,
  isVariableDeclaration: E5,
  react: P5,
  isForOfStatement: x5
} = n5, {
  isCompatTag: v5
} = P5;
function A5(e) {
  const {
    node: t,
    parent: r
  } = this;
  if (!up(t, e) && !y5(r, e))
    if (m5(t, e)) {
      if (v5(t.name))
        return !1;
    } else
      return !1;
  return yo(t, r, this.parentPath.parent);
}
function C5() {
  const {
    node: e,
    parent: t
  } = this;
  return T5(e) && yo(e, t);
}
function I5() {
  const {
    node: e,
    parent: t
  } = this, r = this.parentPath.parent;
  return up(e) && a5(e, t, r);
}
function w5() {
  const {
    node: e,
    parent: t
  } = this;
  return b5(e) ? !(E5(e) && (p5(t, {
    left: e
  }) || f5(t, {
    init: e
  }))) : !1;
}
function O5() {
  return this.isIdentifier() ? this.isReferencedIdentifier() : u5(this.node);
}
function N5() {
  return S5(this.node, this.parent);
}
function _5() {
  return yo(this.node, this.parent);
}
function D5() {
  return o5(this.node);
}
function k5() {
  return g5(this.node);
}
function L5() {
  return this.node && !!this.node.loc;
}
function M5() {
  return !this.isUser();
}
function B5(e) {
  return this.scope.isPure(this.node, e);
}
function F5() {
  const {
    node: e
  } = this;
  return c5(e) ? !0 : h5(e) ? e.importKind === "type" || e.importKind === "typeof" : l5(e) ? e.exportKind === "type" : d5(e) ? e.importKind === "type" || e.importKind === "typeof" : !1;
}
function j5() {
  return cp(this.node) && this.parentPath && this.parentPath.isObjectPattern();
}
function R5() {
  return cp(this.node) && this.parentPath && this.parentPath.isObjectExpression();
}
function $5() {
  return x5(this.node, {
    await: !0
  });
}
function U5() {
  throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
}
function V5() {
  throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
}
var _u;
function br() {
  if (_u)
    return Tt;
  _u = 1, Object.defineProperty(Tt, "__esModule", {
    value: !0
  }), Tt.default = Tt.SHOULD_STOP = Tt.SHOULD_SKIP = Tt.REMOVED = void 0;
  var e = we, t = _N, r = tn(), i = Gc(), s = Ae(), n = s, a = Ze, o = Ti, l = yt, u = Zt, c = h3(), p = Hs, h = Tr, y = Ke, P = $R(), v = VR(), w = zR(), x = QR(), O = Ci, _ = Ye;
  const {
    validate: K
  } = s, R = t("babel"), B = 1;
  Tt.REMOVED = B;
  const C = 2;
  Tt.SHOULD_STOP = C;
  const L = 4;
  Tt.SHOULD_SKIP = L;
  class F {
    constructor(J, ce) {
      this.contexts = [], this.state = null, this.opts = null, this._traverseFlags = 0, this.skipKeys = null, this.parentPath = null, this.container = null, this.listKey = null, this.key = null, this.node = null, this.type = null, this.parent = ce, this.hub = J, this.data = null, this.context = null, this.scope = null;
    }
    static get({
      hub: J,
      parentPath: ce,
      parent: me,
      container: k,
      listKey: M,
      key: D
    }) {
      if (!J && ce && (J = ce.hub), !me)
        throw new Error("To get a node path the parent needs to exist");
      const j = k[D];
      let X = a.path.get(me);
      X || (X = /* @__PURE__ */ new Map(), a.path.set(me, X));
      let W = X.get(j);
      return W || (W = new F(J, me), j && X.set(j, W)), W.setup(ce, k, M, D), W;
    }
    getScope(J) {
      return this.isScope() ? new i.default(this) : J;
    }
    setData(J, ce) {
      return this.data == null && (this.data = /* @__PURE__ */ Object.create(null)), this.data[J] = ce;
    }
    getData(J, ce) {
      this.data == null && (this.data = /* @__PURE__ */ Object.create(null));
      let me = this.data[J];
      return me === void 0 && ce !== void 0 && (me = this.data[J] = ce), me;
    }
    hasNode() {
      return this.node != null;
    }
    buildCodeFrameError(J, ce = SyntaxError) {
      return this.hub.buildError(this.node, J, ce);
    }
    traverse(J, ce) {
      (0, r.default)(this.node, J, this.scope, ce, this);
    }
    set(J, ce) {
      K(this.node, J, ce), this.node[J] = ce;
    }
    getPathLocation() {
      const J = [];
      let ce = this;
      do {
        let me = ce.key;
        ce.inList && (me = `${ce.listKey}[${me}]`), J.unshift(me);
      } while (ce = ce.parentPath);
      return J.join(".");
    }
    debug(J) {
      R.enabled && R(`${this.getPathLocation()} ${this.type}: ${J}`);
    }
    toString() {
      return (0, o.default)(this.node).code;
    }
    get inList() {
      return !!this.listKey;
    }
    set inList(J) {
      J || (this.listKey = null);
    }
    get parentKey() {
      return this.listKey || this.key;
    }
    get shouldSkip() {
      return !!(this._traverseFlags & L);
    }
    set shouldSkip(J) {
      J ? this._traverseFlags |= L : this._traverseFlags &= ~L;
    }
    get shouldStop() {
      return !!(this._traverseFlags & C);
    }
    set shouldStop(J) {
      J ? this._traverseFlags |= C : this._traverseFlags &= ~C;
    }
    get removed() {
      return !!(this._traverseFlags & B);
    }
    set removed(J) {
      J ? this._traverseFlags |= B : this._traverseFlags &= ~B;
    }
  }
  Object.assign(F.prototype, l, u, c, p, h, y, P, v, w, x, O), F.prototype._guessExecutionStatusRelativeToDifferentFunctions = y._guessExecutionStatusRelativeTo;
  for (const Z of n.TYPES) {
    const J = `is${Z}`, ce = n[J];
    F.prototype[J] = function(me) {
      return ce(this.node, me);
    }, F.prototype[`assert${Z}`] = function(me) {
      if (!ce(this.node, me))
        throw new TypeError(`Expected node path of type ${Z}`);
    };
  }
  Object.assign(F.prototype, _);
  for (const Z of Object.keys(e))
    Z[0] !== "_" && (n.TYPES.includes(Z) || n.TYPES.push(Z));
  var te = F;
  return Tt.default = te, Tt;
}
var Du;
function K5() {
  if (Du)
    return Xr;
  Du = 1, Object.defineProperty(Xr, "__esModule", {
    value: !0
  }), Xr.default = void 0;
  var e = br(), t = Ae();
  const {
    VISITOR_KEYS: r
  } = t;
  class i {
    constructor(n, a, o, l) {
      this.queue = null, this.priorityQueue = null, this.parentPath = l, this.scope = n, this.state = o, this.opts = a;
    }
    shouldVisit(n) {
      const a = this.opts;
      if (a.enter || a.exit || a[n.type])
        return !0;
      const o = r[n.type];
      if (!(o != null && o.length))
        return !1;
      for (const l of o)
        if (n[l])
          return !0;
      return !1;
    }
    create(n, a, o, l) {
      return e.default.get({
        parentPath: this.parentPath,
        parent: n,
        container: a,
        key: o,
        listKey: l
      });
    }
    maybeQueue(n, a) {
      this.queue && (a ? this.queue.push(n) : this.priorityQueue.push(n));
    }
    visitMultiple(n, a, o) {
      if (n.length === 0)
        return !1;
      const l = [];
      for (let u = 0; u < n.length; u++) {
        const c = n[u];
        c && this.shouldVisit(c) && l.push(this.create(a, n, u, o));
      }
      return this.visitQueue(l);
    }
    visitSingle(n, a) {
      return this.shouldVisit(n[a]) ? this.visitQueue([this.create(n, n, a)]) : !1;
    }
    visitQueue(n) {
      this.queue = n, this.priorityQueue = [];
      const a = /* @__PURE__ */ new WeakSet();
      let o = !1;
      for (const l of n) {
        if (l.resync(), (l.contexts.length === 0 || l.contexts[l.contexts.length - 1] !== this) && l.pushContext(this), l.key === null)
          continue;
        const {
          node: u
        } = l;
        if (!a.has(u)) {
          if (u && a.add(u), l.visit()) {
            o = !0;
            break;
          }
          if (this.priorityQueue.length && (o = this.visitQueue(this.priorityQueue), this.priorityQueue = [], this.queue = n, o))
            break;
        }
      }
      for (const l of n)
        l.popContext();
      return this.queue = null, o;
    }
    visit(n, a) {
      const o = n[a];
      return o ? Array.isArray(o) ? this.visitMultiple(o, n, a) : this.visitSingle(n, a) : !1;
    }
  }
  return Xr.default = i, Xr;
}
var ku;
function To() {
  if (ku)
    return Xi;
  ku = 1, Object.defineProperty(Xi, "__esModule", {
    value: !0
  }), Xi.traverseNode = i;
  var e = K5(), t = Ae();
  const {
    VISITOR_KEYS: r
  } = t;
  function i(s, n, a, o, l, u) {
    const c = r[s.type];
    if (!c)
      return !1;
    const p = new e.default(a, n, o, l);
    for (const h of c)
      if (!(u && u[h]) && p.visit(s, h))
        return !0;
    return !1;
  }
  return Xi;
}
var en = {};
Object.defineProperty(en, "__esModule", {
  value: !0
});
en.default = void 0;
class q5 {
  getCode() {
  }
  getScope() {
  }
  addHelper() {
    throw new Error("Helpers are not supported by the default hub.");
  }
  buildError(t, r, i = TypeError) {
    return new i(r);
  }
}
en.default = q5;
var Lu;
function tn() {
  return Lu || (Lu = 1, function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "Hub", {
      enumerable: !0,
      get: function() {
        return o.default;
      }
    }), Object.defineProperty(e, "NodePath", {
      enumerable: !0,
      get: function() {
        return n.default;
      }
    }), Object.defineProperty(e, "Scope", {
      enumerable: !0,
      get: function() {
        return a.default;
      }
    }), e.visitors = e.default = void 0;
    var t = Ft;
    e.visitors = t;
    var r = Ae(), i = Ze, s = To(), n = br(), a = Gc(), o = en;
    const {
      VISITOR_KEYS: l,
      removeProperties: u,
      traverseFast: c
    } = r;
    function p(P, v = {}, w, x, O) {
      if (P) {
        if (!v.noScope && !w && P.type !== "Program" && P.type !== "File")
          throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${P.type} node without passing scope and parentPath.`);
        l[P.type] && (t.explode(v), (0, s.traverseNode)(P, v, w, x, O));
      }
    }
    var h = p;
    e.default = h, p.visitors = t, p.verify = t.verify, p.explode = t.explode, p.cheap = function(P, v) {
      c(P, v);
    }, p.node = function(P, v, w, x, O, _) {
      (0, s.traverseNode)(P, v, w, x, O, _);
    }, p.clearNode = function(P, v) {
      u(P, v), i.path.delete(P);
    }, p.removeProperties = function(P, v) {
      return c(P, p.clearNode, v), P;
    };
    function y(P, v) {
      P.node.type === v.type && (v.has = !0, P.stop());
    }
    p.hasType = function(P, v, w) {
      if (w != null && w.includes(P.type))
        return !1;
      if (P.type === v)
        return !0;
      const x = {
        has: !1,
        type: v
      };
      return p(P, {
        noScope: !0,
        denylist: w,
        enter: y
      }, null, x), x.has;
    }, p.cache = i;
  }(pn)), pn;
}
var W5 = tn();
const Y5 = /* @__PURE__ */ Mu(W5);
let Xt = {}, fp = [];
const pp = (e, t) => {
  var i, s, n, a, o, l;
  let r = (i = e.node.key) != null && i.name ? (s = e.node.key) == null ? void 0 : s.name : (n = e.node.key) == null ? void 0 : n.value;
  if (r && ((o = (a = e == null ? void 0 : e.parentPath) == null ? void 0 : a.parentPath) == null ? void 0 : o.type) === "ArrayExpression" && (r = `${(l = e == null ? void 0 : e.parentPath) == null ? void 0 : l.key}.${r}`), e.node.type !== "ExportDefaultDeclaration")
    r && t.unshift(r), pp(e.parentPath, t);
  else
    return;
}, In = (e, t, r) => {
  Object.keys(Xt).includes(t) && (pp(e, Xt[t]), Xt[t].unshift(r), fp.push(Xt[t].join(".")));
}, X5 = (e, t) => {
  Y5.default(e, {
    Property(r) {
      var i, s;
      if (r.node.value.type === "StringLiteral" && r.node.key.name) {
        const n = `${(s = (i = r.node.loc) == null ? void 0 : i.start) == null ? void 0 : s.line}-${r.node.key.name}`;
        Xt[n] = [];
      }
    },
    StringLiteral(r) {
      var s, n, a, o, l;
      const i = (n = (s = r == null ? void 0 : r.parentPath) == null ? void 0 : s.node) == null ? void 0 : n.key;
      if (i != null && i.value && ((a = r.parentPath) == null ? void 0 : a.parentPath.parentPath.node.type) === "ExportDefaultDeclaration") {
        const u = `${(l = (o = i == null ? void 0 : i.loc) == null ? void 0 : o.start) == null ? void 0 : l.line}-${i == null ? void 0 : i.value}`;
        Xt[u] = [], In(r, u, t);
      }
    },
    Identifier(r) {
      var n, a, o, l, u;
      const i = (o = (a = (n = r == null ? void 0 : r.parentPath) == null ? void 0 : n.node) == null ? void 0 : a.value) == null ? void 0 : o.properties, s = i == null ? void 0 : i.filter(
        (c) => c.key.type === "StringLiteral" && c.value.type === "StringLiteral"
      );
      if (s && s.length) {
        let c = "";
        s.forEach((p) => {
          var h, y, P, v;
          c = `${(y = (h = p == null ? void 0 : p.loc) == null ? void 0 : h.start) == null ? void 0 : y.line}-${(P = p == null ? void 0 : p.key) == null ? void 0 : P.value}`, Xt[c] = [(v = p == null ? void 0 : p.key) == null ? void 0 : v.value], In(r, c, t);
        });
      }
      if (r.node.name) {
        const c = `${(u = (l = r.node.loc) == null ? void 0 : l.start) == null ? void 0 : u.line}-${r.node.name}`;
        In(r, c, t);
      }
    }
  });
}, J5 = (e, t) => {
  const r = wn.readFileSync(e).toString();
  Xt = {};
  const i = pr.parse(r, {
    sourceType: "module"
  });
  X5(i, t ? `${e}${t}` : e);
}, H5 = (e) => {
  const t = [];
  return hp(e, t), t;
}, hp = (e, t) => {
  wn.readdirSync(e).forEach((i) => {
    const s = Bu.join(e, i), n = wn.statSync(s);
    n.isDirectory() === !0 && hp(s, t), n.isFile() === !0 && t.push(s);
  });
}, G5 = (e, t) => {
  const r = Bu.resolve(e);
  return H5(r).forEach(
    (s) => J5(s, t)
  ), fp;
}, z5 = (e, t) => {
  console.log(e);
}, o4 = (e) => ({
  name: "vite-plugin-useless-locale",
  enforce: "pre",
  // post | pre
  apply: "build",
  // build | serve
  transform(t, r, i) {
    const s = /react-i18next.*/g, n = /i18next.*/g;
    return !s.test(t) || !n.test(t) || !/i18n.*/g.test(t) || (G5(
      e == null ? void 0 : e.localePath,
      e == null ? void 0 : e.fileSuffix
    ), z5(t)), t;
  }
});
export {
  o4 as default
};
